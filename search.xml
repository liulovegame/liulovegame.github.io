<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>了解 EIP712</title>
      <link href="/2023/08/27/eip-712/"/>
      <url>/2023/08/27/eip-712/</url>
      
        <content type="html"><![CDATA[<p>以太坊钱包如 MetaMask 都支持 EIP712 —— 类型结构化消息签名标准，，让钱包可以结构化和可读的格式在签名提示中显示数据。EIP712 在安全性和可用性方面向前迈进了一大步，因为用户不再需要对难以理解的十六进制字符串签名（这是一种令人困惑、不安全的做法）。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>这个 EIP 旨在提高链下消息签名对链上的可用性。我们可以看到，因为节省 gas 以及减少链上交易的原因，采用链下消息签名的需求日益增长。现在已经被签名的消息，展示给用户的是一串难以理解的 16 进制的字符串，附带一些组成这个消息的项目的上下文。</p><h2 id="签名概述"><a href="#签名概述" class="headerlink" title="签名概述"></a>签名概述</h2><p>签名的作用或目的？<br>身份认证：证明你拥有地址的私钥；<br>不可否认：确认你的确发布过该消息；<br>完整性：确保信息没有被篡改；</p><h2 id="使用-ECDSA-签名并验证"><a href="#使用-ECDSA-签名并验证" class="headerlink" title="使用 ECDSA 签名并验证"></a>使用 ECDSA 签名并验证</h2><h3 id="什么是-ECDSA"><a href="#什么是-ECDSA" class="headerlink" title="什么是 ECDSA"></a>什么是 ECDSA</h3><p>ECDSA 可理解为以太坊、比特币对消息、交易进行签名与验证的算法与流程。在智能合约层面，我们不必多关注其算法的细节，只需理解其流程，看得懂已有项目代码，可以在项目写出对应功能代码即可。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>签名即正向算法（消息 + 私钥 + 随机数）= 签名，其中消息是公开的，私钥是隐私的，经过 ECDSA 正向算法可得到签名，即 r、s、v（不用纠结与 r、s、v 到底什么，只需要知道这就是签名即可）。<br>验证即反向算法（消息 + 签名）= 公钥，其中消息是公开的，签名是公开的，经过 ECDSA 反向算法可得到公钥，然后对比已公开的公钥。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>RLP：一种序列化的方式，其与网络传输中 json 的序列化/反序列化有一些不同，RLP 不仅兼顾网络传输，其编码特性更确保了编码后的一致性，因为每笔交易过程中要进行 Keccak256，如果不能保证编码后的一致性，会导致其 Hash 值不同，那么验证者就无法验证交易是否由同一个人发出。<br>若对上面的阐述不理解，继续看下面的内容。<br>编码方式详情见详解 <a href="https://learnblockchain.cn/books/geth/part3/rlp.html" target="_blank" rel="noopener">以太坊 RLP 编码</a>（不用过度研究）。<br>Keccak256 ：以太坊的 Hash 算法，生成 32 个字节 Hash 值。</p><h3 id="签名交易流程"><a href="#签名交易流程" class="headerlink" title="签名交易流程"></a>签名交易流程</h3><ol><li><p>构建原始交易对象</p><ul><li>nonce: 记录发起交易的账户已执行交易总数。Nonce 的值随着每个新交易的执行不断增加，这能让网络了解执行交易需要遵循的顺序，并且作为交易的重放保护。</li><li>gasPrice:该交易每单位 gas 的价格，Gas 价格目前以 Gwei 为单位（即 10^9wei），其范围是大于 0.1Gwei，可进行灵活设置。</li><li>gasLimit:该交易支付的最高 gas 上限。该上限能确保在出现交易执行问题（比如陷入无限循环）之时，交易账户不会耗尽所有资金。一旦交易执行完毕，剩余所有 gas 会返还至交易账户。</li><li>to：该交易被送往的地址（调用的合约地址或转账对方的账户地址）。</li><li>value：交易发送的以太币总量。</li><li>data:<ul><li>若该交易是以太币交易，则 data 为空；</li><li>若是部署合约，则 data 为合约的 bytecode；</li><li>若是合约调用，则需要从合约 ABI 中获取函数签名，并取函数签名 hash 值前 4 字节与所有参数的编码方式值进行拼接而成，具体参见文章 Ethereum 的合约 ABI 拓展</li></ul></li><li>chainId：防止跨链重放攻击。 -&gt;EIP155</li></ul></li><li><p>签署交易<br>签署交易可使用 MetaMask 和 ethers 库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将RPC与私钥存储在环境变量中</span></span><br><span class="line"><span class="comment">// RPC节点连接，直接用alchemy即可</span></span><br><span class="line"><span class="keyword">let</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider(process.env.RPC_URL);</span><br><span class="line"><span class="comment">// 新建钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = <span class="keyword">new</span> ethers.Wallet(process.env.PRIVATE_KEY, provider);</span><br><span class="line"><span class="comment">// 返回这个地址已经发送过多少次交易</span></span><br><span class="line"><span class="keyword">const</span> nonce = <span class="keyword">await</span> wallet.getTransactionCount();</span><br><span class="line"><span class="comment">// 构造raw TX</span></span><br><span class="line">tx = &#123;</span><br><span class="line">  nonce: nonce,</span><br><span class="line">  gasPrice: <span class="number">100000000000</span>,</span><br><span class="line">  gasLimit: <span class="number">1000000</span>,</span><br><span class="line">  to: <span class="literal">null</span>,</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  data: <span class="string">""</span>,</span><br><span class="line">  chainId: <span class="number">1</span>, <span class="comment">//也可以自动获取chainId = provider.getNetwork()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 签名，其中过程见下面详述</span></span><br><span class="line"><span class="keyword">let</span> resp = <span class="keyword">await</span> wallet.signTransaction(tx);</span><br><span class="line"><span class="built_in">console</span>.log(resp);</span><br><span class="line"><span class="comment">// 发送交易</span></span><br><span class="line"><span class="keyword">const</span> sentTxResponse = <span class="keyword">await</span> wallet.sendTransaction(tx);</span><br></pre></td></tr></table></figure><p>wallet.signTransaction 中发生了什么？<br>对(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)进行 RLP 编码；<br>对上面的 RLP 编码值进行 Keccak256 ；<br>对上面的 Keccak256 值进行 ECDSA 私钥签名（即正向算法）；<br>对上面的 ECDSA 私钥签名(v、r、s)结果与交易消息再次进行 RPL 编码，即 RLP(nonce, gasPrice, gasLimit, to, value, data, v, r, s)，可得到如下编码；</p><p>为什么步骤 1 中包含 chainId 字段，而步骤 4 中再次编码时没有 chainId 字段？原始消息内容都不一样，怎么可能会验证通过？先别急，这是因为 chainId 是被编码到签名的 v 参数中的，因此我们不会将 chainId 本身包含在最终的签名交易数据中</p></li></ol><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>交易签名发送后，以太坊节点如何进行身份认证、不可否认、完整性？</p><ol><li>对上面最终的 RPL 解码，可得到(nonce, gasPrice, gasLimit, to, value, data, v, r, s)；</li><li>对(nonce, gasPrice, gasLimit, to, value, data)和(v,r,s)ECDSA 验证（即反向算法），得到签名者的 address，细心的同学可以看到第一个括号少了 chainId，这是因为 chainId 在 ECDSA 私钥签名（即正向算法） 时被编码到了 v，所以由 v 可以直接解码出 chainId(所以在对上面的 RLP 编码值进行 Keccak256；这一步，肯定是把 chainId 复制了一下，给对上面的 Keccak256 值进行 ECDSA 私钥签名（即正向算法）；这一步用)；</li><li>对上面得到的签名者的 address 与签名者公钥推导的 address 进行比对，相等即完成身份认证、不可否认性、完整性</li></ol><p>我们可以去 <a href="https://app.mycrypto.com/broadcast-transaction" target="_blank" rel="noopener">MyCrypto - Ethereum Wallet Manager</a>，将 wallet.signTransaction 生成的编码复制进去，对上述验证步骤有一个直观的感受，比对一下 ECDSA 反向算法得出的”from”是不是自己的地址？</p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>我们注意到原始交易对象里由 Nonce 和 ChainID 两个字段，这是为了防范双花攻击\重放攻击（双花与重放是相对的，本质都是重复使用一个签名，用自己的签名做对自己有利的重复叫双花，用别人的签名做对自己有利的重复叫重放）：</p><ul><li>Nonce：账户交易计数，以太坊的账户模型中记录着每个账户 Nonce，即此账户发起过多少次交易。</li><li>ChainId：分叉链区分，比如我在以太坊链上给 evil 进行一笔转账交易，evil 又可以去以太坊经典链上重放这笔交易，这时如果我在以太坊经典上也有资产，那么会遭受损失。所以 EIP155 提议加入 ChainId，以防止跨链重放。以太坊 ChainId 为 1，以太坊经典 ChainId 为 61。</li></ul><h2 id="EIP712"><a href="#EIP712" class="headerlink" title="EIP712"></a>EIP712</h2><p>IDEX 需要在中心化服务器上进行订单的撮合，如何保证订单不会被交易所更改呢？核心就在于我们的每笔交易，在发送到中心化服务器前都会用用户自己的私钥进行签名，然后智能合约在进行结算时会对用户签名进行验证。如果中心化服务器对订单数据有任何改动，都无法通过智能合约的校验。</p><h3 id="EIP712-之前"><a href="#EIP712-之前" class="headerlink" title="EIP712 之前"></a>EIP712 之前</h3><p>加密货币领域的格言是:不信任;验证。然而，在 EIP712 之前，用户很难验证被要求签名的数据，在以签名信息作为后续交易基础的 DApp 中，很容易给予更多的信任。</p><p>由去中心化交易触发的 MetaMask 弹窗，为了安全地将与钱包地址关联起来，要求用户对订单的哈希值进行签名。不幸的是，由于这个哈希值是一个十六进制字符串，没有专业技术知识的用户无法轻松地验证这个哈希值。对于普通用户来说，更容易盲目地相信 DApp 并点击“签名”，而不是通过麻烦的技术验证。这不利于安全。</p><p>如果用户无意中登陆了一个恶意的网络钓鱼 DApp，就可能会签下错误的订单信息。例如，可以欺骗用户，让他们为一笔本来成本较低的交易支付不合理的高额以太币。</p><h3 id="EIP712-的改进"><a href="#EIP712-的改进" class="headerlink" title="EIP712 的改进"></a>EIP712 的改进</h3><p><img src="https://github.com/ethereum/EIPs/blob/master/assets/eip-712/eth_signTypedData.png?raw=true" alt="发起的交易确认"></p><p>在这里，我们不只是看到一串哈希数据了，而是能看到完整的签名数据，进而可以验证所签名的数据是不是正确的数据，有没有被攥改</p><h3 id="EIP712-的使用"><a href="#EIP712-的使用" class="headerlink" title="EIP712 的使用"></a>EIP712 的使用</h3><ul><li>‘\x19\x01’ ，固定字符串；</li><li>DOMAIN_SEPARATOR，由 constructor 中定义；</li><li>keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))，其中 PERMIT_TYPEHASH 是 constant 变量</li></ul><p>例如 PayUSD 的多签合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// EIP712 Precomputed hashes:</span><br><span class="line">// keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)&quot;)</span><br><span class="line">bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;</span><br><span class="line"></span><br><span class="line">// keccak256(&quot;Simple MultiSig&quot;)</span><br><span class="line">bytes32 constant NAME_HASH = 0xb7a0bfa1b79f2443f4d73ebb9259cddbcd510b18be6fc4da7d1aa7b1786e73e6;</span><br><span class="line"></span><br><span class="line">// keccak256(&quot;1&quot;)</span><br><span class="line">bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;</span><br><span class="line"></span><br><span class="line">// keccak256(&quot;MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address executor,uint256 gasLimit)&quot;)</span><br><span class="line">bytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;</span><br><span class="line"></span><br><span class="line">bytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constructor(uint threshold_, address[] memory owners_, uint chainId) public &#123;</span><br><span class="line">  setOwners_(threshold_, owners_);</span><br><span class="line">  DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAINTYPE_HASH,</span><br><span class="line">                                          NAME_HASH,</span><br><span class="line">                                          VERSION_HASH,</span><br><span class="line">                                          chainId,</span><br><span class="line">                                          this,</span><br><span class="line">                                          SALT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function execute(uint8[] memory sigV, bytes32[] memory sigR, bytes32[] memory sigS,</span><br><span class="line">  address destination, uint value, bytes memory data, address executor, uint gasLimit</span><br><span class="line">) external &#123;</span><br><span class="line">  // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md</span><br><span class="line">  bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));</span><br><span class="line">  bytes32 totalHash = keccak256(abi.encodePacked(&quot;\x19\x01&quot;, DOMAIN_SEPARATOR, txInputHash));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的合约代码地址在：<a href="https://github.com/christianlundkvist/simple-multisig.git" target="_blank" rel="noopener">simple-multisig</a></p><h3 id="web3-js-调用"><a href="#web3-js-调用" class="headerlink" title="web3.js 调用"></a>web3.js 调用</h3><h4 id="EIP-数据组装"><a href="#EIP-数据组装" class="headerlink" title="EIP 数据组装"></a>EIP 数据组装</h4><p>以<a href="https://github.com/christianlundkvist/simple-multisig.git" target="_blank" rel="noopener">simple-multisig</a>为例，发起签署验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.首先，定义数据类型:</span></span><br><span class="line"><span class="keyword">const</span> domain = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"name"</span>, <span class="attr">type</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"version"</span>, <span class="attr">type</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"chainId"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"verifyingContract"</span>, <span class="attr">type</span>: <span class="string">"address"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"salt"</span>, <span class="attr">type</span>: <span class="string">"bytes32"</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiSigTx = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"destination"</span>, <span class="attr">type</span>: <span class="string">"address"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"value"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"data"</span>, <span class="attr">type</span>: <span class="string">"bytes"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"nonce"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"executor"</span>, <span class="attr">type</span>: <span class="string">"address"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"gasLimit"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义域分隔符和需要签名的应用数据</span></span><br><span class="line"><span class="comment">// 合约地址</span></span><br><span class="line"><span class="keyword">const</span> verifyingContract = <span class="string">'0x0000'</span>;</span><br><span class="line"><span class="comment">// 目的地址</span></span><br><span class="line"><span class="keyword">const</span> destination = <span class="string">'0x0000'</span>;</span><br><span class="line"><span class="comment">// 需要往地址转账</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="string">'0x0000'</span>;</span><br><span class="line"><span class="comment">// 验证成功后的执行信息</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">'0xf207564e000'</span>;</span><br><span class="line"><span class="comment">// 执行地址</span></span><br><span class="line"><span class="keyword">const</span> executor = <span class="string">'0x0000'</span>;</span><br><span class="line"><span class="keyword">const</span> gasLimit = = <span class="number">3000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> domainData = &#123;</span><br><span class="line">  name: <span class="string">"Simple MultiSig"</span>,</span><br><span class="line">  version: <span class="string">"1"</span>,</span><br><span class="line">  chainId: <span class="built_in">parseInt</span>(web3.version.network, <span class="number">10</span>),</span><br><span class="line">  verifyingContract: verifyingContract,</span><br><span class="line">  salt: <span class="string">"0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = &#123;</span><br><span class="line">  destination: destination,</span><br><span class="line">  value: value,</span><br><span class="line">  data: data,</span><br><span class="line">  nonce: <span class="number">1</span>,</span><br><span class="line">  executor: executor,</span><br><span class="line">  gasLimit: gasLimit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 组装需要签名的数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  types: &#123;</span><br><span class="line">    EIP712Domain: domain,</span><br><span class="line">    MultiSigTransaction: multiSigTx,</span><br><span class="line">  &#125;,</span><br><span class="line">  domain: domainData,</span><br><span class="line">  primaryType: <span class="string">"MultiSigTransaction"</span>,</span><br><span class="line">  message: message,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于 data 的生成，可以使用 web.js 对需要执行的函数和传参进行编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threshold = <span class="number">2</span>; <span class="comment">// 替换为您要设置的 threshold 值</span></span><br><span class="line"><span class="keyword">const</span> owners = [</span><br><span class="line">  <span class="string">"0x2ca300446b23dc9a6d14030f29c686d692288461"</span>,</span><br><span class="line">  <span class="string">"0x87D908f9ae2FaBc677ae4947b943F1921D773EE2"</span>,</span><br><span class="line">  <span class="string">"0xA19E3918EFa152CD7939Ebe0a4b673B9C3842fB2"</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> functionSignature = <span class="string">"setOwners(uint8,address[])"</span>; <span class="comment">// 函数签名</span></span><br><span class="line"><span class="keyword">const</span> encodedParams = web3.eth.abi</span><br><span class="line">  .encodeParameters([<span class="string">"uint8"</span>, <span class="string">"address[]"</span>], [threshold, owners])</span><br><span class="line">  .substr(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> data =</span><br><span class="line">  web3.eth.abi.encodeFunctionSignature(functionSignature) + encodedParams; <span class="comment">// 拼接函数签名的哈希和编码后的参数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"data__"</span>, data);</span><br></pre></td></tr></table></figure><h4 id="数据签署"><a href="#数据签署" class="headerlink" title="数据签署"></a>数据签署</h4><p>可以使用小狐狸钱包发起<code>signTypedData</code>签署</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">web3.currentProvider.sendAsync(</span><br><span class="line">  &#123;</span><br><span class="line">    method: <span class="string">"eth_signTypedData_v3"</span>,</span><br><span class="line">    params: [signer, <span class="built_in">JSON</span>.stringify(data)],</span><br><span class="line">    <span class="keyword">from</span>: signer,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> signature = result.result.substring(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> r = <span class="string">"0x"</span> + signature.substring(<span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">const</span> s = <span class="string">"0x"</span> + signature.substring(<span class="number">64</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">const</span> v = <span class="built_in">parseInt</span>(signature.substring(<span class="number">128</span>, <span class="number">130</span>), <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// The signature is now comprised of r, s, and v.</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也可以使用以太坊的<code>eth-sig-util</code> 库，需要传入私钥</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethSigUtil = <span class="built_in">require</span>(<span class="string">"eth-sig-util"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = ethSigUtil.signTypedData(<span class="keyword">new</span> Buffer(privateKey, <span class="string">"hex"</span>), &#123;</span><br><span class="line">  data,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> signature = result.substring(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> r = <span class="string">"0x"</span> + signature.substring(<span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="string">"0x"</span> + signature.substring(<span class="number">64</span>, <span class="number">128</span>);</span><br><span class="line"><span class="keyword">const</span> v = <span class="built_in">parseInt</span>(signature.substring(<span class="number">128</span>, <span class="number">130</span>), <span class="number">16</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Truffle的简单使用</title>
      <link href="/2023/08/16/truffle-use/"/>
      <url>/2023/08/16/truffle-use/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是<a href="https://trufflesuite.com/" target="_blank" rel="noopener">Truffle</a><br>最全面的智能合约开发工具套件</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>合约使用的语言是 <a href="https://soliditylang.org/" target="_blank" rel="noopener">solidity</a>, 而 Truffle 是配套开发框架，在此之前需要熟悉 solidity 的语法，当然合约不完全是自己从零编写，可以参考合约库 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener">OpenZeppelin</a>，合约开发时会遵循标准<a href="https://github.com/ethereum/EIPs" target="_blank" rel="noopener">EIP</a>，在合约中实现 EIP 协议</p><h2 id="安装-Truffle"><a href="#安装-Truffle" class="headerlink" title="安装 Truffle"></a>安装 Truffle</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requirements Node.js v14 - v18</span></span><br><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure><p>安装完了之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle version</span><br></pre></td></tr></table></figure><p>Truffle 里面包含了一些库</p><ol><li>truffle 版本 - Truffle v5.11.2 (core: 5.11.2)</li><li>本地区块链 - Ganache v7.9.0</li><li>编译合约语言 - Solidity v0.6.11+commit.5ef660b1 (solc-js)</li><li>跟区块链和合约交互的 web3js - Web3.js v1.10.0</li></ol><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>在新建的目录运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle init</span><br></pre></td></tr></table></figure><p>就会生成以下目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── contracts            // Solidity 合约目录</span><br><span class="line">├── migrations           // 可编写脚本的部署文件的目录</span><br><span class="line">├── test                 // 用于测试应用程序和合约的测试文件目录</span><br><span class="line">└── truffle-config.js    // 配置文件 也可以是 truffle.js</span><br></pre></td></tr></table></figure><h3 id="合约编写"><a href="#合约编写" class="headerlink" title="合约编写"></a>合约编写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Storage.sol</span><br><span class="line">pragma solidity ^0.6.11;</span><br><span class="line"></span><br><span class="line">contract Storage &#123;</span><br><span class="line">    uint256 number;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Store value in variable</span><br><span class="line">     * @param num value to store</span><br><span class="line">     */</span><br><span class="line">    function store(uint256 num) public &#123;</span><br><span class="line">        number = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Return value</span><br><span class="line">     * @return value of &apos;number&apos;</span><br><span class="line">     */</span><br><span class="line">    function retrieve() public view returns (uint256)&#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写合约的时候注意合约的版本，编译的版本一定要和导入的版本一致</strong><br>编译的版本可以在 <code>truffle-config.js</code> 或者 <code>truffle.js</code> 配置</p><h3 id="部署编译和调试"><a href="#部署编译和调试" class="headerlink" title="部署编译和调试"></a>部署编译和调试</h3><p>为了部署我们的智能合约，我们需要连接到区块链。 Truffle 有一个内置的个人区块链，可用于测试。该区块链位于您的系统本地，不与主以太坊网络交互。</p><ul><li><p>Run Truffle Develop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure><p>truffle 会启动本地开发，会生成一个本地 RPC 接口，可以使用 web3js 交互，同时内置了 web3js，而且会生成十个账户和私钥，每个账户还内置了 ETH 的额度</p></li><li><p>truffle compile</p><p>编译合约，在进入<code>truffle develop</code>模式的时候，可以通过省略 truffle 前缀来运行 Truffle 命令</p></li><li><p>truffle migrate</p><p>部署合约，使用 Truffle migrate 开发进行迁移本地，也可以迁移指定网络，更多命令详情<a href="https://trufflesuite.com/docs/truffle/reference/command-line-options/#migrate" target="_blank" rel="noopener">migrate</a></p><p>需要在<code>migrations</code>编写部署脚本，请注意，文件名以<strong>数字为前缀，并以描述为后缀</strong>。需要编号前缀才能记录迁移是否成功运行</p><p>例如对我们上面 <code>Storage.sol</code> 合约进行部署，部署的时候也可以穿入账户和初始化信息，更多详情<a href="https://trufflesuite.com/docs/truffle/how-to/contracts/run-migrations/" target="_blank" rel="noopener">Run Migrations</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件 1_storage.js</span></span><br><span class="line"><span class="keyword">var</span> Storage = artifacts.require(<span class="string">"./Storage.sol"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(Storage);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>实例化合约，与合约交互</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先建立已部署的 Storage 合约实例</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">await</span> Storage.deployed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用合约的 store 方法 设置 number</span></span><br><span class="line">instance.store(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用合约的 retrieve 方法，返回number</span></span><br><span class="line">instance.retrieve();</span><br></pre></td></tr></table></figure></li></ul><h3 id="合约测试"><a href="#合约测试" class="headerlink" title="合约测试"></a>合约测试</h3><p>Truffle 使用 <a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a> 测试框架和 <a href="https://chaijs.com/" target="_blank" rel="noopener">Chai</a> 进行断言，为您提供一个可靠的框架来编写 JavaScript 测试。</p><p>测试的脚本写在 <code>test</code> 目录下面， 它们应该以.js 扩展名结尾，并且它们应该包含 <code>Mocha</code> 将识别为自动化测试的代码。</p><p><code>Truffle</code> 测试与 <code>Mocha</code> 的不同之处在于其功能 <code>contract()</code>, 该功能的工作原理与 <code>Mocha</code> 完全一样，<code>describe()</code>只是它启用了 <code>Truffle</code> 的 <code>clean-room</code> 功能。它的工作原理如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// storage.js</span></span><br><span class="line"><span class="keyword">const</span> Storage = artifacts.require(<span class="string">"./Storage.sol"</span>);</span><br><span class="line"></span><br><span class="line">contract(<span class="string">"Storage"</span>, (accounts) =&gt; &#123;</span><br><span class="line">  it(<span class="string">"should set number get number"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> storageContract = <span class="keyword">await</span> Storage.deployed();</span><br><span class="line">    <span class="keyword">await</span> storageContract.store(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> storageContract.retrieve();</span><br><span class="line">    assert.equal(result.toString(), <span class="number">2</span>, <span class="string">"2 wasn't in the setting"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以将测试限制为特定文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle test ./test/storage.js</span><br></pre></td></tr></table></figure><h3 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h3><ol><li>在进入<code>develop</code>的时候，可以编写一些外置的脚本，通过 <code>require</code> 的方式引入，可以减少一些定义</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>小狐狸钱包可以使用启动后的 RPC 接口链接账户，配置的 PRC 地址可以在<code>truffle.js</code>中配置</li><li>如果觉得在控制台里面查询交易后的 hash 不方便，可以装一个 <a href="https://trufflesuite.com/ganache/" target="_blank" rel="noopener">Ganache-ui</a>，方便查看</li></ol><h3 id="和外部-web3-js-交互合约"><a href="#和外部-web3-js-交互合约" class="headerlink" title="和外部 web3.js 交互合约"></a>和外部 web3.js 交互合约</h3><p><a href="https://web3js.org/" target="_blank" rel="noopener">web3.js</a> 用来跟以太坊交互的 javascript 库，以太坊使用 JSON-RPC 2.0 的协议，只要遵循协议就可以跟其交互，故 web3.js 有客户端和 Node 端，以下使用 nodejs 来交互</p><p>本地 init 一个 node 项目，以下使用的是 web3.js v1.10 版本</p><p>启动 truffle 开发环境，<code>truffle develop</code>，这个时候会在本地启动了一个 RPC 接口，构建合约，这个时候可以使用 web.js 链接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合约交互</span></span><br><span class="line"><span class="comment">// 新建 contractOpt.js</span></span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="comment">// 链上RPC接口</span></span><br><span class="line"><span class="keyword">const</span> rpcUrl = <span class="string">"http://127.0.0.1:9545/"</span>;</span><br><span class="line"><span class="comment">// 连接RPC</span></span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> Web3(rpcUrl);</span><br><span class="line"><span class="comment">// 用户地址</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 用户私钥，上链操作需要</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 合约地址，构建合约会有</span></span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 合约ABI，构建合约会有</span></span><br><span class="line"><span class="keyword">const</span> contractABI = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链上地址余额</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">  web3.eth.getBalance(address).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> balance = web3.utils.fromWei(res, <span class="string">"ether"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"balance"</span>, balance);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBalance(address);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约实例</span></span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">new</span> web3.eth.Contract(contractABI, contractAddress);</span><br><span class="line"><span class="comment">// 执行其智能合约方法，而不发送任何交易 - contract.methods.meMethods.call</span></span><br><span class="line">contract.methods.retrieve().call();</span><br><span class="line"><span class="comment">// 执行合约交易，上链操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">privateKey, contract, receiverAddress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="keyword">const</span> account = web3.eth.accounts.privateKeyToAccount(privateKey).address;</span><br><span class="line">  <span class="comment">// 执行合约方法，并传入合约函数的参数</span></span><br><span class="line">  <span class="keyword">const</span> transaction = contract.methods.verify(receiverAddress);</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    to: transaction._parent._address,</span><br><span class="line">    data: transaction.encodeABI(),</span><br><span class="line">    gas: <span class="keyword">await</span> transaction.estimateGas(&#123; <span class="attr">from</span>: account &#125;),</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 私钥签署以太坊交易</span></span><br><span class="line">  <span class="keyword">const</span> signed = <span class="keyword">await</span> web3.eth.accounts.signTransaction(options, privateKey);</span><br><span class="line">  <span class="comment">// 发送已签名的交易，上链</span></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> web3.eth.sendSignedTransaction(signed.rawTransaction);</span><br><span class="line">  <span class="built_in">console</span>.log(receipt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">send(privateKey, contract, <span class="string">"0x0000"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行脚本</span></span><br><span class="line">node contractOpt.js</span><br></pre></td></tr></table></figure><p>以上是和合约简单的交互，如果需要涉及到一些更深签署的交易需要相关的库来操作</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs + Tailwind css + Strapi CMS 使用</title>
      <link href="/2022/10/30/nextjs-and-cms/"/>
      <url>/2022/10/30/nextjs-and-cms/</url>
      
        <content type="html"><![CDATA[<p>记一次<a href="https://nextjs.org/" target="_blank" rel="noopener">Nextjs</a> + <a href="https://tailwindcss.com/" target="_blank" rel="noopener">Tailwind</a> + <a href="https://strapi.io/" target="_blank" rel="noopener">Strapi</a> 的使用</p><h2 id="为何使用"><a href="#为何使用" class="headerlink" title="为何使用"></a>为何使用</h2><ol><li>Nextjs 封装了 React，内置了丰富的路由、状态管理、SSR、SSG、SEO 等方案</li><li>Tailwind 原子类 CSS 解决方案，解决起类名、样式管理问题</li><li>strapi 作为成熟的无头 CMS，用作管理数据、权限检验、图片资源管理</li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="strapi-问题"><a href="#strapi-问题" class="headerlink" title="strapi 问题"></a>strapi 问题</h3><ol><li><p>在<code>strapi</code>初始化项目的时候如果以 TS 构建，在自定义 Server 的时候得注意先构建</p><p><a href="https://docs.strapi.io/developer-docs/latest/development/typescript.html#use-typescript-typings" target="_blank" rel="noopener">https://docs.strapi.io/developer-docs/latest/development/typescript.html#use-typescript-typings</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/server.js</span></span><br><span class="line"><span class="keyword">const</span> strapi = <span class="built_in">require</span>(<span class="string">"@strapi/strapi"</span>);</span><br><span class="line"><span class="comment">// distDir 构建后的目录</span></span><br><span class="line"><span class="keyword">const</span> app = strapi(&#123; <span class="attr">distDir</span>: <span class="string">"./dist"</span> &#125;);</span><br><span class="line">app.strart();</span><br></pre></td></tr></table></figure></li><li><p>在返回的数据结构的时候，media 图片资源没有在第二层数据后就不能添加，得安装插件来，或者写一个<code>service</code>来处理</p><p><a href="https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest/populating-fields.html#relation-media-fields" target="_blank" rel="noopener">https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest/populating-fields.html#relation-media-fields</a></p><p>可以使用 <code>strapi-plugin-populate-deep</code>这个 plugins</p></li><li><p>post 请求新建数据的时候，发送的 body 结构是 <code>{ data: &lt;Params&gt; }</code></p><p><a href="https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#create-an-entry" target="_blank" rel="noopener">https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#create-an-entry</a></p></li></ol><h3 id="Next-前端问题"><a href="#Next-前端问题" class="headerlink" title="Next 前端问题"></a>Next 前端问题</h3><ol><li>在使用 Next-i18n 国际化的时候，切换的语言是带有路径的，而且在 build 的时候会有问题</li><li>在<code>tailwind css</code>引用动态 background 的时候，得用 style 的方式</li><li>在<code>tailwind css</code>不同 media query 使用不同的展示图<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="string">"--image-url"</span>: <span class="string">`url(<span class="subst">$&#123;imageUrl&#125;</span>)`</span>,</span><br><span class="line">    <span class="string">"--image-lg-url"</span>: <span class="string">`url(<span class="subst">$&#123;imgLgUrl&#125;</span>)`</span>,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  className=<span class="string">"bg-[image:var(--image-url)] sm:bg-[image:var(--image-lg-url)]"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Next的改进"><a href="#Next的改进" class="headerlink" title="Next的改进"></a>Next的改进</h3><p>server耦合过重和缺乏产物规范标准以及和webpack耦合过深：</p><ul><li>导致几个事情比较难做不支持(难以支持)纯CSR模式：对于很多场景CSR就已经足够了，nextjs似乎很难开启纯CSR模式。</li><li>自定义CLI的实现难度较大： 业务自行开发类似next-cli的工具(如vite | esbuild | parcel |xxxpack)的版本，需要对齐nextjs复杂的产物格式(十几个自定义json文件),而这些产物也没有很好的标准。</li><li>custom server 定制难度较大：大部分公司的server都是和公司内部基建耦合，如果要在这些场景下将nextjs的server更换为公司的server实现，并不是很容易。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将 JavaScript 日期初始化为特定时区</title>
      <link href="/2022/06/24/date-timezone/"/>
      <url>/2022/06/24/date-timezone/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 的日期对象在内部使用 UTC，但根据操作计算机的本地时间显示输出。日期对象没有任何时区概念。没有声明字符串对象。它只是对自 <code>1970-01-01 00:00:00 UTC</code> 以来经过的毫秒数的度量。在输出时间时，它会自动考虑计算机的本地时区并应用于内部表示。它不适用于不同的时区。因此，我们需要借助函数和外部库来执行此类操作。</p><h3 id="使用-Intl-DateTimeFormat-和-format-方法将日期初始化为特定时区"><a href="#使用-Intl-DateTimeFormat-和-format-方法将日期初始化为特定时区" class="headerlink" title="使用 Intl.DateTimeFormat 和 format() 方法将日期初始化为特定时区"></a>使用 <code>Intl.DateTimeFormat</code> 和 <code>format()</code> 方法将日期初始化为特定时区</h3><p>Intl 对象是 JavaScript 国际化 API 的辅助工具。它为我们提供了许多用于转换日期/时间、字符串和数字的函数。<br>Intl 对象使用 <code>DateTimeFormat</code> 来格式化日期时间字符串。<br>它有一个 <code>format</code> 方法，它使用作为格式化程序参数提供的语言环境和选项获取日期并将其转换为不同的时区。此方法会将日期格式化为所需的时区并将其转换为字符串。</p><p><code>format()</code> 函数采用的参数是日期。我们需要以下参数来形成 <code>Intl.DateTimeFormat</code> 对象：</p><ol><li><code>locales</code>：它是一个包含语言和语言环境标签的字符串数组。通常，它是一个可选参数，但对于我们的目的来说是必需的。要更改时区，我们只需指定 BCP 语言代码和所需的时区。</li><li><code>options</code>：它是一个对象，用于指定执行比较的属性。它也是一个可选参数，可用于指定样式和显示单位。一些属性是 <code>second</code>、<code>minute</code>、<code>hour</code>、<code>day</code>、<code>month</code> 和 <code>year</code> 等。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeTimezone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Date in India: "</span> + date);</span><br><span class="line">  <span class="comment">// &#123; hour: 'numeric', hour12: false, minute: 'numeric', timeZoneName: 'short'&#125;</span></span><br><span class="line">  <span class="keyword">let</span> formatter = <span class="keyword">new</span> <span class="built_in">Intl</span>.DateTimeFormat(<span class="string">"en-US"</span>, &#123;</span><br><span class="line">    timeZone: <span class="string">"America/Denver"</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> usDate = formatter.format(date);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Date in USA: "</span> + usDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Date in India: Mon Jun 28 2021 08:30:00 GMT+0530 (India Standard Time)</span></span><br><span class="line"><span class="comment">// VM1504:7 Date in USA: 6/27/2021</span></span><br></pre></td></tr></table></figure><p>在上面的函数中，我们首先使用 <code>Date()</code> 构造函数创建一个 Date 对象。然后我们使用 <code>Intl.DateTimeFormat</code> 创建一个格式化程序，指定区域设置，即 BCP 语言标签 和我们要转换到的 <code>timeZone</code>。然后我们使用此格式化程序将日期转换为所需的时区。</p><h3 id="使用-toLocaleString-方法将-JavaScript-日期初始化为特定时区"><a href="#使用-toLocaleString-方法将-JavaScript-日期初始化为特定时区" class="headerlink" title="使用 toLocaleString() 方法将 JavaScript 日期初始化为特定时区"></a>使用 <code>toLocaleString()</code> 方法将 JavaScript 日期初始化为特定时区</h3><p>toLocaleString() 方法最常用于更改时区，因为它更易于使用并且可以直接在 Date 上调用。它的工作方式与 Intl.DateTimeFormat 相同。它还接受语言环境字符串和选项作为参数，并返回一个日期根据它们格式化的字符串。这种方法的优点是不像上面的方法是根据国家的时区转换时间并在字符串中返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeTimezone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Date in India: "</span> + date);</span><br><span class="line">  <span class="keyword">let</span> usDate = date.toLocaleString(<span class="string">"en-US"</span>, &#123; <span class="attr">timeZone</span>: <span class="string">"America/New_York"</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Date in USA: "</span> + usDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Date in India: Mon Jun 28 2021 08:30:00 GMT+0530 (India Standard Time)</span></span><br><span class="line"><span class="comment">// Date in USA: 6/27/2021, 11:00:00 PM</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目目录结构推荐</title>
      <link href="/2021/10/30/directory-structure/"/>
      <url>/2021/10/30/directory-structure/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├─ assets                   // 公用资源文件</span><br><span class="line">├─ constants                // 常量</span><br><span class="line">├─ components               // 所有通用组件</span><br><span class="line">│  └─ demo</span><br><span class="line">│     ├─ assets             // 仅供当前组件用的资源文件</span><br><span class="line">│     └─ index</span><br><span class="line">├─ config                   // 配置信息</span><br><span class="line">├─ hooks                    // hooks</span><br><span class="line">├─ pages                    // 页面结构</span><br><span class="line">│  └─ route1                // 对应的页面路由</span><br><span class="line">│     ├─ component          // 只供给当前路由用的组件</span><br><span class="line">│     │  ├─ component1</span><br><span class="line">│     │  │  ├─ assets</span><br><span class="line">│     │  │  ├─ style</span><br><span class="line">│     │  │  └─ index.js</span><br><span class="line">│     │  └─ component2</span><br><span class="line">│     ├─ style              // 当前页面路由样式</span><br><span class="line">│     ├─ assets             // 当前页面路由资源文件</span><br><span class="line">│     ├─ route.js           // 路由配置信息</span><br><span class="line">│     ├─ api.js             // 接口请求地址</span><br><span class="line">│     └─ index.js           // 入口</span><br><span class="line">├─ router                   // 总路由</span><br><span class="line">├─ store                    // 管理全局状态</span><br><span class="line">├─ styles                   // 全局样式、reset、配置样式</span><br><span class="line">├─ types                    // type、interface等全局接口类型</span><br><span class="line">├─ utils                    // 工具类</span><br><span class="line">├─ app.js</span><br><span class="line">└─ main.js</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>input 失去焦点重复校验</title>
      <link href="/2020/08/09/input-blur/"/>
      <url>/2020/08/09/input-blur/</url>
      
        <content type="html"><![CDATA[<p>在 input 框中，失去焦点时做了校验，并弹窗提示。<br>在点保存时又做了一遍校验，但是当在输入框输入内容后，不点击空白，直接点击保存按钮则会出现连续校验两遍的问题。<br>因为失去焦点事件是 mousedown 默认触发的，所以，在点击的按钮上阻止 mousedown 的默认事件即可。具体操作代码如下：<br>在按钮元素上绑定 onmouse 事件，函数：<br><code>event.preventDefault()</code><br>即可阻止点击按钮时触发失去焦点事件</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴脚本教程</title>
      <link href="/2020/08/09/tampermonkey/"/>
      <url>/2020/08/09/tampermonkey/</url>
      
        <content type="html"><![CDATA[<h2 id="功能注释"><a href="#功能注释" class="headerlink" title="功能注释"></a>功能注释</h2><table><thead><tr><th>属性名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>name</td><td style="text-align:center">油猴脚本的名字</td></tr><tr><td>namespace</td><td style="text-align:center">命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td></tr><tr><td>version</td><td style="text-align:center">脚本版本，油猴脚本的更新会读取这个版本号</td></tr><tr><td>description</td><td style="text-align:center">描述，用来告诉用户这个脚本是干什么用的</td></tr><tr><td>author</td><td style="text-align:center">作者名字</td></tr><tr><td>match</td><td style="text-align:center">只有匹配的网址才会执行对应的脚本，例如<code>*</code>、<code>http://*</code>、<code>http://www.baidu.com/*</code>等，参见<a href="https://developer.chrome.com/docs/extensions/mv3/match_patterns/" target="_blank" rel="noopener">谷歌开发者文档</a></td></tr><tr><td>grant</td><td style="text-align:center">指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为<code>none</code>的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td></tr><tr><td>require</td><td style="text-align:center">如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载<code>jquery</code></td></tr><tr><td>connect</td><td style="text-align:center">当用户使用<a href="https://www.tampermonkey.net/documentation.php?version=4.9&amp;ext=dhdg&amp;show=dhdg#GM_xmlhttpRequest" target="_blank" rel="noopener">GM_xmlhttpRequest</a>请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及<code>*</code>通配符</td></tr><tr><td>updateURL</td><td style="text-align:center">脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td></tr></tbody></table><h2 id="脚本权限"><a href="#脚本权限" class="headerlink" title="脚本权限"></a>脚本权限</h2><p>下面简单介绍一下grant指令那里可以填写的一些权限，详情请查看<a href="https://www.tampermonkey.net/documentation.php" target="_blank" rel="noopener">油猴脚本文档</a>。这里就简单介绍几个常用的，可以调用的函数全部以GM_作为开头。</p><table><thead><tr><th>权限名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td>unsafeWindow</td><td style="text-align:center">允许脚本可以完整访问原始页面，包括原始页面的脚本和变量。</td></tr><tr><td>GM_getValue(name,defaultValue)</td><td style="text-align:center">从油猴扩展的存储中访问数据。可以设置默认值，在没成功获取到数据的时候当做初始值。如果保存的是日期等类型的话，取出来的数据会变成文本，需要自己转换一下。</td></tr><tr><td>GM_setValue(name,value)</td><td style="text-align:center">将数据保存到存储中</td></tr><tr><td>GM_xmlhttpRequest(details)</td><td style="text-align:center">异步访问网页数据的API，这个方法比较复杂，有大量参数和回调，详情请参考官方文档。</td></tr><tr><td>GM_setClipboard(data, info)</td><td style="text-align:center">将数据复制到剪贴板中，第一个参数是要复制的数据，第二个参数是MIME类型，用于指定复制的数据类型。</td></tr><tr><td>GM_log(message)</td><td style="text-align:center">将日志打印到控制台中，可以使用F12开发者工具查看。</td></tr><tr><td>GM_addStyle(css)</td><td style="text-align:center">像网页中添加自己的样式表。</td></tr><tr><td>GM_notification(details, ondone), GM_notification(text, title, image, onclick)</td><td style="text-align:center">设置网页通知，请参考文档获取用法。</td></tr><tr><td>GM_openInTab(url, loadInBackground)</td><td style="text-align:center">在浏览器中打开网页，可以设置是否在后台打开等几个选项</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面加载时使用脚本自动跳转到新页面浏览器不会产生历史记录</title>
      <link href="/2020/08/09/auto-jump-history/"/>
      <url>/2020/08/09/auto-jump-history/</url>
      
        <content type="html"><![CDATA[<h2 id="需求场景："><a href="#需求场景：" class="headerlink" title="需求场景："></a>需求场景：</h2><ul><li>页面初始化时，获取列表数据</li><li>当某一条数据符合条件，跳转对应的页面</li><li>当用户从外部页面后退时，可以回到当前页面，此时正常显示页面内容</li></ul><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><ul><li>在页面入口脚本中，没有符合正常渲染</li><li>如果为外链使用<code>location.href</code>跳转，内部链接使用<code>react-router</code>的<code>history.push</code></li></ul><p>跳转到新页面后，按后退时不会回到当前页。在微信浏览器里，后退会直接关闭，在小米自带浏览器、夸克浏览器里，后退会回到标签页的初始页。</p><p>当长按返回箭头的时候，可以看到会话历史，历史记录也有未跳转的记录。</p><p>上百度搜了下，尝试了以下方案，均无效：</p><ul><li>加 <code>setTimeout</code> 延时再跳转</li><li>使用 <code>location.assign()</code> 代替 <code>location.href</code> 赋值</li><li>使用 <code>history.pushState</code> 手动写入当前页面 URL 后再跳转</li><li>在 <code>window.onload</code> 里执行判断并延时跳转</li><li>在 <code>window.onload</code> 里延时执行一个模拟点击事件并在该元素的点击回调中执行跳转</li></ul><p>这其中倒是发现一个奇怪的现象，就是在延时跳转前，如果手动点击过页面任意位置，或者操作页面提前渲染的按钮，表现就会一切正常，新页面后退可以正常返回当前页，完全符合需求预期</p><p>但是，使用 dispatchEvent 模拟出来的点击事件不行。</p><p>最后在 StackOverflow 上找到了一些解答（类似问题同样很少，但总算有答案）：</p><p><a href="https://html.spec.whatwg.org/multipage/history.html#location-object-setter-navigate" target="_blank" rel="noopener">HTML 标准</a> 文档对 <code>history</code> 的使用有一些规范：</p><blockquote><p>If any of the following conditions are met, let replacement flag be unset; otherwise, let it be set:<br>This Location object’s <a href="https://html.spec.whatwg.org/multipage/history.html#relevant-document" target="_blank" rel="noopener">relevant Document</a> has <a href="https://html.spec.whatwg.org/multipage/parsing.html#completely-loaded" target="_blank" rel="noopener">completely loaded</a>, or In the task in which the algorithm is running, an activation behavior is currently being processed whose <code>click</code> event’s <code>isTrusted</code> attribute is true, or In the task in which the algorithm is running, the event listener for a <code>click</code> event, whose <code>isTrusted</code> attribute is true, is being handled.</p></blockquote><p>大致的意思是：</p><p>如果满足以下任意条件之一， location 对象的 replacement 标记置为默认，否则置为 true。</p><p>（换句话说，如果不满足以下条件，对 location 进行任何操作，都不会产生新的历史记录）</p><ul><li><code>location</code>对象所在的文档已经<code>完全加载</code></li><li><code>location</code>的修改操作由<code>click</code>事件触发，且事件的<code>isTrusted</code>属性为<code>true</code>（也就是用户的真实点击操作）</li></ul><p>英文不行，没有找到<code>完全加载</code>的精确定义。但我推测对遵循 HTML 标准的浏览器来说，只有用户与页面产生互动，才表示页面真的已经“完全加载”了。</p><p>在用户对页面进行操作前，只有最终展现的页面才被认为是有效页面，之前的所有中间跳转都应该被忽略，不计入历史记录，这样才能避免后退行为出现死锁。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于flex布局的最后一行元素宽度问题</title>
      <link href="/2020/08/08/flex-finally-width/"/>
      <url>/2020/08/08/flex-finally-width/</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>问题是这样的，我有一个 list，期望做成一个固定宽度，一行排放个数不确定的列表，随着窗口的拉伸，item 宽度不变，一行排放的 item 自动填充，类似 flex 的 wrap 布局。</p><p>代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.card-list</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    margin-left: -12px;</span><br><span class="line">    margin-right: -12px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.card</span> &#123;</span></span><br><span class="line">    flex: 1 1 auto;</span><br><span class="line">    width: 252px;</span><br><span class="line">    padding-left: 12px;</span><br><span class="line">    padding-right: 12px;</span><br><span class="line">    margin-bottom: 24px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是问题来了对于最后一行的 item，显示情况就很糟糕了。<br>由于最后一行的元素更少，所以在就会占用更多的宽度，导致这些元素比其他列表的元素更宽。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在查询了 Stack Overflow 的众多问题后，发现这个是一个通用问题，并没有特别完善的 css 解决方案。<br>不过在这个问题的答案给了我一些启发 <a href="https://stackoverflow.com/questions/42767664/flex-wrapped-items-with-same-width-as-the-rest?rq=1" target="_blank" rel="noopener">css - Flex: wrapped items with same width as the rest - Stack Overflow</a></p><p>如果列表少于 4 列的时候，可以利用伪元素来控制</p><p>利用空列表项进行辅助布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.card-list</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    margin-left: -12px;</span><br><span class="line">    margin-right: -12px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.card</span> &#123;</span></span><br><span class="line">    flex: 1 1 auto;</span><br><span class="line">    width: 252px;</span><br><span class="line">    padding-left: 12px;</span><br><span class="line">    padding-right: 12px;</span><br><span class="line">    margin-bottom: 24px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.card</span><span class="selector-class">.card-empty-item</span> &#123;</span></span><br><span class="line">    cursor: default;</span><br><span class="line">    height: 0;</span><br><span class="line">    margin-top: 0;</span><br><span class="line">    margin-right: 18px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card card-empty-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card card-empty-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card card-empty-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们额外添加了三个列表项，并且将其高度设置为 0。<br>结果如下，我们看到即使最后一行没有填满也能成功布局，使每一项等宽。<br>我们看到这些额外的列表项实际也参与了 flex 布局，只是没有高度，所以在感官上不会影响。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unicode编码和解码</title>
      <link href="/2020/08/07/%20unicode/"/>
      <url>/2020/08/07/%20unicode/</url>
      
        <content type="html"><![CDATA[<h2 id="全局方法"><a href="#全局方法" class="headerlink" title="全局方法"></a>全局方法</h2><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">escape()</td><td style="text-align:center">使用转义序列替换某些字符来对字符串进行编码</td></tr><tr><td style="text-align:center">unescape()</td><td style="text-align:center">对使用 escape() 编码的字符串进行解码</td></tr><tr><td style="text-align:center">encodeURI()</td><td style="text-align:center">通过转义某些字符对 URI 进行编码</td></tr><tr><td style="text-align:center">decodeURI()</td><td style="text-align:center">对使用 encodeURI() 方法编码的字符串进行解码</td></tr><tr><td style="text-align:center">encodeURIComponent()</td><td style="text-align:center">通过某些转义字符对 URI 的组件进行编码</td></tr><tr><td style="text-align:center">deencodeURIComponent()</td><td style="text-align:center">对使用 encodeURIComponent() 方法编码的字符串进行解码</td></tr><tr><td style="text-align:center">btoa</td><td style="text-align:center">将 ascii 字符串或二进制数据转换成一个 base64 编码过的字符串，该方法不能直接作用于 Unicode 字符串。</td></tr><tr><td style="text-align:center">atob</td><td style="text-align:center">将已经被 base64 编码过的数据进行解码。</td></tr></tbody></table><h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><p><strong>escape 不编码字符有 69 个：*，+，-，.，/，@，_，0-9，a-z，A-Z</strong><br><strong>encodeURI 不编码字符有 82 个：!，#，$，&amp;，’，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z</strong><br><strong>encodeURIComponent 不编码字符有 71 个：!， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z</strong></p><h2 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h2><p>escape() 方法能够把 <code>ASCII</code> 之外的所有字符转换为 %xx 或 %uxxxx（x 表示十六进制的数字）的转义序列。从 \u000 到 \u00ff 的 Unicode 字符由转义序列 %xx 替代，其他所有 Unicode 字符由 %uxxxx 序列替代。unescape() 方法能够对 escape() 编码的字符串进行解码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"JavaScript 中国"</span>;</span><br><span class="line">s = <span class="built_in">escape</span>(s);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//返回字符串“JavaScript%u4E2D%u56FD”</span></span><br></pre></td></tr></table></figure><p>可以使用该方法对 <code>Cookie</code> 字符串进行编码，以避免与其他约定字符发生冲突，因为 <code>Cookie</code> 包含的标点符号是有限制的。</p><h2 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI"></a>encodeURI</h2><p>ECMAScript v3.0 版本推荐使用 encodeURI() 和 encodeURIComponent() 方法代替 escape() 方法，使用 decodeURI() 和 decodeURIComponent() 方法代替 unescape() 方法。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI" target="_blank" rel="noopener">encodeURI</a>是用来编码 URI 的，最常见的就是编码一个 URL。 encodeURI 会将需要编码的字符转换为 UTF-8 的格式。decodeURI 方法可以恢复到原有字符串。</p><p>encodeURI 方法不会编码下列字符：<code>:</code>, <code>/</code>, <code>;</code>, <code>?</code>，不过我们可以通过下面的 encodeURIComponent 方法来编码这些字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="string">"http://www.我.com"</span>); <span class="comment">// =&gt; "http://www.%E6%88%91.com"</span></span><br></pre></td></tr></table></figure><p>由于 <code>encodeURI</code> 不转义<code>&amp;</code>, <code>+</code>, 和 <code>=</code>。所以 URL 参数的值是无法转义的，比如我们想把 a=?传给服务器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="string">"http://www.我.com?a=?"</span>); <span class="comment">// =&gt; "http://www.%E6%88%91.com?a=?"</span></span><br></pre></td></tr></table></figure><p>服务器收到的 a 值为空，因为?是 URL 保留字符。此时我们需要用 <code>encodeURIComponent</code> 来编码！</p><h2 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent"></a>encodeURIComponent</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="noopener">encodeURIComponent</a> 是用来编码 URI 参数的。decodeURIComponent 方法可以恢复到原有字符串。<br>它只会跳过非转义字符（字母数字以及<code>-_.!~*&#39;()</code>）， URL 保留字符（<code>;,/?:@&amp;=+$#</code>）均会被转义。</p><p>由于 encodeURIComponent 能够编码差不多所有字符，当我们把编码过的/folder1/folder2/default.html 发送到服务器时时，由于<code>/</code>也将被编码，服务器将无法正确识别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; "http://www.我.com?a=%3F"</span></span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">"http://www.我.com"</span>) + <span class="string">"?a="</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">"?"</span>);</span><br></pre></td></tr></table></figure><p>因为 <code>encodeURIComponent</code> 会编码所有的 URL 保留字，所以不适合编码 URL，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">"http://www.我.com"</span>);</span><br><span class="line">(<span class="string">"http%3A%2F%2Fwww.%E6%88%91.com"</span>);</span><br></pre></td></tr></table></figure><h2 id="btoa"><a href="#btoa" class="headerlink" title="btoa"></a>btoa</h2><p>btoa：将 ascii 字符串或二进制数据转换成一个 base64 编码过的字符串，该方法不能直接作用于 Unicode 字符串。<br>atob：将已经被 base64 编码过的数据进行解码。<br><strong>注意：</strong> 因为 btoa 仅将 ascii 字符串或二进制数据进行编码，不能作用于 unicode 字符串，所以对中文的 base64 编码会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btoa(<span class="string">"hello 童童"</span>);</span><br><span class="line"><span class="comment">// InvalidCharacterError: 'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.</span></span><br></pre></td></tr></table></figure><p>如果要对中文进行 base64 编码，只需要将中文进行 encodeURIComponent 进行编码之后再进行 base64 编码即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btoa(<span class="built_in">encodeURIComponent</span>(<span class="string">"hello 童童"</span>));</span><br><span class="line"><span class="comment">// "aGVsbG8lMjAlNDAlRTQlQkElOTElRTYlQjclQTElRTclODQlQjY="</span></span><br></pre></td></tr></table></figure><p>完整的 utf8 编码字符串进行 base64 编码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整的utf8字符串base64编码与解码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">utf8ToBase64</span>(<span class="params">utf8</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(utf8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64ToUtf8</span>(<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(base64));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> base64 = uft8ToBase64(<span class="string">"hello 童童"</span>);</span><br><span class="line"><span class="comment">// "aGVsbG8lMjAlNDAlRTQlQkElOTElRTYlQjclQTElRTclODQlQjY="</span></span><br><span class="line">base64ToUtf8(base64);</span><br><span class="line"><span class="comment">// "hello 童童"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回流和重绘</title>
      <link href="/2020/08/05/reflow-repaint/"/>
      <url>/2020/08/05/reflow-repaint/</url>
      
        <content type="html"><![CDATA[<h2 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流(Reflow)"></a>回流(Reflow)</h2><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流</p><p>下面内容会导致回流:</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><h2 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h2 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a>浏览器的优化机制</h2><p>性能对比影响：回流比重绘代价要高。有时即使回流一个单一的元素，它的父元素及任何跟随它的元素也会产生回流。</p><p>浏览器会对频繁的回流或重绘操作进行优化：<br>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器会对队列进行清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当你获取布局信息的操作的时候，会强制队列刷新，比如一些常用且会导致回流的属性和方法。</p><h2 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h2><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line">el.style.padding = <span class="string">'5px'</span>;</span><br><span class="line">el.style.borderLeft = <span class="string">'1px'</span>;</span><br><span class="line">el.style.borderRight = <span class="string">'2px'</span>;</span><br></pre></td></tr></table></figure><p>每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>)</span><br><span class="line">el.style.cssText += <span class="string">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br><span class="line"></span><br><span class="line">el.className += <span class="string">'active'</span>;</span><br></pre></td></tr></table></figure><h2 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h2><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p><ol><li>使元素脱离文档流</li><li>对其进行多次修改</li><li>将元素带回到文档中。</li></ol><p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。有三种方式可以让DOM脱离文档流：</p><ol><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li><li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li></ol><p>例如批量插入节点:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">appendToElement, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.textContent = <span class="string">'text'</span>;</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure></p><p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p><p>我们可以使用这三种方式进行优化: 隐藏元素，应用修改，重新显示。这个会在展示和隐藏节点的时候，产生两次重绘</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">appendToElement, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.textContent = <span class="string">'text'</span>;</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">ul.style.display = <span class="string">'none'</span>;</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = <span class="string">'block'</span>;</span><br></pre></td></tr></table></figure><p>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">const</span> clone = ul.cloneNode(<span class="literal">true</span>);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="/2020/08/03/data-structure/"/>
      <url>/2020/08/03/data-structure/</url>
      
        <content type="html"><![CDATA[<h3 id="时间复杂度-O-1-O-n-O-n-2-O-logn-O-nlogn"><a href="#时间复杂度-O-1-O-n-O-n-2-O-logn-O-nlogn" class="headerlink" title="时间复杂度 O(1),O(n),O(n^2),O(logn),O(nlogn)"></a>时间复杂度 O(1),O(n),O(n^2),O(logn),O(nlogn)</h3><p>O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的n代表输入数据的量。</p><p>冒泡排序: <code>O(n^2)</code> 对n个数排序，需要扫描n<em>n次。<br>二分查找: <code>O(logn)</code> 当数据增大n倍时，耗时增大logn倍（这里的log是以2为底）, 每找一次排除一半的可能<br>归并排序: <code>O(nlogn)</code> 同理，就是n乘以logn，当数据增大256倍时，耗时增大256</em>8=2048倍。这个复杂度高于线性低于平方。<br>哈希算法: <code>O(1)</code> 就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</p><blockquote><p>如果a<sup>x</sup>=N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=logaN，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。2^3 = 8 即 log 8 = 3</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的内存管理</title>
      <link href="/2020/07/08/Memory-Leak/"/>
      <url>/2020/07/08/Memory-Leak/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏问题很常见的，通俗表现就是用着用着任务管理器里的内存占用越来越大。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p><h2 id="标记-清除算法（Mark-and-sweep）"><a href="#标记-清除算法（Mark-and-sweep）" class="headerlink" title="标记-清除算法（Mark-and-sweep）"></a>标记-清除算法（Mark-and-sweep）</h2><ol><li>垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</li><li>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</li><li>所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</li></ol><h2 id="常见的内存泄漏"><a href="#常见的内存泄漏" class="headerlink" title="常见的内存泄漏"></a>常见的内存泄漏</h2><h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><p>JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123; </span><br><span class="line">    bar = <span class="string">"this is a hidden global variable"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄露了一个简单的字符串，无伤大雅，但是有更糟的情况。<br>另一种意外的全局变量可能由 this 创建：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Foo 调用自己，this 指向了全局对象（window） </span></span><br><span class="line"><span class="comment">// 而不是 undefined </span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。</p><p><strong>全局变量注意事项:</strong><br>尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于 临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓 存内容无法被回收。</p><h3 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData(); </span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>); </span><br><span class="line">    <span class="keyword">if</span>(node) &#123; </span><br><span class="line">        <span class="comment">// 处理 node 和 someResource </span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。</p><h3 id="未捕获的异常-console-error"><a href="#未捕获的异常-console-error" class="headerlink" title="未捕获的异常/console.error"></a>未捕获的异常/console.error</h3><p>会打印在控制台里，你随便什么时候打开控制台，都能看见，会被保存起来。</p><h3 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123; </span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>), </span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>), </span><br><span class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>) </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    image.src = <span class="string">'http://some.url/image'</span>; </span><br><span class="line">    button.click(); </span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML); </span><br><span class="line">    <span class="comment">// 更多逻辑 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 按钮是 body 的后代元素 </span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 此时，仍旧存在一个全局的 #button 的引用 </span></span><br><span class="line">    <span class="comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <td> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 </td><td> 以外的其它节点。实际情况并非如此：此</td><td> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 </td><td> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。</td></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing; </span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (originalThing) </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>); </span><br><span class="line">  &#125;; </span><br><span class="line"> </span><br><span class="line">  theThing = &#123; </span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>), </span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(someMessage); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄露。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2020/07/05/promise/"/>
      <url>/2020/07/05/promise/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Promise是异步编程的一种解决方案，比传统的回调函数和事件更合理和强大。<br>所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事情（通常是一个异步操作）。从语法上说，Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。<br>它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p><p>特点：</p><ul><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（以失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来。</li><li>一旦状态改变，就不会再变，任何时候都是可以得到这个结果的。Promise对象的状态改变只有两种可能：*从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就会凝固，不会再变了。再对Promise对象添加回调函数也会立即得到这个结果。有了Promise对象，就可以将异步操作以同步操作的流程表达出来。</li></ul><p>缺点：<br>首先无法取消Promise，一旦新建他就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部跑出的错误无法反应到外部。当pending的时候，无法知道进展到了哪一步。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure><p>参数: <code>executor</code></p><p>executor是带有 <code>resolve</code> 和 <code>reject</code> 两个参数的函数 。Promise构造函数执行时立即调用<code>executor</code> 函数， <code>resolve</code> 和 <code>reject</code> 两个函数作为参数传递给<code>executor</code>（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。<code>resolve</code> 和 <code>reject</code> 函数被调用时，分别将promise的状态改为<code>fulfilled</code>（完成）或<code>rejected</code>（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">Promise.all(iterable)</a></h3><p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。<br>这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。</p><h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="noopener">Promise.race(iterable)</a></h3><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject" target="_blank" rel="noopener">Promise.reject(reason)</a></h3><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" target="_blank" rel="noopener">Promise.resolve(value)</a></h3><p>返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。<br>通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank" rel="noopener">Promise.prototype.catch(onRejected)</a></h3><p>添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果.</p><h3 id="Promise-prototype-then-onFulfilled-onRejected"><a href="#Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then(onFulfilled, onRejected)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">Promise.prototype.then(onFulfilled, onRejected)</a></h3><p>添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.</p><h3 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally" target="_blank" rel="noopener">Promise.prototype.finally(onFinally)</a></h3><p>添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)</p><h2 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// =&gt; 1 2 4 3</span></span><br></pre></td></tr></table></figure><p>解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success1'</span>)</span><br><span class="line">  reject(<span class="string">'error'</span>)</span><br><span class="line">  resolve(<span class="string">'success2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// =&gt; then: success1</span></span><br></pre></td></tr></table></figure><p>解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// =&gt; 1  3</span></span><br></pre></td></tr></table></figure><p>解释：promise 可以链式调用, catch在错误的时候捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========&gt;</span></span><br><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="comment">// success 1005</span></span><br><span class="line"><span class="comment">// success 1007</span></span><br></pre></td></tr></table></figure><p>解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BFC</title>
      <link href="/2020/06/28/BFC/"/>
      <url>/2020/06/28/BFC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ——<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">MDN</a></p></blockquote><h2 id="Box-css布局的基本单位"><a href="#Box-css布局的基本单位" class="headerlink" title="Box: css布局的基本单位"></a>Box: css布局的基本单位</h2><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p><ul><li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li><li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li><li>run-in: 根据上下文决定对象是内联对象还是块级对象。（CSS3）</li></ul><h2 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h2><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p><p>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p><h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li><li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><h2 id="如何产生-创建BFC"><a href="#如何产生-创建BFC" class="headerlink" title="如何产生/创建BFC"></a>如何产生/创建BFC</h2><ul><li>根元素(<code>&lt;html&gt;</code>)</li><li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li><li>绝对定位元素（元素的 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>）</li><li>行内块元素（元素的 <code>display</code> 为 <code>inline-block</code>）</li><li>表格单元格（元素的 <code>display</code> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li><li>表格标题（元素的 <code>display</code> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li><li>匿名表格单元格元素（元素的 <code>display</code>为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 <code>inline-table</code>）</li><li><code>overflow</code> 值不为 <code>visible</code> 的块元素</li><li><code>display</code> 值为 <code>flow-root</code> 的元素</li><li><code>contain</code> 值为 <code>layout</code>、<code>content</code>或 <code>paint</code> 的元素</li><li>弹性元素（<code>display</code>为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li><li>网格元素（<code>display</code>为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li><li>多列容器（元素的 <code>column-count</code> 或 <code>column-width</code> 不为 <code>auto</code>，包括 <code>column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li></ul><p>CSS样式中BFC与float元素实际应用的关联?<br>关于float元素中产生的块级元素浮动，对于拥有BFC属性的样式和内联元素（inline）以及文本，都不会被float块级元素所覆盖，也就是在实际应用，前者会跟后者同时完全展示，而非<strong>折叠</strong>或者<strong>覆盖</strong>展示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.div1</span>&#123;<span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid red;<span class="attribute">float</span>: left;<span class="attribute">background</span>: red;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.div2</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">height</span>: <span class="number">200px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid blue;<span class="attribute">background</span>: blue;<span class="attribute">display</span>: flex;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI七层协议模型和TCP/IP模型</title>
      <link href="/2020/06/16/osi-and-tcpip/"/>
      <url>/2020/06/16/osi-and-tcpip/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>OSI七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br><img src="/images/osi.png" alt="osi"><br><img src="/images/osi2.jpg" alt="osi2"></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP模型：应用层、传输层、网络层、网络接口层<br><img src="/images/tcpip.png" alt="TCP/IP"></p><ol><li><p><code>应用层</code>：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）、超文本传输协议（HTTP）、可扩展通讯和表示协议（XMPP）等。</p></li><li><p><code>传输层</code>：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，<code>TCP</code> 和 <code>UDP</code> 给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。</p></li><li><p><code>互连网络层</code>：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。</p></li><li><p><code>网络接口层</code>：对实际的网络媒体的管理，定义如何使用实际网络（如 Ethernet、SerialLine等）来传送数据。</p></li></ol><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="http的-GET-和-POST-的区别？"><a href="#http的-GET-和-POST-的区别？" class="headerlink" title="http的 GET 和 POST 的区别？"></a>http的 GET 和 POST 的区别？</h3><ol><li>GET 请求数据显示在 URL 后，POST 则在 HTTP 包体中。</li><li>GET 请求参数有限制（浏览器及服务器），POST 请求没有限制。</li><li>POST 安全性比 GET 安全性高。</li></ol><h3 id="TCP-和-UDP-区别？"><a href="#TCP-和-UDP-区别？" class="headerlink" title="TCP 和 UDP 区别？"></a>TCP 和 UDP 区别？</h3><ol><li>TCP 面向连接；UDP 无连接。</li><li>TCP 基于字节流；UDP 基于数据报文。</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 连接是点到点；UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li>TCP 首部开销 20 字节；UDP 只有 8 个字节。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 max/min-content及fit-content等width值</title>
      <link href="/2020/06/15/fill-available/"/>
      <url>/2020/06/15/fill-available/</url>
      
        <content type="html"><![CDATA[<p>一般地，有两种自适应：撑满空闲空间与收缩到内容尺寸。CSS3将这两种情况分别定义为’fill-availabel’和’fit-content’。除此之外 ，还新增了更细粒度的’min-content’和’max-content’。这四个关键字可用于设置宽高属性。</p><h3 id="fill-available"><a href="#fill-available" class="headerlink" title="fill-available"></a>fill-available</h3><p><code>width:fill-available</code>表示撑满可用空间,出现fill-available关键字值的价值在于，可以让元素的100%自动填充特性不仅仅在block水平元素上，也可以应用在其他元素，把padding和margin算在width的内部里面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span>&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.test</span>&#123;<span class="attribute">margin</span>: <span class="number">10px</span>;<span class="attribute">padding</span>:<span class="number">20px</span>;<span class="attribute">width</span>:<span class="number">100%</span>;<span class="attribute">width</span>:-webkit-fill-available;<span class="attribute">background</span>:green;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.test2</span>&#123;<span class="attribute">display</span>:inline-block;<span class="attribute">background</span>:red;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">外层</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test test2"</span>&gt;</span>inline 层<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以用来实现等高布局，于是，利用fill-available可以轻松地实现等高布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:-webkit-fill-available</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 10<span class="selector-tag">px</span>;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    background-color: pink;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#fff</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>JS<span class="tag">&lt;<span class="name">br</span>&gt;</span>jQyery<span class="tag">&lt;<span class="name">br</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h3><p><code>width:fit-content</code>也是应该比较好理解的，“shrink-to-fit”表现，换句话说，和CSS2.1中的float, absolute, inline-block的尺寸收缩表现是一样的。<br><code>width:fit-content</code>可以实现元素收缩效果的同时，保持原本的block水平状态，于是，就可以直接使用margin:auto实现元素向内自适应同时的居中效果了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">  background-color: pink;</span><br><span class="line"><span class="css">  <span class="selector-tag">width</span><span class="selector-pseudo">:-webkit-fit-content</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">margin</span><span class="selector-pseudo">:auto</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>小火柴的蓝色理想<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似地，高度也有此特性，但不常用</p><h3 id="min-content"><a href="#min-content" class="headerlink" title="min-content"></a>min-content</h3><p><code>width:min-content</code>表示采用内部元素最小宽度值最大的那个元素的宽度作为最终容器的宽度</p><p>首先，要明白这里的 <code>最小宽度值</code> 是什么意思。替换元素，例如图片的最小宽度值就是图片呈现的宽度，对于文本元素，如果全部是中文，则最小宽度值就是一个中文的宽度值；如果包含英文，因为默认英文单词不换行，所以，最小宽度可能就是里面最长的英文单词的宽度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:-webkit-min-content</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:10px;width:100px;background:lightgreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: pink;"</span>&gt;</span>小火柴的蓝色理想<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="max-content"><a href="#max-content" class="headerlink" title="max-content"></a>max-content</h3><p><code>width:max-content</code>表示采用内部元素宽度值最大的那个元素的宽度作为最终容器的宽度。如果出现文本，则相当于文本不换行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">width</span><span class="selector-pseudo">:-webkit-max-content</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:10px;width:100px;background:lightgreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: pink;"</span>&gt;</span>小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想小火柴的蓝色理想<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会发现，<code>width:max-content</code>表现得好像设置了<code>white-space:nowrap</code>一样，文字一马平川下去，元素的宽度也变成了这些文字一行显示的宽度！为什么会这么表现呢？定义就是这样的，对吧，我们对照下，首先，假设我们的容器有足够的空间，你想呀，容器足够空间，那下面的描述文字肯定一行显示了，此时，上面的div和下面的文字哪个内容宽度大，自然是文字啦，所谓<code>max-content</code>就是值采用宽度大的那个内容的宽度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa常用的中间件</title>
      <link href="/2020/06/14/koa-middleware/"/>
      <url>/2020/06/14/koa-middleware/</url>
      
        <content type="html"><![CDATA[<h2 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a><a href="https://github.com/ZijianHe/koa-router" target="_blank" rel="noopener">koa-router</a></h2><p>路由是Web框架必不可少的基础功能，koa.js为了保持自身的精简，并没有像Express.js自带了路由功能，因此koa-router做了很好的补充，作为koa星数最多的中间件，koa-router提供了全面的路由功能，比如类似Express的app.get/post/put的写法，URL命名参数、路由命名、支持加载多个中间件、嵌套路由等。</p><h2 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a><a href="https://github.com/koajs/bodyparser" target="_blank" rel="noopener">koa-bodyparser</a></h2><p>koa.js并没有内置Request Body的解析器，当我们需要解析请求体时需要加载额外的中间件，官方提供的koa-bodyparser是个很不错的选择，支持x-www-form-urlencoded, application/json等格式的请求体，但不支持form-data的请求体，需要借助 <a href="https://github.com/node-formidable/formidable" target="_blank" rel="noopener">formidable</a> 这个库，也可以直接使用 <a href="https://github.com/dlau/koa-body" target="_blank" rel="noopener">koa-body</a> 或 <a href="https://github.com/helapkg/hela" target="_blank" rel="noopener">koa-better-body</a></p><h2 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a><a href="https://github.com/koajs/static" target="_blank" rel="noopener">koa-static</a></h2><p>Node.js除了处理动态请求，也可以用作类似Nginx的静态文件服务，在本地开发时特别方便，可用于加载前端文件或后端Fake数据，可结合 <a href="https://github.com/koajs/compress" target="_blank" rel="noopener">koa-compress</a> 和 <a href="https://github.com/koajs/mount" target="_blank" rel="noopener">koa-mount</a> 使用。</p><h2 id="koa-session"><a href="#koa-session" class="headerlink" title="koa-session"></a><a href="https://github.com/koajs/session" target="_blank" rel="noopener">koa-session</a></h2><p>HTTP是无状态协议，为了保持用户状态，我们一般使用Session会话，koa-session提供了这样的功能，既支持将会话信息存储在本地Cookie，也支持存储在如Redis, MongoDB这样的外部存储设备。</p><h2 id="koa-jwt"><a href="#koa-jwt" class="headerlink" title="koa-jwt"></a><a href="https://github.com/koajs/jwt" target="_blank" rel="noopener">koa-jwt</a></h2><p>随着网站前后端分离方案的流行，越来越多的网站从Session Base转为使用Token Base，JWT(Json Web Tokens)作为一个开放的标准被很多网站采用，koa-jwt这个中间件使用JWT认证HTTP请求。</p><h2 id="koa-helmet"><a href="#koa-helmet" class="headerlink" title="koa-helmet"></a><a href="https://github.com/venables/koa-helmet" target="_blank" rel="noopener">koa-helmet</a></h2><p>网络安全得到越来越多的重视，helmet 通过增加如Strict-Transport-Security, X-Frame-Options, X-Frame-Options等HTTP头提高Express应用程序的安全性，koa-helmet为koa程序提供了类似的功能</p><h2 id="koa-compress"><a href="#koa-compress" class="headerlink" title="koa-compress"></a><a href="https://github.com/koajs/compress" target="_blank" rel="noopener">koa-compress</a></h2><p>当响应体比较大时，我们一般会启用类似Gzip的压缩技术减少传输内容，koa-compress提供了这样的功能，可根据需要进行灵活的配置。</p><h2 id="koa-logger"><a href="#koa-logger" class="headerlink" title="koa-logger"></a><a href="https://github.com/koajs/logger" target="_blank" rel="noopener">koa-logger</a></h2><p>koa-logger提供了输出请求日志的功能，包括请求的url、状态码、响应时间、响应体大小等信息，对于调试和跟踪应用程序特别有帮助，<a href="https://github.com/koajs/bunyan-logger" target="_blank" rel="noopener">koa-bunyan-logger</a> 提供了更丰富的功能。</p><h2 id="koa-views"><a href="#koa-views" class="headerlink" title="koa-views"></a><a href="https://github.com/queckezz/koa-views" target="_blank" rel="noopener">koa-views</a></h2><p>koa-views对需要进行视图模板渲染的应用是个不可缺少的中间件，支持ejs, nunjucks等众多模板引擎。</p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些题目</title>
      <link href="/2020/06/11/questions/"/>
      <url>/2020/06/11/questions/</url>
      
        <content type="html"><![CDATA[<h2 id="给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。"><a href="#给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。" class="headerlink" title="给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。"></a>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</h2><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p><p>1、 avaScript 暴力法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i, j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2、进化1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> dif = target-nums[i]</span><br><span class="line">    <span class="keyword">if</span> (temp[dif] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [temp[dif], i]</span><br><span class="line">    &#125;</span><br><span class="line">    temp[nums[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、进化2 - Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> dif = target-nums[i]</span><br><span class="line">    <span class="keyword">if</span> (map.has(dif)) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(dif), i]</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不用-eval-Function-实现加法"><a href="#不用-eval-Function-实现加法" class="headerlink" title="不用 + eval Function 实现加法"></a>不用 + eval Function 实现加法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a-(-b));</span><br></pre></td></tr></table></figure><p>使用function<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="keyword">let</span> carry = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(carry != <span class="number">0</span>)</span><br><span class="line">        sum = add(sum,carry);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">24</span>);</span><br></pre></td></tr></table></figure></p><h2 id="JS立即执行函数有几种写法"><a href="#JS立即执行函数有几种写法" class="headerlink" title="JS立即执行函数有几种写法"></a>JS立即执行函数有几种写法</h2><p>立即执行函数是在函数被声明或者定义后马上执行，其思路就是在函数体后面直接添加括号，如果需要传递参数则直接写在这个括号里面。<br>这个结构中不支持箭头函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p>这种方式支持箭头函数，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;)(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(x)&#125;)(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在function前面加<code>!</code>, <code>+</code>, <code>-</code>或者使用<code>void</code>操作符等到都可以起到函数定义后立即执行的效果，而<code>()</code>,  <code>!</code>,  <code>+</code> , <code>-</code>, <code>=</code>等运算符，都将函数声明转换成函数表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 这个方式不支持使用箭头函数<code>!</code>,此外，使用<code>!</code>来构成的话，这个整体会返回<code>true</code>,用<code>+-</code>来构成的话整体返回<code>NaN</code></p><p>可以把函数给变量变成立执行函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;<span class="built_in">console</span>.log(a)&#125;(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></p><h2 id="pseudo-class（伪类）与pseudo-element（伪元素）有什么区别？"><a href="#pseudo-class（伪类）与pseudo-element（伪元素）有什么区别？" class="headerlink" title="pseudo-class（伪类）与pseudo-element（伪元素）有什么区别？"></a>pseudo-class（伪类）与pseudo-element（伪元素）有什么区别？</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">伪元素</a>是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 每一个 &lt;p&gt; 元素的第一行。 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123; <span class="attribute">content</span>: <span class="string">"→"</span>; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span>&#123; <span class="attribute">content</span>: <span class="string">"←"</span>; &#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">CSS 伪类</a> 是添加到选择器的关键字，指定要选择的元素的特殊状态。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所有用户指针悬停的按钮 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相同点:<br>Pseudo-class和pseudo-element的语法都是以selector或者selector.class开始的。</p><p>不同点：<br>Pseudo-class的操作对象是文档树中已有的元素，而pseudo-element则创建了一个文档数外的元素。因此，Pseudo-class和pseudo-element的区别在于：有没有创建一个文档树之外的元素。<br>语法上Pseudo-class只有一个冒号，pseudo-element有两个冒号<br><code>pseudo-classes</code> 能够根据状态改变元素样式。<br><code>pseudo-elements</code> 可被用于为一个元素的 特定部分 应用样式。</p><h2 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all()"></a>实现Promise.all()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resolvedCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> promiseNum = promises.length;</span><br><span class="line">    <span class="keyword">let</span> resolvedValues = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolvedCounter++;</span><br><span class="line">        resolvedValues[i] = value;</span><br><span class="line">        <span class="keyword">if</span>(resolvedCounter === promiseNum)&#123;</span><br><span class="line">resolve(resolvedValues)</span><br><span class="line">&#125;</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reject(reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面刷新时sessionStroage会清空吗？"><a href="#页面刷新时sessionStroage会清空吗？" class="headerlink" title="页面刷新时sessionStroage会清空吗？"></a>页面刷新时sessionStroage会清空吗？</h2><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li><li>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同。</li><li>打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。</li><li>关闭对应浏览器tab，会清除对应的sessionStorage。<br>————<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">MDN</a></li></ul><h2 id="js延迟加载的方式"><a href="#js延迟加载的方式" class="headerlink" title="js延迟加载的方式"></a>js延迟加载的方式</h2><ol><li><code>defer</code> 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后</li><li><code>async</code> 该属性能够消除解析阻塞的 Javascript。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析</li><li><p>动态创建DOM方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  varelement = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  element.src = <span class="string">"defer.js"</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = downloadJSAtOnload;</span><br></pre></td></tr></table></figure></li><li><p>使用jQuery的getScript()方法</p></li></ol><h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"9007199254740991"</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"1234567899999999999"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="built_in">Math</span>.max(a.length, b.length)</span><br><span class="line">  a = a.padStart(maxLength, <span class="string">"0"</span>)</span><br><span class="line">  b = b.padStart(maxLength, <span class="string">"0"</span>)</span><br><span class="line">  <span class="keyword">let</span> f = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="string">""</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = maxLength - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    t = <span class="built_in">parseInt</span>(a[i]) + <span class="built_in">parseInt</span>(b[i]) + f</span><br><span class="line">    f = <span class="built_in">Math</span>.floor(t / <span class="number">10</span>);</span><br><span class="line">    sum = (t % <span class="number">10</span>) + sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(f === <span class="number">1</span>)&#123;</span><br><span class="line">    sum = <span class="string">"1"</span> + sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">add(a ,b); <span class="comment">//结果为：1243575099254740990</span></span><br></pre></td></tr></table></figure><h2 id="小数后位上下取整"><a href="#小数后位上下取整" class="headerlink" title="小数后位上下取整"></a>小数后位上下取整</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.234 =&gt; 1.25</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.toCeil = <span class="function"><span class="keyword">function</span>(<span class="params">toFixedNum</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//128.3    256.9000000001</span></span><br><span class="line">  <span class="comment">// return Math.ceil(this * Math.pow(10, num)) / Math.pow(10, num);</span></span><br><span class="line">  <span class="comment">//数据类型保留上</span></span><br><span class="line">  <span class="comment">// return Math.round(this * Math.pow(10, num)) / Math.pow(10, num);</span></span><br><span class="line">  <span class="keyword">let</span> numStr = (<span class="keyword">this</span> * <span class="built_in">Math</span>.pow(<span class="number">10</span>, toFixedNum)).toFixed(<span class="number">3</span>)  <span class="comment">//预留三位的小数值可以相上取整</span></span><br><span class="line">  numStr = <span class="keyword">new</span> <span class="built_in">Number</span>(numStr)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(numStr) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, toFixedNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.236 =&gt; 1.23</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.toFloor = <span class="function"><span class="keyword">function</span>(<span class="params">toFixedNum</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="keyword">this</span> * <span class="built_in">Math</span>.pow(<span class="number">10</span>, toFixedNum)) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, toFixedNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oauth2</title>
      <link href="/2020/05/26/oauth2/"/>
      <url>/2020/05/26/oauth2/</url>
      
        <content type="html"><![CDATA[<p>参考: <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a> 和 <a href="https://www.iteye.com/blog/jinnianshilongnian-2038646" target="_blank" rel="noopener">张开涛的博客</a></p><p>OAuth协议<br>第三方授权，比如两个网站合作，A站点账户可以登陆B站点，B站点账户可以登陆A站点，这样A站点就能拿到B站点相关资源，反过来也是。就做到了资源共享。那么这种授权是怎么做的呢？到底安全不安全？那么可能就要需要OAuth协议了。</p><p><img src="/images/oauth2.0.png" alt="OAuth2.0"></p><p>第一步访问授权页面（然后授权服务器返回授权页面）时，即需要预先申请的开发者信息如client_id、redirect_uri，而授权服务器在第三步用户手动授权后才用到这些信息，进行页面跳转（response状态码302，附上redirect地址和授权码等），第四步是第三部redirect_uri所指向的应用开发后台地址，是第三步的网页自动重定向所访问到的，这个后台逻辑要自己写，内容是拼接redirect_uri和授权码code参数，访问认证服务器后台，申请令牌返回。这样应用获取到令牌，此后使用令牌继续访问资源服务器获取资源进行使用，由此跳转到自己的应用页面（一般是一个绑定手机号页面，使用微信账号与之绑定，是一个注册，把微信账号access_token与手机号账号绑定，存入应用自身数据库，当然access_token存在有效期，过期后也需要在用户再次登录时在自身数据库透明更新）</p><blockquote><p>（A）用户访问客户端，后者将前者导向认证服务器。<br>（B）用户选择是否给予客户端授权。<br>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。<br>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。<br>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li>esponse_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line">    <span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line">    <span class="attribute">Cache-Control</span>: no-store</span><br><span class="line">    <span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">      "token_type":"example",</span><br><span class="line">      "expires_in":3600,</span><br><span class="line">      "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">      "example_parameter":"example_value"</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-get/set</title>
      <link href="/2020/05/24/js-setter-getter/"/>
      <url>/2020/05/24/js-setter-getter/</url>
      
        <content type="html"><![CDATA[<p>getter 和 setter 方法有什么意义？<br>在<code>java</code>中有以下体现 </p><ol><li>这两个方法可以方便增加额外功能（比如验证）。</li><li>内部存储和外部表现不同。</li><li>可以保持外部接口不变的情况下，修改内部存储方式和逻辑。</li><li>任意管理变量的生命周期和内存存储方式。</li><li>提供一个debug接口。</li><li>能够和模拟对象、序列化乃至WPF库等融合。</li><li>允许继承者改变语义。</li><li>可以将getter、setter用于lambda表达式。（大概即作为一个函数，参与函数传递和运算）</li><li>getter和setter可以有不同的访问级别。</li></ol><h2 id="js的getter"><a href="#js的getter" class="headerlink" title="js的getter"></a>js的getter</h2><p><code>get</code>语法将对象属性绑定到查询该属性时将被调用的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prop</span></span><br><span class="line"><span class="comment">// 要绑定到给定函数的属性名。</span></span><br><span class="line">&#123;<span class="keyword">get</span> prop() &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expression</span></span><br><span class="line"><span class="comment">// 从 ECMAScript 2015 开始，还可以使用一个计算属性名的表达式绑定到给定的函数。</span></span><br><span class="line">&#123;<span class="keyword">get</span> [expression]() &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。<br>尽管可以结合使用getter和setter来创建一个伪属性，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值。</p><p>使用<code>get</code>语法时应注意以下问题：</p><ul><li>可以使用数值或字符串作为标识；</li><li>必须不带参数（请参考<a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/" target="_blank" rel="noopener">Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments</a>）；</li><li>它不能与另一个 <code>get</code> 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 <code>{ get x() { }, get x() { } }</code> 和 <code>{ x: ..., get x() { } }</code>）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  log: [<span class="string">'example'</span>,<span class="string">'test'</span>],</span><br><span class="line">  <span class="keyword">get</span> latest() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.log.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.log[<span class="keyword">this</span>.log.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.latest); <span class="comment">// "test".</span></span><br></pre></td></tr></table></figure><h3 id="智能-自我复写-懒加载-getters"><a href="#智能-自我复写-懒加载-getters" class="headerlink" title="智能 / 自我复写/ 懒加载 getters"></a>智能 / 自我复写/ 懒加载 getters</h3><p>Getters 给你一种方法来定义一个对象的属性，但是在访问它们之前不会计算属性的值。 getter 延迟计算值的成本，直到需要此值，如果不需要，您就不用支付成本。</p><p>一种额外的优化技术是用智能(或称记忆化)getters 延迟属性值的计算并将其缓存以备以后访问。该值是在第一次调用getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这在以下情况下很有用：</p><ul><li>如果属性值的计算是昂贵的（占用大量RAM或CPU时间，产生工作线程，检索远程文件等）。</li><li>如果现在不需要该值。它将在稍后使用，或在某些情况下它根本不使用。</li><li>如果被使用，它将被访问几次，并且不需要重新计算，该值将永远不会被改变，或者不应该被重新计算。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> notifier() &#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>.notifier;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.notifier = <span class="built_in">document</span>.getElementById(<span class="string">'bookmarked-notification-anchor'</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="get-vs-defineProperty"><a href="#get-vs-defineProperty" class="headerlink" title="get vs defineProperty"></a><code>get</code> vs <code>defineProperty</code></h3><p>当使用 <code>get</code> 关键字时，它和<code>Object.defineProperty()</code> 有类似的效果，在<code>classes</code>中使用时，二者有细微的差别。</p><p>当使用 <code>get</code> 关键字时，属性将被定义在实例的原型上，当使用<code>Object.defineProperty()</code>时，属性将被定义在实例自身上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Example, <span class="string">'hello2'</span>, &#123;</span><br><span class="line"><span class="keyword">get</span>: function()&#123; <span class="keyword">return</span> <span class="string">'world2'</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Example();</span><br><span class="line"><span class="built_in">console</span>.log(obj.hello);</span><br><span class="line"><span class="comment">// "world"</span></span><br><span class="line"></span><br><span class="line">obj.hello2       <span class="comment">//undefined</span></span><br><span class="line">Example.hello2   <span class="comment">//"world2"</span></span><br><span class="line">Example.prototype.hello <span class="comment">//"world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'hello'</span>));</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj), <span class="string">'hello'</span></span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: false, get: function get hello() &#123; return 'world'; &#125;, set: undefined &#125;</span></span><br></pre></td></tr></table></figure><h2 id="js的setter"><a href="#js的setter" class="headerlink" title="js的setter"></a>js的setter</h2><p>当尝试设置属性时，<code>set</code>语法将对象属性绑定到要调用的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> language = &#123;</span><br><span class="line">  <span class="keyword">set</span> current(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.log.push(name);</span><br><span class="line">  &#125;,</span><br><span class="line">  log: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">language.current = <span class="string">'EN'</span>;</span><br><span class="line">language.current = <span class="string">'FA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(language.log);</span><br><span class="line"><span class="comment">// expected output: Array ["EN", "FA"]</span></span><br></pre></td></tr></table></figure></p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prop</span></span><br><span class="line"><span class="comment">// 要绑定到给定函数的属性名。</span></span><br><span class="line"><span class="comment">// val</span></span><br><span class="line"><span class="comment">// 用于保存尝试分配给prop的值的变量的一个别名。</span></span><br><span class="line">&#123;<span class="keyword">set</span> prop(val) &#123; . . . &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="comment">// 从 ECMAScript 2015 开始，还可以使用一个计算属性名的表达式绑定到给定的函数。</span></span><br><span class="line">&#123;<span class="keyword">set</span> [expression](val) &#123; . . . &#125;&#125;</span><br></pre></td></tr></table></figure><p>在 javascript 中，如果试着改变一个属性的值，那么对应的 setter 将被执行。setter 经常和 getter 连用以创建一个伪属性。不可能在具有真实值的属性上同时拥有一个 setter 器。</p><p>使用 set 语法时请注意：</p><ul><li>它的标识符可以是数字或字符串；</li><li>它必须有一个明确的参数 （详见 <a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/" target="_blank" rel="noopener">Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments</a>）；</li><li>在对象字面量中，不能为一个已有真实值的变量使用 <code>set</code> ，也不能为一个属性设置多个 <code>set</code>。<br><code>( { set x(v) { }, set x(v) { } }</code> 和 <code>{ x: ..., set x(v) { } }</code> 是不允许的 )</li></ul><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>getter和setter都可以用用 delete 操作符移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">get</span> latest()&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> latest(x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.latest;</span><br></pre></td></tr></table></figure><p>使用 defineProperty 为当前对象定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">a</span>:<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'b'</span>, &#123;</span><br><span class="line">    <span class="keyword">set</span>: function(x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = x / <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a) <span class="comment">// ==&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b) <span class="comment">// ==&gt; 6</span></span><br></pre></td></tr></table></figure><p>使用计算出的属性名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  baz: <span class="string">"bar"</span>,</span><br><span class="line">  <span class="keyword">get</span> [expr]() &#123; <span class="keyword">return</span> <span class="string">'bar'</span>; &#125;,</span><br><span class="line">  <span class="keyword">set</span> [expr](v) &#123; <span class="keyword">this</span>.baz = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.baz) <span class="comment">// ==&gt; bar</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo) <span class="comment">// ==&gt; bar</span></span><br><span class="line">obj.foo = <span class="string">"baz1"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(obj.baz) <span class="comment">// ==&gt; baz1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react setState</title>
      <link href="/2020/05/23/react-setState/"/>
      <url>/2020/05/23/react-setState/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setState(updater, [callback])</span><br><span class="line"></span><br><span class="line"><span class="comment">//updater 函数中接收的 state 和 props 都保证为最新。updater 的返回值会与 state 进行浅合并。</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">counter</span>: state.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="setState真的是异步的吗-？"><a href="#setState真的是异步的吗-？" class="headerlink" title="setState真的是异步的吗 ？"></a>setState真的是异步的吗 ？</h3><h4 id="合成事件中的setState"><a href="#合成事件中的setState" class="headerlink" title="合成事件中的setState"></a>合成事件中的setState</h4><p>首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick、onChange这些都是合成事件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的是更新前的val --&gt; 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>合成事件中的<code>setState</code>写法比较常见，点击事件里去改变<code>this.state.val</code>的状态值.</p><p>当你在<code>increment</code>中调用 <code>setState</code> 之后去 <code>console.log</code> 的时候，是属于try代码块中的执行，但是由于是合成事件，try 代码块执行完 <code>state</code> 并没有更新，所以你输入的结果是更新前的 <code>state</code> 值，这就导致了所谓的”异步”，但是当你的 try 代码块执行完的时候（也就是你的increment合成事件），这个时候会去执行 <code>finally</code> 里的代码，在 <code>finally</code> 中执行了 <code>performSyncWork</code> 方法，这个时候才会去更新你的 <code>state</code>并且渲染到UI上。</p><h3 id="生命周期函数中的setState"><a href="#生命周期函数中的setState" class="headerlink" title="生命周期函数中的setState"></a>生命周期函数中的setState</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的还是更新前的值 --&gt; 0</span></span><br><span class="line"> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>其实还是和合成事件一样，当<code>componentDidmount</code>执行的时候，react内部并没有更新，执行完<code>componentDidmount</code>后才去<code>commitUpdateQueue</code>更新。这就导致你在<code>componentDidmount</code>中<code>setState</code>完去console.log拿的结果还是更新前的值。</p><h3 id="原生事件中的setState"><a href="#原生事件中的setState" class="headerlink" title="原生事件中的setState"></a>原生事件中的setState</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的是更新后的值 --&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>原生事件是指非react合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件。</p><p>原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发click事件，到<code>requestWork</code> ,在 <code>requestWork</code> 里由于 <code>expirationTime === Sync</code> 的原因，直接走了 <code>performSyncWork</code> 去更新，并不像合成事件或钩子函数中被return，所以当你在原生事件中setState后，能同步拿到更新后的state值。</p><h3 id="setTimeout中的setState"><a href="#setTimeout中的setState" class="headerlink" title="setTimeout中的setState"></a>setTimeout中的setState</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出更新后的值 --&gt; 1</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>setTimeout</code> 中去 <code>setState</code> 并不算是一个单独的场景，它是随着你外层去决定的，因为你可以在合成事件中 <code>setTimeout</code>，可以在钩子函数中 <code>setTimeout</code>，也可以在原生事件<code>setTimeout</code>，但是不管是哪个场景下，基于event loop的模型下，<code>setTimeout</code> 中里去 setState 总能拿到最新的state值。</p><p>举个栗子，比如之前的合成事件，由于 <code>setTimeout(_ =&gt; { this.setState()}, 0)</code>是在 try 代码块中,当你 try 代码块执行到<code>setTimeout</code>的时候，把它丢到列队里，并没有去执行，而是先执行的 <code>finally</code> 代码块，等 <code>finally</code> 执行完了，<code>isBatchingUpdates</code>又变为了 false，导致最后去执行队列里的 <code>setState</code> 时候， <code>requestWork</code> 走的是和原生事件一样的 <code>expirationTime === Sync if</code>分支，所以表现就会和原生事件一样，可以同步拿到最新的state值。</p><h3 id="最后看个"><a href="#最后看个" class="headerlink" title="最后看个"></a>最后看个</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面分析的，钩子函数中的 <code>setState</code> 无法立马拿到更新后的值，所以前两次都是输出0，当执行到<code>setTimeout</code>里的时候，前面两个state的值已经被更新，由于 <code>setState</code> 批量更新的策略， <code>this.state.val</code>只对最后一次的生效，为1，而在 <code>setTimmout</code> <code>中setState</code> 是可以同步拿到更新结果，所以 <code>setTimeout</code> 中的两次输出2，3，最终结果就为0, 0, 2, 3。</p><p><strong>总结:</strong></p><ol><li><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和<code>setTimeout</code> 中都是同步的。</li><li><code>setState</code> 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的callback拿到更新后的结果。</li><li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和<code>setTimeout</code> 中不会批量更新，在“异步”中如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新。</li></ol><h3 id="setState为什么要异步"><a href="#setState为什么要异步" class="headerlink" title="setState为什么要异步"></a>setState为什么要异步</h3><p>推迟协调(reconciliation)来实现批量更新是有益的。换句话说，我们同意如果 <code>setState()</code> 总是同步的重渲染，在很多情况下都是效率很低的。为此，如果我们知道我们很可能得到多个更新，我们再去批量更新它们，这样更好。</p><p>例如，如果我们在浏览器的 <code>click</code> 句柄(handler)中，<code>Child</code> 和 <code>Parent</code> 都调用了 <code>setState</code>，则我们不希望重新渲染 <code>Child</code> 两次，而是倾向于将它们标记为脏，然后在浏览器事件结束的时候重新渲染它们。如果改成同步实现，会难以保证内部一致性，使并发更新变得不可行</p><p><code>setstate</code>除了要更动<code>this.state</code>之外，还要负责触发重新渲染，这里面要经过 React 核心 diff 算法，最终才能决定是否要进行重渲染，以及如何渲染，React 可以根据 <code>setState</code> 来自的不同的位置：事件句柄，网络响应，动画等，来为它们分配不同的优先级。</p><p>而且为了批次与效能的理由，多个 <code>setState</code> 呼叫有可能在执行过程中还需要被合并，所以它被设计以延时的来进行执行是相当合理的。</p><p><img src="/images/setState.webp" alt="setState"></p><p>在 React 的 <code>setState</code> 函数实现中，会根据一个变量 <code>isBatchingUpdates</code> 判断是直接更新 <code>this.state</code> 还是放到队列中，而 <code>isBatchingUpdates</code> 默认是 <code>false</code>，也就表示 <code>setState</code> 会同步更新 <code>this.state</code>，但是，有一个函数 <code>batchedUpdates</code>，这个函数会把 <code>isBatchingUpdates</code> 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 <code>batchedUpdates</code>，造成的后果，就是由 React 控制的事件处理过程 <code>setState</code> 不会同步更新 <code>this.state</code>。</p><h3 id="为什么直接修改this-state无效"><a href="#为什么直接修改this-state无效" class="headerlink" title="为什么直接修改this.state无效"></a>为什么直接修改this.state无效</h3><p>要知道<code>setState</code>本质是通过一个队列机制实现state更新的。 执行<code>setState</code>时，会将需要更新的state合并后放入状态队列，而不会立刻更新state，队列机制可以批量更新state。</p><p>如果不通过<code>setState</code>而直接修改<code>this.state</code>，那么这个state不会放入状态队列中，下次调用<code>setState</code>时对状态队列进行合并时，会忽略之前直接被修改的state，这样我们就无法合并了，而且实际也没有把你想要的state更新上去。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的反柯里化</title>
      <link href="/2020/05/22/js-uncurrying/"/>
      <url>/2020/05/22/js-uncurrying/</url>
      
        <content type="html"><![CDATA[<p>柯里化，是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</p><p>而反柯里化，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下:</p><ol><li>为Function原型添加uncurrying方法，并在执行的时候保存执行unCurrying的方法到self</li><li>借用apply把要借用的函数作为this环境赋给call，并传入之后的形参作为参数执行</li></ol><p>还有一个实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.call.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得把函数放在Function.prototype上不太好，也可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">tar, ...argu</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(tar, argu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>用<code>unCurrying</code>通用实现简单的实用一下试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>                        <span class="comment">// 这里的self就是Array.prototype.push方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;              <span class="comment">// rest为传入的两层参数[[1,2,3],4]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> push = <span class="built_in">Array</span>.prototype.push.unCurrying()</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;       <span class="comment">// rest:[1,2,3]</span></span><br><span class="line">  push(rest, <span class="number">4</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(rest)    <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"length"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">"0"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">push(obj, <span class="number">2</span>) <span class="comment">//&#123;0: 1, 1: 2, length: 2&#125;</span></span><br></pre></td></tr></table></figure><p>过程解析：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply([], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">[].max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么上面的</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call.apply(<span class="built_in">Array</span>.prototype.push, [obj, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(obj, <span class="number">2</span>)</span><br><span class="line">obj.push(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//&#123;0: 1, 1: 2, length: 2&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="借用其他方法"><a href="#借用其他方法" class="headerlink" title="借用其他方法"></a>借用其他方法</h3><p>反柯里化其实反映的是一种思想，即扩大方法的适用范围，仍然调用刚刚的通用<code>unCurrying</code>方法借用push方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> push = <span class="built_in">Array</span>.prototype.push.unCurrying()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">'嘻嘻'</span> &#125;</span><br><span class="line">push(obj, <span class="string">'呵呵'</span>, <span class="string">'哈哈'</span>, <span class="string">'嘿嘿'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)                </span><br><span class="line"> <span class="comment">// &#123; '0': '呵呵', '1': '哈哈', '2': '嘿嘿', a: '嘻嘻', length: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>相当于<code>obj.push(...)</code>，obj不仅多了类似于数组一样以数字作为索引的属性，还多了个类似于数组的length属性，让引擎自动管理数组成员和length属性；(文后有V8引擎实现push方法的源码)<br>这样一个数组的push方法就被借用出来，可以应用于任何其他对象了。</p><p>只要是方法，<code>unCurrying</code>就可以借用，<code>call</code>方法也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> call = <span class="built_in">Function</span>.prototype.call.unCurrying();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line">call($, <span class="built_in">document</span>, <span class="string">'demo'</span>)            <span class="comment">// #demo 元素</span></span><br></pre></td></tr></table></figure><p>相当于<code>document.$(&#39;demo&#39;)</code>，成功的借用了<code>call</code>方法，当然可以把<code>document</code>改成你希望作为<code>this</code>绑定到<code>$</code>的任何对象，比如<code>{ getElementById:T=&gt;console.log(T+&#39;呃&#39;) } // demo呃</code></p><p>在或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(that, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello "</span> + <span class="keyword">this</span>.value +<span class="string">" "</span>+[].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayHiuncurrying=sayHi.uncurrying();</span><br><span class="line"><span class="built_in">console</span>.log(sayHiuncurrying(&#123;<span class="attr">value</span>:<span class="string">'world'</span>&#125;,<span class="string">"hahaha"</span>));</span><br></pre></td></tr></table></figure><ul><li><p><code>uncurrying</code>是定义在<code>Function</code>的<code>prototype</code>上的方法，因此对所有的函数都可以使用此方法。调用时候：<code>sayHiuncurrying = sayHi.uncurrying()</code>，所以<code>uncurrying</code>中的 <code>this</code> 指向的是 <code>sayHi</code> 函数; （一般原型方法中的 <code>this</code> 不是指向原型对象<code>prototype</code>，而是指向调用对象，在这里调用对象是另一个函数，在javascript中函数也是对象）</p></li><li><p><code>call.apply(that, arguments)</code> 把 that 设置为 call 方法的上下文，然后将 <code>arguments</code> 传给 call方法，前文的例子，that 实际指向 sayHi，所以调用 <code>sayHiuncurrying(arg1, arg2, ...)</code> 相当于 <code>sayHi.call(arg1, arg2, ...)</code>;</p></li><li><p><code>sayHi.call(arg1, arg2, ...)</code>, call 函数把 arg1 当做 sayHi的上下文，然后把 arg2,… 等剩下的参数传给sayHi，因此最后相当于 <code>arg1.sayHi(arg2,...)</code>;</p></li><li><p>因此，这相当于 sayHiuncurrying(obj,args) 等于 obj.sayHi(args)。</p></li></ul><p>最后，我们反过来看，其实反柯里化相当于把原来 <code>sayHi(args)</code> 的形式，转换成了 <code>sayHiuncurrying(obj,args)</code>，使得sayHi的使用范围泛化了。 更抽象地表达， uncurryinging反柯里化，使得原来 <code>x.y(z)</code> 调用，可以转成 <code>y(x,z)</code> 形式的调用 。 假设x为x或者其他对象，这就扩大了函数的使用范围</p><h3 id="借用自己"><a href="#借用自己" class="headerlink" title="借用自己"></a>借用自己</h3><p><code>unCurrying</code>本身也是方法，也可以借用自己…-。-</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unCurrying = <span class="built_in">Function</span>.prototype.unCurrying.unCurrying()</span><br><span class="line"><span class="keyword">const</span> map = unCurrying(<span class="built_in">Array</span>.prototype.map)</span><br><span class="line">map(&#123; <span class="number">0</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="literal">null</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;, n =&gt; n + n)            </span><br><span class="line"> <span class="comment">// [8, "aa", 0]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单说，<code>函数柯里化</code>就是对高阶函数的降阶处理，缩小适用范围，创建一个针对性更强的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg1,arg2</span>)        // =&gt; <span class="title">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)</span></span><br><span class="line"><span class="function"><span class="title">function</span>(<span class="params">arg1,arg2,arg3</span>)        // =&gt; <span class="title">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)</span></span><br><span class="line"><span class="function"><span class="title">function</span>(<span class="params">arg1,arg2,arg3,arg4</span>)        // =&gt; <span class="title">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)(<span class="params">arg4</span>)</span></span><br><span class="line"><span class="function"><span class="title">function</span>(<span class="params">arg1,arg2,…,argn</span>)        // =&gt; <span class="title">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)…(<span class="params">argn</span>)</span></span><br></pre></td></tr></table></figure><p>而<code>反柯里化</code>就是反过来，增加适用范围，让方法使用场景更大。使用unCurrying, 可以把原生方法借出来，让任何对象拥有原生对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(arg1, arg2) <span class="comment">// =&gt; func(obj, arg1, arg2)</span></span><br></pre></td></tr></table></figure><p><strong>也可以这样理解：</strong><br>柯里化是在运算前提前传参，可以传递多个参数；<br>反柯里化是延迟传参，在运算时把原来已经固定的参数或者this上下文等当作参数延迟到未来传递。</p><p>V8引擎中Array.prototype.push方法源码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32(<span class="keyword">this</span>.length);</span><br><span class="line">    <span class="keyword">var</span> m = %_ArgumentsLength();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i + n] = %_Arguments(i);        <span class="comment">// 属性拷贝</span></span><br><span class="line">        <span class="keyword">this</span>.length = n + m;                    <span class="comment">// 修正length</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js parseInt和map函数</title>
      <link href="/2020/05/22/js-parseInt-and-map/"/>
      <url>/2020/05/22/js-parseInt-and-map/</url>
      
        <content type="html"><![CDATA[<p>今天看了一个js的题目[“1”,”2”,”3”].map(parseInt)，看到后脑海中浮现的答案是[1,2,3],但是看到正确答案后蒙了，仔细想想才知道原因。</p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h3><p>parseInt有两个参数，后面那个是可选参数： <code>parseInt(string, radix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。要被解析的字符串。</td></tr><tr><td>radix</td><td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</td></tr></tbody></table><p>radix表示string的基数，当radix存在时，string以radix基数解析，当radix为0或者无时，根据string来解析，”0x” 开头，以16进制解析，“0”开头，以十进制或8进制解析，1-9开头，以十进制解析</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map是对数组的每一个元素调用回调函数并返回一个包含结果的数组，有三个参数，其中一个可选参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// Return element for new_array </span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure><p><code>callback</code> 生成新数组元素的函数，使用三个参数：</p><table><thead><tr><th>currentValue</th><th>callback 数组中正在处理的当前元素。</th></tr></thead><tbody><tr><td>index可选</td><td>callback 数组中正在处理的当前元素的索引。</td></tr><tr><td>array可选</td><td>map 方法调用的数组。</td></tr></tbody></table><p><code>thisArg</code>  可选, 执行 callback 函数时值被用作this。</p><p>map中回调函数的语法：function callbackfn(value, index, array1)，可使用最多三个参数来声明回调函数。</p><p>第一参数value，数组元素的值；第二个参数index，数组元素的数组所以；array1，包含该元素的数组对象。</p><p>因此，[“1”,”2”,”3”].map(parseInt)等于[parseInt(1,0),parseInt(2,1),parseInt(3,2)]</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的柯里化</title>
      <link href="/2020/05/21/js-currying/"/>
      <url>/2020/05/21/js-currying/</url>
      
        <content type="html"><![CDATA[<p>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p>核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</p><p>按照Stoyan Stefanov –《JavaScript Pattern》作者 的说法，所谓“柯里化”就是使函数理解并处理部分应用</p><p>柯里化有3个常见作用：</p><ol><li>参数复用</li><li>提前返回</li><li>延迟计算/运行</li></ol><h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...rest1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里concat接受非数组元素参数将被当做调用者的一个元素传入</p><p>用它将一个sayHello函数柯里化试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curryingShowMsg1 = currying(sayHello, <span class="string">'小明'</span>)</span><br><span class="line">curryingShowMsg1(<span class="number">22</span>, <span class="string">'苹果'</span>)            <span class="comment">// 我叫 小明,我 22 岁了, 我喜欢吃 苹果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curryingShowMsg2 = currying(sayHello, <span class="string">'小衰'</span>, <span class="number">20</span>)</span><br><span class="line">curryingShowMsg2(<span class="string">'西瓜'</span>)               <span class="comment">// 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br></pre></td></tr></table></figure><h2 id="高阶柯里化函数"><a href="#高阶柯里化函数" class="headerlink" title="高阶柯里化函数"></a>高阶柯里化函数</h2><p>以上柯里化函数已经能解决一般需求了，但是如果要多层的柯里化总不能不断地进行currying函数的嵌套吧，我们希望经过柯里化之后的函数每次只传递一个或者多个参数，那该怎么做呢：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingHelper</span>(<span class="params">fn, len</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = len || fn.length  <span class="comment">// 第一遍运行length是函数fn一共需要的参数个数，以后是剩余所需要的参数个数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest.length &gt;= length    <span class="comment">// 检查是否传入了fn所需足够的参数</span></span><br><span class="line">        ? fn.apply(<span class="keyword">this</span>, rest)</span><br><span class="line">        : curryingHelper(currying.apply(<span class="keyword">this</span>, [fn].concat(rest)), length - rest.length)        <span class="comment">// 在通用currying函数基础上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>) &#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> betterShowMsg = curryingHelper(sayHello)</span><br><span class="line">betterShowMsg(<span class="string">'小衰'</span>, <span class="number">20</span>, <span class="string">'西瓜'</span>)      <span class="comment">// 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br><span class="line">betterShowMsg(<span class="string">'小猪'</span>)(<span class="number">25</span>, <span class="string">'南瓜'</span>)      <span class="comment">// 我叫 小猪,我 25 岁了, 我喜欢吃 南瓜</span></span><br><span class="line">betterShowMsg(<span class="string">'小明'</span>, <span class="number">22</span>)(<span class="string">'倭瓜'</span>)      <span class="comment">// 我叫 小明,我 22 岁了, 我喜欢吃 倭瓜</span></span><br><span class="line">betterShowMsg(<span class="string">'小拽'</span>)(<span class="number">28</span>)(<span class="string">'冬瓜'</span>)      <span class="comment">// 我叫 小拽,我 28 岁了, 我喜欢吃 冬瓜</span></span><br></pre></td></tr></table></figure><h2 id="疯狂柯里化函数"><a href="#疯狂柯里化函数" class="headerlink" title="疯狂柯里化函数"></a>疯狂柯里化函数</h2><p>尽管柯里化函数已经很牛了，但是它也让你必须花费点小心思在你所定义函数的参数顺序上。在一些函数式编程语言中，会定义一个特殊的“占位变量”。通常会指定下划线来干这事，如果作为一个函数的参数被传入，就表明这个是可以“跳过的”，是尚待指定的参数。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sendAjax = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, options</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> sendPost = <span class="function"><span class="keyword">function</span> (<span class="params">url, data</span>) </span>&#123;                    <span class="comment">// 当然可以这样</span></span><br><span class="line">    <span class="keyword">return</span> sendAjax(url, data, &#123; <span class="attr">type</span>: <span class="string">"POST"</span>, <span class="attr">contentType</span>: <span class="string">"application/json"</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用下划线来指定未确定的参数</span></span><br><span class="line"><span class="keyword">var</span> sendPost = sendAjax( _ , _ , &#123; <span class="attr">type</span>: <span class="string">"POST"</span>, <span class="attr">contentType</span>: <span class="string">"application/json"</span> &#125;)</span><br></pre></td></tr></table></figure><p>JS不具备这样的原生支持，可以使用一个全局占位符变量const _ = { }并且通过===来判断是否是占位符，当然你如果使用了lodash的话可以使用别的符号代替。那么可以这样改造柯里化函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crazyCurryingHelper</span>(<span class="params">fn, length, args, holes</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length    <span class="comment">// 第一遍是fn所需的参数个数，以后是</span></span><br><span class="line">  args = args || []</span><br><span class="line">  holes = holes || []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _args = args.slice(),</span><br><span class="line">        _holes = holes.slice(),</span><br><span class="line">        argLength = _args.length,        <span class="comment">// 存储接收到的args和holes的长度</span></span><br><span class="line">        holeLength = _holes.length,</span><br><span class="line">        arg, i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; rest.length; i++) &#123;</span><br><span class="line">      arg = rest[i]</span><br><span class="line">      <span class="keyword">if</span> (arg === _ &amp;&amp; holeLength) &#123;</span><br><span class="line">        holeLength--                      <span class="comment">// 循环_holes的位置</span></span><br><span class="line">        _holes.push(_holes.shift())      <span class="comment">// _holes最后一个移到第一个</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg === _) &#123;</span><br><span class="line">        _holes.push(argLength + i)          <span class="comment">// 存储_hole就是_的位置</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holeLength) &#123;              <span class="comment">// 是否还有没有填补的hole</span></span><br><span class="line">        holeLength--</span><br><span class="line">        _args.splice(_holes.shift(), <span class="number">0</span>, arg)           <span class="comment">// 在参数列表指定hole的地方插入当前参数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _args.push(arg)            <span class="comment">// 不需要填补hole,直接添加到参数列表里面</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _args.length &gt;= length                          <span class="comment">// 递归的进行柯里化</span></span><br><span class="line">        ? fn.apply(<span class="keyword">this</span>, _args)</span><br><span class="line">        : crazyCurryingHelper.call(<span class="keyword">this</span>, fn, length, _args, _holes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> betterShowMsg = crazyCurryingHelper(sayHello)</span><br><span class="line">betterShowMsg(_, <span class="number">20</span>)(<span class="string">'小衰'</span>, _, <span class="string">'西瓜'</span>)          <span class="comment">// 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br><span class="line">betterShowMsg(_, _, <span class="string">'南瓜'</span>)(<span class="string">'小猪'</span>)(<span class="number">25</span>)          <span class="comment">// 我叫 小猪,我 25 岁了, 我喜欢吃 南瓜</span></span><br><span class="line">betterShowMsg(<span class="string">'小明'</span>)(_, <span class="number">22</span>)(_, _, <span class="string">'倭瓜'</span>)          <span class="comment">// 我叫 小明,我 22 岁了, 我喜欢吃 倭瓜</span></span><br><span class="line">betterShowMsg(<span class="string">'小拽'</span>)(<span class="number">28</span>)(<span class="string">'冬瓜'</span>)          <span class="comment">// 我叫 小拽,我 28 岁了, 我喜欢吃 冬瓜</span></span><br></pre></td></tr></table></figure><h2 id="柯里化的常见用法"><a href="#柯里化的常见用法" class="headerlink" title="柯里化的常见用法"></a>柯里化的常见用法</h2><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><p>通过柯里化方法，缓存参数到闭包内部参数，然后在函数内部将缓存的参数与传入的参数组合后apply/bind/call给函数执行，来实现参数的复用，降低适用范围，提高适用性。</p><p>参看以下栗子，官员无论添加后续老婆，都能和合法老婆组合，通过柯里化方法，getWife方法就无需添加多余的合法老婆…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)      <span class="comment">// fn 指官员消化老婆的手段,args 指的是那个合法老婆</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArgs = args.concat(...rest)        <span class="comment">// 已经有的老婆和新搞定的老婆们合成一体，方便控制</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, newArgs)        <span class="comment">// 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getWife = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([...arguments].join(<span class="string">';'</span>))          <span class="comment">// allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆</span></span><br><span class="line">&#125;, <span class="string">'合法老婆'</span>)</span><br><span class="line"></span><br><span class="line">getWife(<span class="string">'老婆1'</span>, <span class="string">'老婆2'</span>, <span class="string">'老婆3'</span>)      <span class="comment">// 合法老婆;老婆1;老婆2;老婆3</span></span><br><span class="line">getWife(<span class="string">'超越韦小宝的老婆'</span>)             <span class="comment">// 合法老婆;超越韦小宝的老婆</span></span><br><span class="line">getWife(<span class="string">'超级老婆'</span>)                    <span class="comment">// 合法老婆;超级老婆</span></span><br></pre></td></tr></table></figure><h3 id="提高适用性"><a href="#提高适用性" class="headerlink" title="提高适用性"></a>提高适用性</h3><p>通用函数解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未柯里化前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i * i; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dubble</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i * <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">handler, list</span>) </span>&#123; <span class="keyword">return</span> list.map(handler); &#125;</span><br><span class="line"></span><br><span class="line">map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);        <span class="comment">// 数组的每一项平方</span></span><br><span class="line">map(square, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</span><br><span class="line">map(dubble, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);        <span class="comment">// 数组的每一项加倍</span></span><br><span class="line">map(dubble, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</span><br></pre></td></tr></table></figure><p>同一规则重复使用，带来代码的重复性，因此可以使用上面的通用柯里化实现改造一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i * i; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dubble</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i * <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">handler, ...list</span>) </span>&#123; <span class="keyword">return</span> list.map(handler); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapSQ = currying(map, square);</span><br><span class="line">mapSQ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">mapSQ([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapDB = currying(map, dubble);</span><br><span class="line">mapDB([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">mapDB([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。例如累加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curryAdd = <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _args = rest</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> _args.reduce(<span class="function">(<span class="params">sum, single</span>) =&gt;</span> sum += single)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _args.push(...rest)</span><br><span class="line">      <span class="keyword">return</span> cb</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()                        <span class="comment">// 为了保存添加的数，这里要返回一个闭包</span></span><br><span class="line">curryAdd(<span class="number">1</span>)</span><br><span class="line">curryAdd(<span class="number">2</span>)</span><br><span class="line">curryAdd(<span class="number">3</span>)</span><br><span class="line">curryAdd(<span class="number">4</span>)</span><br><span class="line">curryAdd()</span><br></pre></td></tr></table></figure><p>更通用的写法，将处理函数提取出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args)</span><br><span class="line">    &#125;</span><br><span class="line">    _args.push(...rest)</span><br><span class="line">    <span class="keyword">return</span> cb</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curryAdd = curry(<span class="function">(<span class="params">...T</span>) =&gt;</span> </span><br><span class="line">  T.reduce(<span class="function">(<span class="params">sum, single</span>) =&gt;</span> sum += single)</span><br><span class="line">)</span><br><span class="line">curryAdd(<span class="number">1</span>)</span><br><span class="line">curryAdd(<span class="number">2</span>)</span><br><span class="line">curryAdd(<span class="number">3</span>)</span><br><span class="line">curryAdd(<span class="number">4</span>)</span><br><span class="line">curryAdd()               <span class="comment">// 最后计算输出:10</span></span><br></pre></td></tr></table></figure><h3 id="函数柯里化的递归调用"><a href="#函数柯里化的递归调用" class="headerlink" title="函数柯里化的递归调用"></a>函数柯里化的递归调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"> seed </span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">retVal</span>(<span class="params"> later </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add( seed + later );</span><br><span class="line">    &#125;</span><br><span class="line">    retVal.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>每调用一次add函数，都会返回retValue函数；调用retValue函数会调用add函数，然后还是返回retValue函数，所以调用add的结果一定是返回一个retValue函数。add函数的存在意义只是为了提供闭包，这个类似的递归调用每次调用add都会生成一个新的闭包。</p><h3 id="函数组合-compose"><a href="#函数组合-compose" class="headerlink" title="函数组合(compose)"></a>函数组合(compose)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f,g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f1 = compose(f,g);</span><br><span class="line">f1(x);</span><br></pre></td></tr></table></figure><p>将传入的函数变成两个，通过组合的方式返回一个新的函数，让代码从右向左运行，而不是从内向外运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非 pointfree，因为提到了数据：name</span></span><br><span class="line"><span class="keyword">var</span> initials = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.split(<span class="string">' '</span>).map(compose(toUpperCase, head)).join(<span class="string">'. '</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointfree</span></span><br><span class="line"><span class="keyword">var</span> initials = compose(join(<span class="string">'. '</span>), map(compose(toUpperCase, head)), split(<span class="string">' '</span>));</span><br><span class="line"></span><br><span class="line">initials(<span class="string">"hunter stockton thompson"</span>);</span><br><span class="line"><span class="comment">// 'H. S. T'</span></span><br></pre></td></tr></table></figure><h3 id="Function-prototype-bind-方法也是柯里化应用"><a href="#Function-prototype-bind-方法也是柯里化应用" class="headerlink" title="Function.prototype.bind 方法也是柯里化应用"></a>Function.prototype.bind 方法也是柯里化应用</h3><p>与 call/apply 方法直接执行不同，bind 方法将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">888</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;.bind(foo);              <span class="comment">// 绑定</span></span><br><span class="line">bar();                    <span class="comment">// 888</span></span><br></pre></td></tr></table></figure></p><p>下面是一个 bind 函数的模拟，testBind 创建并返回新的函数，在新的函数中将真正要执行业务的函数绑定到实参传入的上下文，延迟执行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.testBind = <span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.apply(scope)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">x</span>: <span class="number">888</span> &#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;.testBind(foo)              <span class="comment">// 绑定</span></span><br><span class="line">bar()                    <span class="comment">// 888</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2020/05/18/js-closures/"/>
      <url>/2020/05/18/js-closures/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MDN: 函数和对其周围状态（<strong>lexical environment</strong>，词法环境）的引用捆绑在一起构成闭包（<strong>closure</strong>）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。示例：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closuresFn = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        b = b + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">    closuresFn = fn1;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line">closuresFn(); <span class="comment">//2</span></span><br><span class="line">closuresFn(); <span class="comment">//3</span></span><br><span class="line">closuresFn(); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> closuresFn = test();</span><br><span class="line">closuresFn(); <span class="comment">//2</span></span><br><span class="line">closuresFn(); <span class="comment">//3</span></span><br><span class="line">closuresFn(); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>内部函数存在引用就会产生闭包，前提也要存在后续内部函数的调用，需要return出来，或者用变量接收产生闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> local = <span class="string">'变量'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(local);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>很多人会问这为什么是闭包？之前闭包不是函数A里的函数B吗？函数B用来访问函数A的变量，称函数B是闭包，只有一个函数为什么也是闭包。其实，用两个函数形成闭包只是一般形式。闭包真正的含义是，如果一个函数访问了此函数的父级及父级以上的作用域变量，就可以称这个函数是一个闭包。</p><p>所以上面的示例2的 <code>function</code> 都可以称之为闭包（匿名闭包函数）。</p><p><strong>为什么要函数套函数呢？</strong><br>是因为需要局部变量，所以才把变量放在一个函数里，如果不把变量放在一个函数里，就是一个全局变量了，达不到使用闭包的目的——隐藏变量</p><p><strong>为什么要 return fn 呢？</strong><br>因为如果不 return，你就无法使用这个闭包。把 return fn 改成 window.fn = fn 也是一样的，只要让外面可以访问到这个 fn 函数就行了。</p><p>所以 return fn 只是为了 fn 能被使用，也跟闭包无关。</p><h2 id="在循环中创建闭包：一个常见错误"><a href="#在循环中创建闭包：一个常见错误" class="headerlink" title="在循环中创建闭包：一个常见错误"></a>在循环中创建闭包：一个常见错误</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"help"</span>&gt;</span>Helpful notes will appear here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>当焦点在<code>input上</code>时候，触发<code>onfocus</code>，然而赋值给 <code>onfocus</code> 的是闭包，保持了个引用。这些闭包是由他们的函数定义和在 <code>setupHelp</code> 作用域中捕获的环境所组成的。</p><p>当<code>onfocus</code>的回调执行时，<code>item.help</code>的值被决定。由于循环在事件触发之前早已执行完毕，变量对象<code>item</code>（被三个闭包所共享）已经指向了<code>helpText</code>的最后一项。</p><h2 id="闭包的坑"><a href="#闭包的坑" class="headerlink" title="闭包的坑"></a>闭包的坑</h2><h3 id="坑点1：-引用的变量可能发生变化"><a href="#坑点1：-引用的变量可能发生变化" class="headerlink" title="坑点1： 引用的变量可能发生变化"></a>坑点1： 引用的变量可能发生变化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info(i)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子result每个闭包函数对打印对应数字，1,2,3,4,…,10, 实际不是，因为每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印10， 10， …, 10</p><p>怎么解决这个问题呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        result[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.info(num);   <span class="comment">// 此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number都不一样</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;)(i)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="坑点2-this指向问题"><a href="#坑点2-this指向问题" class="headerlink" title="坑点2: this指向问题"></a>坑点2: this指向问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">     name: <span class="string">"object"</span>,</span><br><span class="line">     getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.info(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">object.getName()()    <span class="comment">// underfined</span></span><br><span class="line"><span class="comment">// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows</span></span><br></pre></td></tr></table></figure><h3 id="坑点3：内存泄露问题"><a href="#坑点3：内存泄露问题" class="headerlink" title="坑点3：内存泄露问题"></a>坑点3：内存泄露问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">showId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      aler(el.id)   <span class="comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成下面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">showId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line">    <span class="keyword">var</span> id  = el.id</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      aler(id) </span><br><span class="line">    &#125;</span><br><span class="line">    el = <span class="literal">null</span>    <span class="comment">// 主动释放el</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h2><p>用闭包解决递归调用问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial</span><br><span class="line">factorial = <span class="literal">null</span></span><br><span class="line">anotherFactorial(<span class="number">4</span>)   <span class="comment">// 报错 ，因为最好是return num* arguments.callee（num-1），arguments.callee指向当前执行函数，但是在严格模式下不能使用该属性也会报错，所以借助闭包来实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包实现递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFactorial</span> = (<span class="params">function f(num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> num* f(num<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) <span class="comment">//这样就没有问题了，实际上起作用的是闭包函数f，而不是外面的函数newFactorial</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/rubylouvre/p/3345294.html" target="_blank" rel="noopener">闭包的内存泄漏问题测试</a></p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-hook</title>
      <link href="/2020/05/15/react-hook/"/>
      <url>/2020/05/15/react-hook/</url>
      
        <content type="html"><![CDATA[<h3 id="useSate-声明-State-变量"><a href="#useSate-声明-State-变量" class="headerlink" title="useSate 声明 State 变量"></a>useSate 声明 State 变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useSate &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个叫 "count" 的 state 变量</span></span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">            Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明多个 state 变量</span></span><br><span class="line">    <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">'banana'</span>);</span><br><span class="line">    <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">'学习 Hook'</span> &#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useEffect 做了什么？ 通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。</p><p>它在第一次渲染之后和每次state更新的时候都调用useEffect。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><h4 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line">  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  <span class="comment">// Specify how to clean up after this effect:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>react 会在每次渲染后都执行，也会执行清除函数。effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p><h4 id="useEffect-优化"><a href="#useEffect-优化" class="headerlink" title="useEffect 优化"></a>useEffect 优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（<code>[]</code>）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p><p>effect 内部的 props 和 state 就会一直拥有其初始值, 当然内部尽量不要引用state的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect..'</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [num, setNum] = useState([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">const</span> [num1, setNum1] = useState([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'callback function'</span>);</span><br><span class="line">         <span class="keyword">return</span> [...num, ...num1] </span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;ChildrenApp num=&#123;num&#125; num1=&#123;num1&#125; callback=&#123;mCallback&#125;  /&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setNum([<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])&#125; &gt;change num&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setNum1([10,11,12])&#125; &gt;change num1&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ChildrenApp(&#123;num, num1, callback&#125;) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    set.add(callback);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    console.log(set);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">            &#123;num&#125; - &#123;num1&#125; - &#123;callback()&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>从上面的过程我们可以发现，set 集合里面一直只有一个函数，这说明了 callback 函数的引用没有发生变化，使用的是记忆化的版本函数。</p><p>这里之所以 callback 显示的值一直是 123456 没有变化，原因在于 mCallback 函数的依赖列表为空，并没有监听 num 和 num1 的变化，所以其闭包里面的 num 和 num1 值一直分别是 123 和 456。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback function'</span>);</span><br><span class="line">    <span class="keyword">return</span> [...num, ...num1]</span><br><span class="line">&#125;, [num, num1]);</span><br></pre></td></tr></table></figure><p>传入num, num1操作后会发现 set 里面会包含几个function，说明了每次重新渲染的时候都会重新生成 mCallback 函数并传递给子组件。</p><p><strong>总结：</strong></p><ul><li>普通函数在重新渲染时会重新生成，所以引用会变。</li><li>使用 useCallback 包装的函数，依赖列表为空时，重新渲染时该函数会使用记忆化的版本函数，所以引用不会变化</li><li>使用 useCallback 包装的函数，依赖列表存在依赖，重新渲染时对应的依赖发生变化，该函数会重新生成，所以引用发生变化，</li></ul><p>为什么依赖发生变化的时候需要重新生成函数那？这里面和作用域的知识有点相关。</p><ul><li><p>首先我们看看普通函数<br>ChildrenApp 的 callback 函数其实是指向 App 的 mCallback 函数的，即 callback -&gt; mCallback，所以调用 callback 函数也就是调用 mCallback 函数，里面用到的 num 和 num1 是 App 组件作用域里面的 num 和 num1。</p></li><li><p>再来看看依赖为空的情况<br>和上面一样，ChildrenApp 的 callback 函数其实是指向 App 的 mCallback 函数的，即 callback -&gt; mCallback，但是我们这里的 mCallback 函数是一个记忆化版本函数，在初始化的时候，App 作用域下的 num 和 num1 传给 mCallback 函数闭包环境里面的 num 和 num1。因为我们的依赖列表为空，不监听变化，所以闭包里面的内容不会发生变化。所以 mCallback 函数也就没有重新生成。</p></li><li><p>最后看看有依赖的情况<br>和依赖为空的差别在于，例如当依赖 num 发生变化的时候，mCallback 闭包环境里对应的 num 会被重新赋值，这个流程会触发生成一个新的函数。</p></li></ul><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure><p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext provider</code> 的 context value 值。即使祖先使用 <code>React.memo</code> 或 <code>shouldComponentUpdate</code>，也会在组件本身使用 useContext 时重新渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton() &#123;</span></span><br><span class="line"><span class="regexp">  const theme = useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      I am styled by theme context!</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 <code>&lt;div ref={myRef} /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。</p><p>然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> intervalRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    intervalRef.current = id;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(intervalRef.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure><p>父组件调用子组件里面的函数或一些实例值</p><p><code>useImperativeHandle</code> 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput);</span></span><br></pre></td></tr></table></figure><p>在本例中，渲染 <code>&lt;FancyInput ref={inputRef} /&gt;</code> 的父组件可以调用 <code>inputRef.current.focus()</code>。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useState</code> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState 的 reducer</code>，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react渲染</title>
      <link href="/2020/05/14/react-rendering/"/>
      <url>/2020/05/14/react-rendering/</url>
      
        <content type="html"><![CDATA[<h3 id="react-条件渲染"><a href="#react-条件渲染" class="headerlink" title="react 条件渲染"></a>react 条件渲染</h3><h4 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF/ELSE"></a>IF/ELSE</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (renderComponent1) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125; else &#123;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>return <code>null</code> 如果不想渲染空元素，不要使用空字符串, 最好使用 null， 这样对 React 渲染效率有提升。</p><h3 id="组件变量"><a href="#组件变量" class="headerlink" title="组件变量"></a>组件变量</h3><p>将组件赋值到变量，就可以在 return 前任意修改它了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (renderComponent1) &#123;</span><br><span class="line">    component = <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return component;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderComponent1 ? <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span> : null;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>但三元运算符产生嵌套时，理解成本会变得很高。</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><p>这个是最常用了，因为代码量最少。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderComponent1 &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>IIFE 含义是立即执行函数，也就是如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"><span class="regexp">/* arguments */</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(<span class="comment">/* arguments */</span>);</span><br></pre></td></tr></table></figure></p><h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h4><p>这是 IIFE 的变种，也就是把这段立即执行函数替换成一个普通函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SubRender /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function SubRender() &#123;</span></span><br><span class="line"><span class="regexp">  if (renderComponent1) &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;Component1 /</span>&gt;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="IF-组件"><a href="#IF-组件" class="headerlink" title="IF 组件"></a>IF 组件</h4><p>做一个条件渲染组件 IF 代替 js 函数的 if：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;If condition=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">  &lt;span&gt;Hi!<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/If&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const If = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const condition = props.condition || false;</span></span><br><span class="line"><span class="regexp">  const positive = props.then || null;</span></span><br><span class="line"><span class="regexp">  const negative = props.else || null;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return condition ? positive : negative;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></p><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>高阶组件，就是返回一个新组件的函数，并且接收一个组件作为参数。<br>那么我们就能在高阶组件里写条件语句，返回不同的组件即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">higherOrderComponent</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">EnhancedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*----------------------------------------------*/</span><br><span class="line">const withList = WrappedComponent =&gt; &#123;</span><br><span class="line">  return class PP extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123; status &#125; = this.props</span><br><span class="line">      switch (status) &#123;</span><br><span class="line">        case 'loading':</span><br><span class="line">          return &lt;div&gt;加载状态&lt;/div&gt;</span><br><span class="line">        </span><br><span class="line">        case 'error':</span><br><span class="line">          return &lt;div&gt;错误状态&lt;/div&gt;</span><br><span class="line">        </span><br><span class="line">        case 'success':</span><br><span class="line">          return &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">        </span><br><span class="line">        case 'empty':</span><br><span class="line">          return &lt;div&gt;空状态&lt;/div&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@withList</span><br><span class="line">class List extends Component &#123;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    status: PropTypes.oneOf(['loading', 'error', 'success', 'empty'])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        成功页面</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结:</p><ul><li>当项目很简单，或者条件渲染的逻辑确认无法复用时，推荐在代码中用 &amp;&amp; 或者三元运算符、IIFE 等直接实现条件渲染。</li><li>当项目很复杂时，尽量都使用 子函数、子组件、IF 组件、高阶组件 等方式做更有抽象度的条件渲染。</li><li>在做逻辑抽象时，考虑下项目的复杂度，避免因为抽象带来的成本增加，让本可以整体理解的项目变得支离破碎。</li></ul><h3 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h3><h4 id="减少-render-方法的复杂度"><a href="#减少-render-方法的复杂度" class="headerlink" title="减少 render 方法的复杂度"></a>减少 render 方法的复杂度</h4><p>当组件状态更新时，会不断的调用 render 方法，意味着你放在 render 方法的中代码逻辑、函数调用等也是每次都会被执行，如果是跟组件状态无关的函数，建议不要放到 render 方法中。</p><h4 id="控制嵌套层级"><a href="#控制嵌套层级" class="headerlink" title="控制嵌套层级"></a>控制嵌套层级</h4><p>你需要将页面的 vdom 层级控制在 14 层以下，过大的嵌套层级会导致页面渲染时间加长，严重的会导致低端手机 crash。</p><h4 id="PureComponent-组件-与-memo-组件"><a href="#PureComponent-组件-与-memo-组件" class="headerlink" title="PureComponent 组件 与 memo 组件"></a>PureComponent 组件 与 memo 组件</h4><p>官方提供了 memo 组件和PureComponent组件分别用于减少函数组件和类组件的重复渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    cnt = cnt + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Class组件发生渲染次数: &#123;cnt&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ChildClass;</span><br></pre></td></tr></table></figure><p><code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 <code>props</code> 和 <code>state</code> 较为简单时，才使用 <code>React.PureComponent</code>，或者在深层数据结构发生变化时调用 <code>forceUpdate()</code> 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。<br>此外，<code>React.PureComponent</code> 中的 <code>shouldComponentUpdate()</code> 将跳过所有子组件树的 <code>prop</code> 更新。因此，请确保所有子组件也都是“纯”的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; memo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OpChildFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  cnt = cnt + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>函数组件发生渲染次数: &#123;cnt&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(OpChildFunc);</span><br></pre></td></tr></table></figure><p><code>React.memo</code>为高阶组件。它与<code>React.PureComponent</code>非常相似，但它适用于函数组件，但不适用于 <code>class</code> 组件。</p><p>如果你的函数组件在给定相同<code>props</code>的情况下渲染相同的结果，那么你可以通过将其包装在<code>React.memo</code>中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure><p>此方法仅作为性能优化的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。</p><p><strong>注意:</strong> 与 class 组件中 shouldComponentUpdate() 方法不同的是，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false。这与 shouldComponentUpdate 方法的返回值相反。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>console的用法</title>
      <link href="/2020/04/13/console/"/>
      <url>/2020/04/13/console/</url>
      
        <content type="html"><![CDATA[<h2 id="分类输出"><a href="#分类输出" class="headerlink" title="分类输出"></a>分类输出</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'文字信息'</span>);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'提示信息'</span>);</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">'警告信息'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'错误信息'</span>);</span><br></pre></td></tr></table></figure><h2 id="输出对象的所有属性和属性值"><a href="#输出对象的所有属性和属性值" class="headerlink" title="输出对象的所有属性和属性值"></a>输出对象的所有属性和属性值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(object);</span><br></pre></td></tr></table></figure><h2 id="分组输出"><a href="#分组输出" class="headerlink" title="分组输出"></a>分组输出</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">'第一个组'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1-1"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1-2"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1-3"</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">'第二个组'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2-1"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2-2"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2-3"</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure><h2 id="表格输出"><a href="#表格输出" class="headerlink" title="表格输出"></a>表格输出</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = &#123;</span><br><span class="line">    Obj1: &#123;</span><br><span class="line">        a: <span class="string">"aaa"</span>,</span><br><span class="line">        b: <span class="string">"bbb"</span>,</span><br><span class="line">        c: <span class="string">"ccc"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Obj2: &#123;</span><br><span class="line">        a: <span class="string">"aaa"</span>,</span><br><span class="line">        b: <span class="string">"bbb"</span>,</span><br><span class="line">        c: <span class="string">"ccc"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Obj3: &#123;</span><br><span class="line">        a: <span class="string">"aaa"</span>,</span><br><span class="line">        b: <span class="string">"bbb"</span>,</span><br><span class="line">        c: <span class="string">"ccc"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Obj4: &#123;</span><br><span class="line">        a: <span class="string">"aaa"</span>,</span><br><span class="line">        b: <span class="string">"bbb"</span>,</span><br><span class="line">        c: <span class="string">"ccc"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.table(Obj);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> Arr = [</span><br><span class="line">    [<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>],</span><br><span class="line">    [<span class="string">"dd"</span>,<span class="string">"ee"</span>,<span class="string">"ff"</span>],</span><br><span class="line">    [<span class="string">"gg"</span>,<span class="string">"hh"</span>,<span class="string">"ii"</span>],</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.table(Arr);</span><br></pre></td></tr></table></figure><h2 id="条件输出"><a href="#条件输出" class="headerlink" title="条件输出"></a>条件输出</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当第一个参数或返回值为真时，不输出内容</span></span><br><span class="line"><span class="comment">// 当第一个参数或返回值为假时，输出后面的内容并抛出异常</span></span><br><span class="line"><span class="built_in">console</span>.assert(<span class="literal">true</span>, <span class="string">"你永远看不见我"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>;&#125;)(), <span class="string">"你永远看不见我"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.assert(<span class="literal">false</span>, <span class="string">"你看得见我"</span>);</span><br><span class="line"><span class="built_in">console</span>.assert((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>;&#125;)(), <span class="string">"你看得见我"</span>);</span><br></pre></td></tr></table></figure><h2 id="计次输出"><a href="#计次输出" class="headerlink" title="计次输出"></a>计次输出</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.count(<span class="string">"运行次数："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="追踪调用堆栈"><a href="#追踪调用堆栈" class="headerlink" title="追踪调用堆栈"></a>追踪调用堆栈</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Console.trace()来追踪函数被调用的过程，在复杂项目时调用过程非常多，用这个命令来帮你缕清。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace();</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Console.time()中的参数作为计时器的标识，具有唯一性。</span></span><br><span class="line"><span class="comment">// Console.timeEnd()中的参数来结束此标识的计时器，并以毫秒为单位返回运行时间。</span></span><br><span class="line"><span class="comment">// 最多同时运行10000个计时器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"Chrome中循环1000次的时间"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Chrome中循环1000次的时间"</span>);</span><br></pre></td></tr></table></figure><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><table><thead><tr><th>位符</th><th>含义</th></tr></thead><tbody><tr><td>%s</td><td>字符串输出</td></tr><tr><td>%d or %i</td><td>整数输出 </td></tr><tr><td>%f</td><td>浮点数输出</td></tr><tr><td>%o</td><td>打印javascript对象，可以是整数、字符串以及JSON数据</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"小明"</span>, <span class="string">"小红"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"欢迎%s和%s两位新同学"</span>,arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"圆周率整数部分：%d，带上小数是：%f"</span>,<span class="number">3.1415</span>,<span class="number">3.1415</span>);</span><br></pre></td></tr></table></figure><h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><p>使用%c为打印内容定义样式,再输出信息前加上%c，后面写上标准的css样式，就可以为输出的信息添加样式了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出带模糊字体</span></span><br><span class="line"><span class="keyword">var</span> _log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _log.call(<span class="built_in">console</span>, <span class="string">'%c'</span> + [].slice.call(<span class="built_in">arguments</span>).join(<span class="string">' '</span>), <span class="string">'color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> console </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Redux 使用</title>
      <link href="/2020/04/01/redux-basic-use/"/>
      <url>/2020/04/01/redux-basic-use/</url>
      
        <content type="html"><![CDATA[<h2 id="Provider和connect"><a href="#Provider和connect" class="headerlink" title="Provider和connect"></a>Provider和connect</h2><p>React-Redux 提供<code>&lt;Provider/&gt;</code>组件，能够使你的整个app访问到<code>Redux store</code>中的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  rootElement</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>React-Redux提供一个<code>connect</code>方法能够让你把组件和<code>store</code>连接起来，可以读取数据以及当store更新后，重新读取数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement, reset &#125; <span class="keyword">from</span> <span class="string">"./actionCreators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const Counter = ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state <span class="regexp">/*, ownProps*/</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: state.counter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123; increment, decrement, reset &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure></p><h2 id="connect方法接收两个参数，都是可选参数："><a href="#connect方法接收两个参数，都是可选参数：" class="headerlink" title="connect方法接收两个参数，都是可选参数："></a><code>connect</code>方法接收两个参数，都是可选参数：</h2><ul><li><code>mapStateToProps</code>：每当store state发生变化时，就被调用。接收整个store state，并且返回一个该组件所需要的数据对象</li><li><code>mapDispatchToProps</code>：这个参数可以是一个函数或对象<ul><li>如果是一个函数，一旦该组件被创建，就会被调用。接收<code>dispatch</code>作为一个参数，并且返回一个能够使用<code>dispatch</code>来分发<code>actions</code>的若干函数组成的对象</li><li>如果是一个<code>action creators</code>构成的对象，每一个<code>action creator</code>将会转化为一个<code>prop function</code>并会在调用时自动分发<code>actions</code>。注意： 我们建议使用这种形式。</li></ul></li></ul><p>常见的调用connect的方式</p><table><thead><tr><th></th><th>不订阅Store</th><th>订阅Store</th></tr></thead><tbody><tr><td>不注入Action Creators</td><td>connect()(Component)</td><td>connect(mapStateToProps)Component)</td></tr><tr><td>注入Action Creators</td><td>connect(null, mapDispatchToProps)(Component)</td><td>connect(mapStateToProps, mapDispatchToProps)(Component)</td></tr></tbody></table><h3 id="不订阅store并且不注入action创建函数"><a href="#不订阅store并且不注入action创建函数" class="headerlink" title="不订阅store并且不注入action创建函数"></a>不订阅store并且不注入action创建函数</h3><p>如果你调用connect方法并且不传入任何参数，那么你的组件将会：</p><ul><li>在store改变时不能够重新渲染</li><li>接收一个props.dispatch方法以便你手动分发actions<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect()(Component); <span class="comment">// 组件将接收 `dispatch` (正如 &lt;TodoList /&gt;!)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="订阅store但不注入action创建函数"><a href="#订阅store但不注入action创建函数" class="headerlink" title="订阅store但不注入action创建函数"></a>订阅store但不注入action创建函数</h3><p>如果你调用connect方法并且只传入了mapStateToProps方法，你的组件将会：</p><ul><li>订阅mapStateToProps从store中提取的部分值，当这些值改变时会重新渲染</li><li>接收一个props.dispatch以便你手动分发actions</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... Component</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> state.partOfState;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(Component);</span><br></pre></td></tr></table></figure><h3 id="不订阅store但注入action创建函数"><a href="#不订阅store但注入action创建函数" class="headerlink" title="不订阅store但注入action创建函数"></a>不订阅store但注入action创建函数</h3><p>如果你调用connect方法并只传入mapDispatchToProps参数，你的组件将会：</p><ul><li>store改变时不重新渲染</li><li>以props形式接收每个你通过mapDispatchToProps注入的action创建函数，能够在你调用后自动分发actions<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; addTodo &#125; <span class="keyword">from</span> <span class="string">"./actionCreators"</span>;</span><br><span class="line"><span class="comment">// ... Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  &#123; addTodo &#125;</span><br><span class="line">)(Component);</span><br></pre></td></tr></table></figure></li></ul><h3 id="订阅store并且注入action创建函数"><a href="#订阅store并且注入action创建函数" class="headerlink" title="订阅store并且注入action创建函数"></a>订阅store并且注入action创建函数</h3><p>如果你在connect方法中传入了mapStateToProps和mapDispatchToProps，你的组件将会：</p><ul><li>订阅mapStateToProps从store中提取的部分值，当这些值改变时会重新渲染</li><li>以props形式接收每个你通过mapDispatchToProps注入的action创建函数，能够在你调用后自动分发actions</li></ul><h3 id="Connect：使用mapStateToProps抽取数据"><a href="#Connect：使用mapStateToProps抽取数据" class="headerlink" title="Connect：使用mapStateToProps抽取数据"></a>Connect：使用mapStateToProps抽取数据</h3><p>作为传递给connect的第一个参数，mapStateToProps用来从store中选择被连接的组件所需要的部分数据。常以mapState缩写来表示。</p><ul><li>每当store state改变时就被调用</li><li>接收整个store state，并且返回一个组件需要的数据对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps?</span>)</span></span><br></pre></td></tr></table></figure></li></ul><p>这个方法应作为第一个参数传递给<code>connect</code>，并且会在每次<code>Redux store state</code>改变时被调用。如果你不希望订阅<code>store</code>，那么请传递<code>null</code>或者<code>undefined</code>替代<code>mapStateToProps</code>作为<code>connect</code>的第一个参数。</p><p>参数：<br>state<br><code>mapStateToProps</code>的第一个参数是整个Redux store state对象（与<code>store.getState()</code>方法返回的值相同）。因此第一个参数通常命名为<code>state</code>（当然你也可以选择别的名字，但是叫<code>store</code>就不推荐了——因为它是<code>state</code>值而不是<code>store</code>实例）</p><p>mapStateToProps方法至少要传递state参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoList.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = state;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todoList</span>: todos.allIds &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(TodoList);</span><br></pre></td></tr></table></figure></p><p>ownProps（可选）<br>如果你的组件需要用自身的props数据以从store中检索出数据，你可以传入第二个参数，<code>ownProps</code>。这个参数将包含所有传递给由<code>connect</code>生成的包装组件的props。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Todo.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; visibilityFilter &#125; = state;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = ownProps;</span><br><span class="line">  <span class="keyword">const</span> todo = getTodoById(state, id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件额外接收:</span></span><br><span class="line">  <span class="keyword">return</span> &#123; todo, visibilityFilter &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后，在你的应用里，渲染一个如下父组件：</span></span><br><span class="line">&lt;ConnectedTodo id=&#123;<span class="number">123</span>&#125; /&gt;</span><br><span class="line"><span class="comment">// 你的组件接收 props.id, props.todo, 以及 props.visibilityFilter</span></span><br></pre></td></tr></table></figure><p>返回值<br>你的mapStateToProps方法应该返回一个包含了组件用到的数据的纯对象：</p><ul><li>每一个对象中的字段都将作为你组件的一个prop</li><li>字段中的值用来判断你的组件是否需要重新渲染<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a : <span class="number">42</span>,</span><br><span class="line">    todos : state.todos,</span><br><span class="line">    filter : state.visibilityFilter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件会接收: props.a, props.todos,以及 props.filter</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>让<code>mapStateToProps</code>改造从store中取出的数据<br><code>mapStateToProps</code>方法能够，且应该，做更多的事情，而不仅仅是返回一个state.someSlice。他们有责任去改造组建所需要的store中的数据。比如说，返回一个特定prop名称的值，从state树中不同部分取出数据片段并合并为一个整体，以及以不同的方式转化store。</p><p><code>mapStateToProps</code>方法应该足够快<br>一旦store改变了，所有被连接组件中的所有的<code>mapStateToProps</code>方法都会运行。因此，你的<code>mapStateToProps</code>方法一定要足够快。这也意味着缓慢的<code>mapStateToProps</code>方法会成为你应用的一个潜在瓶颈。</p><p>作为“重塑数据”想法的一部分，<code>mapStateToProps</code>方法经常需要以各种方式来转化数据（比如过滤数组，遍历IDs数组映射到对应的对象，或者从Immutable.js对象中抽取纯js值）。这些转化的开销通常很高昂，不仅表现在运行转化操作的开销上，也表现在判断最终是否要更新组件上。如果的确需要考虑性能问题了，那么要确保你的这些转化只发生在所输入的值发生变化的时候。</p><p><code>mapStateToProps</code>方法应该纯净且同步<br>正如Redux Reducer，一个<code>mapStateToProps</code>方法应该是100%纯净的并且是同步的。他应该仅接受state（以及ownProps）作为参数，然后以props形式返回组件所需要的数据。他不应该触发任何异步操作，如AJAX请求数据，方法也不能声明为async形式。</p><h3 id="行为及总结"><a href="#行为及总结" class="headerlink" title="行为及总结"></a>行为及总结</h3><p>mapStateToProps在store state相同的情况下不会运行<br>connect生成的包装组件会订阅Redux store。每当action被分发后，它就调用store.getState()并检查是否lastState===currentState。如果两个状态值引用完全相同，那么mapStateToProps就不会运行，因为组件假设了你余下的store state也没有发生改变。</p><p>Redux的combineReducers功能函数会尝试对其优化。如果所有reducer都没有返回新值，那么combineReducers会返回旧state对象而不是新的。这意味着，一个reducer中的突变不会使根state对象更新，当然UI也不会重新渲染。</p><h3 id="声明参数的数量影响行为"><a href="#声明参数的数量影响行为" class="headerlink" title="声明参数的数量影响行为"></a>声明参数的数量影响行为</h3><p>当仅有(state)时，每当根store state对象不同了，函数就会运行。</p><p>当有(state,ownProps)两个参数时，每当store state不同、或每当包装props变化时，函数都会运行。</p><p>这意味着你不应该增加ownProps参数，除非你实在是需要它，否则你的mapStateToProps函数会比它实际需要运行次数运行更多次。</p><p>关于这个行为有一些极端案例。arguments的数量决定了mapStateToProps是否接收ownProps参数。</p><p>如果先前定义函数的时候包含了一个命令参数，mapStateToProps就不会接收ownProps</p><h2 id="Connect-使用mapDispatchToProps分发actions"><a href="#Connect-使用mapDispatchToProps分发actions" class="headerlink" title="Connect: 使用mapDispatchToProps分发actions"></a>Connect: 使用mapDispatchToProps分发actions</h2><p>作为第二个传入connect的参数，mapDispatchToProps可以实现向store中分发acions。</p><p>使用React-Redux后，你的组件就不再需要直接和store打交道了——connect会为你完成这件任务，React-Redux提供了两种可以分发actions的方式：</p><ul><li>默认地，一个已连接组件可以接收props.dispatch然后自己分发actions</li><li>connect能够接收一个mapDispatchToProps作为第二个参数，这将让你能够创建dispatch调用方法，然后把这些方法作为props传递给你的组件。</li></ul><h3 id="分发（Dispatching）的途径"><a href="#分发（Dispatching）的途径" class="headerlink" title="分发（Dispatching）的途径"></a>分发（Dispatching）的途径</h3><p>默认：作为一个prop的dispatch<br>如果你不为connect()指明第二个参数，你的组件会默认接收dispatch。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">connect()(MyComponent);</span><br><span class="line"><span class="comment">// 与下面语句等价</span></span><br><span class="line">connect(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)(MyComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">connect(mapStateToProps <span class="comment">/** 没有第二个参数 */</span>)(MyComponent);</span><br></pre></td></tr></table></figure></p><p>一旦你以这种方式连接了你的组件，你的组件就会接收props.dispatch。你可以用它来向store中分发actions。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; count, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"DECREMENT"</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: "INCREMENT" &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"RESET"</span> &#125;)&#125;&gt;reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个mapDispatchToProps参数能够让你指明你的组件所实际需要分发的那些actions。它允许你提供action分发函数作为props，这样一来，你不用再进行props.dispatch(() =&gt; increment())调用，你可以直接props.increment()。</p><p>一旦你把所有的action creators使用函数封装起来之后，你的组件就不需要再<code>dispatch</code>了。因此，如果你定义了mapDispatchToProps被连接组件就不再接收到<code>dispatch</code>了。</p><p>把action分发逻辑向子（未连接）组件传递</p><p>此外，你现在也能够向下传递你的action分发函数给子组件（可能尚未连接）。这样就能够使更多的组件分发actions，且它们对Redux也是无感知的。</p><h3 id="两种mapDispatchToProps的形式"><a href="#两种mapDispatchToProps的形式" class="headerlink" title="两种mapDispatchToProps的形式"></a>两种mapDispatchToProps的形式</h3><p>mapDispatchToProps参数有两种形式：函数形式自定义化程度更高，对象形式更简单。</p><ul><li>函数形式：更高自由度、能够访问dispatch和可选择的ownProps</li><li>对象形式：更声明式，更易于使用</li></ul><h4 id="将mapDispatchToProps定义为一个函数"><a href="#将mapDispatchToProps定义为一个函数" class="headerlink" title="将mapDispatchToProps定义为一个函数"></a>将mapDispatchToProps定义为一个函数</h4><p>将mapDispatchToProps定义为一个函数使你更灵活地定义你的组件能够接收到的函数、以及这些函数如何分发actions。你对dispatch和ownProps都具有访问权限。你可以借此机会编写你的连接组件的自定义函数。<br>参数</p><ol><li>dispatch</li><li>ownProps（可选）</li></ol><p>mapDispatchToProps函数调用时以dispatch作为第一个参数。通常情况下，你会利用这个参数来返回一个内部调用了dispatch()的新函数，然后内部传递一个纯的action对象或者action创建函数的返回值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 分发纯action对象</span></span><br><span class="line">    increment: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">"INCREMENT"</span> &#125;),</span><br><span class="line">    decrement: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">"DECREMENT"</span> &#125;),</span><br><span class="line">    reset: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">"RESET"</span> &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>你也可能需要把一些参数转发给你的action创建函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 直接转发参数</span></span><br><span class="line">    onClick: <span class="function"><span class="params">event</span> =&gt;</span> dispatch(trackClick(event)),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 间接转发参数</span></span><br><span class="line">    onReceiveImpressions: <span class="function">(<span class="params">...impressions</span>) =&gt;</span></span><br><span class="line">      dispatch(trackImpressions(impressions))</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ownProps（可选）</p><p>你的mapDispatchToProps函数是可以接收两个参数的，第一个是dispatch，传递给连接组件的props即为mapDispatchToProps的第二个参数，然后在组件接收到新的props后会重新调用。</p><p>这意味着，你应该在组件props改变阶段重新把新的props绑定到action分发函数中去，而不是在组件重新渲染阶段进行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件re-rendering阶段绑定</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.props.toggleTodo(<span class="keyword">this</span>.props.todoId)&#125; /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 props 改变阶段绑定</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  toggleTodo: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(toggleTodo(ownProps.todoId));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>返回值<br>你的mapDispatchToProps函数应该的返回一个纯对象。</p><ul><li>每一个对象的字段都会作为你的组件的一个独立prop，并且字段的值通常是一个调用后能分发action的函数。</li><li>如果你在dispatch()中使用了action创建函数（区别于纯对象形式的action），通常约定字段名与action创建函数的名称相同</li></ul><p>mapDispatchToProps的函数返回值会合并到你的组件props中去。你就能够直接调用它们来分发action。</p><h4 id="使用bindActionCreators定义mapDispatchToProps函数"><a href="#使用bindActionCreators定义mapDispatchToProps函数" class="headerlink" title="使用bindActionCreators定义mapDispatchToProps函数"></a>使用bindActionCreators定义mapDispatchToProps函数</h4><p>手动封装这些函数实在是繁琐，所以Redux提供了一个函数简化这个操作。</p><p>bindActionCreators将值为action creators的对象，转化为同键名的新对象，但将每个action creators封装到一个dispatch调用中，以便可以直接调用它们。参阅<a href="https://www.redux.org.cn/docs/api/bindActionCreators.html" target="_blank" rel="noopener">Redux | bindActionCreators</a></p><p>bindActionCreators接收两个参数：</p><ul><li>一个函数（action creator）或一个对象（每个属性为一个action creator）</li><li>dispatch</li></ul><p>由bindActionCreators生成的包装函数会自动转发它们所有的参数，所以你不需要在手动操作了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">"INCREMENT"</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">"DECREMENT"</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> reset = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">"RESET"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定一个action creator</span></span><br><span class="line"><span class="comment">// 返回 (...args) =&gt; dispatch(increment(...args))</span></span><br><span class="line"><span class="keyword">const</span> boundIncrement = bindActionCreators(increment, dispatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定一个action creators构成的object</span></span><br><span class="line"><span class="keyword">const</span> boundActionCreators = bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch);</span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   increment: (...args) =&gt; dispatch(increment(...args)),</span></span><br><span class="line"><span class="comment">//   decrement: (...args) =&gt; dispatch(decrement(...args)),</span></span><br><span class="line"><span class="comment">//   reset: (...args) =&gt; dispatch(reset(...args)),</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------在mapDispatchToProps中使用bindActionCreators函数：--------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bindActionCreators将值为action creators的对象，转化为同键名的新对象，但将每个action creators封装到一个dispatch调用中，以便可以直接调用它们。</span></span><br><span class="line"><span class="comment">// const mapDispatchToProps = dispatch =&gt; (&#123;</span></span><br><span class="line"><span class="comment">//   actions: bindActionCreators(TodoActions, dispatch)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件能接收到 props.increment, props.decrement, props.reset</span></span><br><span class="line">connect(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure><p>手动注入dispatch<br>如果提供了mapDispatchToProps，组件将不再接收到默认的dispatch。但你可以通过在mapDispatchToProps的return中添加dispatch把它重新注入你的组件。多数情况下，你不需要这么做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    ...bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将mapDispatchToProps定义为一个对象"><a href="#将mapDispatchToProps定义为一个对象" class="headerlink" title="将mapDispatchToProps定义为一个对象"></a>将mapDispatchToProps定义为一个对象</h4><p>你已经注意到了，在React组件中分发Redux actions的过程都十分类似：定义action创建函数，把它包装在形如<code>(…args) =&gt; dispatch(actionCreator(…args))</code>的另一个函数，然后把那个包装函数作为props 传递给你的组件。</p><p>因为这一流程实在是太通用了，connect支持了一个“对象简写”形式的mapDispatchToProps参数：如果你传递了一个由action creators构成的对象，而不是函数，connect会在内部自动为你调用bindActionCreators</p><p>注意到：</p><ul><li>每个mapDispatchToProps对象的字段都被假设为一个action创建函数</li><li>你的组件不再接收dispatch作为一个prop</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React-Redux 自动为你做:</span></span><br><span class="line">dispatch =&gt; bindActionCreators(mapDispatchToProps, dispatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，我们的mapDispatchToProps可以简写为：</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  reset</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//既然变量名取决于你，你可能想把它命名为actionCreators或者甚至直接在调用connect时使用一个行内对象：</span></span><br><span class="line"><span class="keyword">import</span> &#123;increment, decrement, reset&#125; <span class="keyword">from</span> <span class="string">"./counterActions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actionCreators = &#123;</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  reset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapState, actionCreators)(Counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapState,</span><br><span class="line">  &#123; increment, decrement, reset &#125;</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IM 即时通信</title>
      <link href="/2020/03/09/IM/"/>
      <url>/2020/03/09/IM/</url>
      
        <content type="html"><![CDATA[<p>P2P通信原理与实现资料(协议 STUN TURN ICE SIP)<br><a href="https://evilpan.com/2015/10/31/p2p-over-middle-box/" target="_blank" rel="noopener">https://evilpan.com/2015/10/31/p2p-over-middle-box/</a></p><p>P2P技术详解(一)：NAT详解——详细原理、P2P简介<br><a href="http://www.52im.net/thread-50-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-50-1-1.html</a></p><p>WebRTC详细介绍<br><a href="https://hpbn.co/webrtc/#" target="_blank" rel="noopener">https://hpbn.co/webrtc/#</a><br>中译<br><a href="https://blog.csdn.net/tifentan/article/details/77941236" target="_blank" rel="noopener">https://blog.csdn.net/tifentan/article/details/77941236</a></p><p>WebRTC示例<br><a href="https://webrtc.github.io/samples/" target="_blank" rel="noopener">https://webrtc.github.io/samples/</a><br><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-tldr" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-tldr</a><br><a href="https://blog.coding.net/blog/getting-started-with-webrtcm" target="_blank" rel="noopener">https://blog.coding.net/blog/getting-started-with-webrtcm</a></p><p>WebRTC介绍及简单应用<br><a href="https://www.cnblogs.com/vipzhou/p/7994927.html" target="_blank" rel="noopener">https://www.cnblogs.com/vipzhou/p/7994927.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IM </tag>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas性能优化</title>
      <link href="/2020/02/27/optimizing-canvas/"/>
      <url>/2020/02/27/optimizing-canvas/</url>
      
        <content type="html"><![CDATA[<h3 id="Path2D"><a href="#Path2D" class="headerlink" title="Path2D"></a>Path2D</h3><p>Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。</p><p><strong>作用: 缓存图形path</strong> </p><p>作用场景：</p><ul><li>假如随机生成的图形，常见的方法，保存图形参数</li><li>clearRect 清空canvas后，需要回显刚才的图形</li><li>isPointInPath 判断事件path区域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmpPathArr = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )&#123;</span><br><span class="line">    <span class="keyword">var</span> cx = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random()*<span class="number">300</span> ),</span><br><span class="line">        cy = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random()*<span class="number">300</span> ),</span><br><span class="line">        r = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ),</span><br><span class="line">        g = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ),</span><br><span class="line">        b = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = <span class="string">'rgb('</span>+r+<span class="string">','</span>+g+<span class="string">','</span>+b+<span class="string">')'</span>;</span><br><span class="line">    ctx.arc(cx, cy, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    <span class="comment">//保存图形的参数</span></span><br><span class="line">    tmpPathArr.push( &#123;<span class="attr">cx</span>:cx,<span class="attr">cy</span>:cy,<span class="attr">rgb</span>:ctx.fillStyle&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空后回显</span></span><br><span class="line">ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.arc(v.cx, v.cy, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//isPointInPath</span></span><br><span class="line">canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> e = ev||event;  </span><br><span class="line">    <span class="keyword">var</span> x = e.clientX;  </span><br><span class="line">    <span class="keyword">var</span> y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(v.cx, v.cy, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">        <span class="keyword">if</span> ( ctx.isPointInPath(x,y) )&#123;  </span><br><span class="line">            <span class="comment">// 判断区域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用Path2D</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmpPathArr = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )&#123;</span><br><span class="line">    <span class="keyword">var</span> cx = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random()*<span class="number">300</span> ),</span><br><span class="line">        cy = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random()*<span class="number">300</span> ),</span><br><span class="line">        r = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ),</span><br><span class="line">        g = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ),</span><br><span class="line">        b = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = <span class="string">'rgb('</span>+r+<span class="string">','</span>+g+<span class="string">','</span>+b+<span class="string">')'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用path2直接保存图形，然后绘制图形</span></span><br><span class="line">    <span class="keyword">var</span> path2D = <span class="keyword">new</span> Path2D();        </span><br><span class="line">    path2D.arc(cx, cy, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">    path2D.rgb = ctx.fillStyle;</span><br><span class="line">    ctx.fill( path2D );</span><br><span class="line">    <span class="comment">//保存图形的参数</span></span><br><span class="line">    tmpPathArr.push( path2D );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空后回显</span></span><br><span class="line">ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.fill( v );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//isPointInPath</span></span><br><span class="line">canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> e = ev||event;  </span><br><span class="line">    <span class="keyword">var</span> x = e.clientX;  </span><br><span class="line">    <span class="keyword">var</span> y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ctx.isPointInPath(v, x,y) )&#123;</span><br><span class="line">            <span class="comment">//判断区域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Path2优点</p><ul><li>直接保存图形，不用关心图形参数，快速绘制</li><li>判断事件区域时，简单直接的使用 <code>ctx.isPointInPath(path2D,x,y)</code> ，不用绘制缓存的图形，取得上下文context后再判断</li><li>如果是多path的复杂图形，使用path2D优势将更明显，不需要保存图形复杂的绘制参数，方便开发和使用</li></ul><h3 id="CanvasRenderingContext2D-isPointInPath"><a href="#CanvasRenderingContext2D-isPointInPath" class="headerlink" title="CanvasRenderingContext2D.isPointInPath()"></a>CanvasRenderingContext2D.isPointInPath()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean ctx.isPointInPath(x, y);</span><br><span class="line">boolean ctx.isPointInPath(x, y, fillRule);</span><br><span class="line"></span><br><span class="line">boolean ctx.isPointInPath(path, x, y);</span><br><span class="line">boolean ctx.isPointInPath(path, x, y, fillRule);</span><br></pre></td></tr></table></figure><p>isPointInPath的入参出参：ctx.isPointInPath([path, ]x, y [, fillRule])，该方法的参数有4个，其中path和fillRule为选填，x和y为必填。返回一个Boolean值，当检测点包含在当前或指定的路径内，返回 true；否则返回 false。</p><ul><li>path: Path2D构造函数new的对象</li><li>x，y: x轴和y轴的距离,其相对位置是Canvas的左上角。</li><li>fillRule: 用来决定点在路径内还是在路径外的算法。<br>允许的值：<br>“nonzero”: 非零环绕规则 ，默认的规则。<br>“evenodd”: 奇偶环绕原则 。</li></ul><h3 id="性能优化——离屏canvas"><a href="#性能优化——离屏canvas" class="headerlink" title="性能优化——离屏canvas"></a>性能优化——离屏canvas</h3><p>在离屏canvas上预渲染相似的图形或重复的对象</p><p>如果你发现你的在每一帧里有好多复杂的画图运算，请考虑创建一个离屏canvas，将图像在这个画布上画一次（或者每当图像改变的时候画一次），然后在每帧上画出视线以外的这个画布。</p><p>使用场景</p><ul><li>静态的背景及不变的图形，每次重绘、回显时，可以直接绘制背景及图形，优化性能</li><li>重复或相似的图形，此时，可以将离屏canvas类比Sprite，保存各种图形的不同状态，利用drawImage 定位图形位置和区域大小，绘制要需要的部分图形</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建离屏canvas</span></span><br><span class="line"><span class="keyword">var</span>  offCanvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);  </span><br><span class="line">offCanvas.width=<span class="number">400</span>;  </span><br><span class="line">offCanvas.height=<span class="number">400</span>;  </span><br><span class="line"><span class="keyword">var</span> offContext = offCanvas.getContext(<span class="string">"2d"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )&#123;</span><br><span class="line">    <span class="keyword">var</span> cx = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random()*<span class="number">300</span> ),</span><br><span class="line">        cy = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random()*<span class="number">300</span> ),</span><br><span class="line">        r = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ),</span><br><span class="line">        g = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ),</span><br><span class="line">        b = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> ) ; </span><br><span class="line">    <span class="comment">//在离屏canvas上绘制场景，此时图形在离屏canvas上，并不显示</span></span><br><span class="line">    offContext.beginPath();  </span><br><span class="line">    offContext.fillStyle = <span class="string">'rgb('</span>+r+<span class="string">','</span>+g+<span class="string">','</span>+b+<span class="string">')'</span>;</span><br><span class="line">    offContext.arc(cx, cy, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">    offContext.fill();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//drawImage直接绘制整个离屏canvas的图形</span></span><br><span class="line">ctx.drawImage(offCanvas,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cavnas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鼠标获取 event位置、宽高</title>
      <link href="/2020/02/25/event-location/"/>
      <url>/2020/02/25/event-location/</url>
      
        <content type="html"><![CDATA[<h2 id="获取宽高和滚动距离"><a href="#获取宽高和滚动距离" class="headerlink" title="获取宽高和滚动距离"></a>获取宽高和滚动距离</h2><ul><li><code>offsetWidth</code> 返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）</li><li><code>offsetHeight</code> 返回元素的高度（包括元素高度、内边距和边框，不包括外边距）</li><li><code>clientWidth</code> 返回元素的宽度（包括元素宽度、内边距，不包括边框和外边距）</li><li><code>clientHeight</code> 返回元素的高度（包括元素高度、内边距，不包括边框和外边距）</li><li><code>style.width</code> 返回元素的宽度（包括元素宽度，不包括内边距、边框和外边距）</li><li><code>style.height</code> 返回元素的高度（包括元素高度，不包括内边距、边框和外边距）</li><li><code>scrollWidth</code> 返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同</li><li><code>scrollHeigh</code> 返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同</li><li><code>offsetTop</code> 返回元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离。</li><li><code>offsetLeft</code> 此属性和offsetTop的原理是一样的，只不过方位不同，这里就不多介绍了。</li><li><code>scrollLeft</code> 此属性可以获取或者设置对象的最左边到对象在当前窗口显示的范围内的左边的距离，也就是元素被滚动条向左拉动的距离。             返回值是一个整数，单位是像素。此属性是可读写的。</li><li><code>scrollTop</code> 此属性可以获取或者设置对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，也就是元素滚动条被向下拉动的距离。             返回值是一个整数，单位是像素。此属性是可读写的。</li></ul><p><img src="/images/location.webp" alt="宽度和可视区域"></p><h2 id="当鼠标事件发生时"><a href="#当鼠标事件发生时" class="headerlink" title="当鼠标事件发生时"></a>当鼠标事件发生时</h2><blockquote><p>pageX，pageY，screenX，screenY，clientX，和clientY返回一个数，其指示物理“CSS像素”的数量的点是从参考点。事件点是用户单击的位置，参考点是左上角的一个点。这些属性返回该参考点的水平和垂直距离。</p></blockquote><h3 id="offsetX，offsetY"><a href="#offsetX，offsetY" class="headerlink" title="offsetX，offsetY"></a>offsetX，offsetY</h3><p>鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。</p><h3 id="screenX，screenY"><a href="#screenX，screenY" class="headerlink" title="screenX，screenY"></a>screenX，screenY</h3><p>设置或获取获取鼠标指针位置相对于<code>物理屏幕的左上角</code>的坐标，当改变屏幕的<code>分辨率</code>的时候，坐标会随之改变<br>相对于<code>screen</code>设备像素的坐标。</p><h3 id="clientX，clientY"><a href="#clientX，clientY" class="headerlink" title="clientX，clientY"></a>clientX，clientY</h3><p>设置或获取鼠标指针位置相对于<code>浏览器视口（内容区域的左上角）</code>的坐标，与浏览器是否有滚动条无关<br>相对于页面的可见部分的左上角，通过浏览器窗口“看到”。<br>相对于<code>viewport</code> CSS像素的坐标</p><h3 id="pageX，pageY"><a href="#pageX，pageY" class="headerlink" title="pageX，pageY"></a>pageX，pageY</h3><p>相对于浏览器中完<code>全呈现的内容区域</code>的左上角，此参考点位于左上方的网址栏和后退按钮下方。如果在页面中嵌入可嵌入的可滚动页面，并且用户移动滚动条，则可以实际改变位置。<br>坐标相对于整个渲染页面的左上角（包括滚动隐藏的部分）<br>相对于<code>&lt;html&gt;</code>CSS像素中元素的坐标。</p><p>类似于<code>event.clientX</code>、<code>event.clientY</code>，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。</p><p>也就是说，当浏览器没有滚动条的时候，pageX和clientX是一样的</p><p><img src="/images/page-client.webp" alt="pageX和clientX区别"></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">clientX</td><td style="text-align:left">以浏览器左上顶角为原点，定位 x 轴坐标</td></tr><tr><td style="text-align:center">clientY</td><td style="text-align:left">以浏览器左上顶角为原点，定位ｙ轴坐标</td></tr><tr><td style="text-align:center">offsetX</td><td style="text-align:left">以当前事件的目标对象左上角为原点，定位x轴坐标</td></tr><tr><td style="text-align:center">offsetY</td><td style="text-align:left">以当前事件的目标对象左上角为原点，定位y轴坐标</td></tr><tr><td style="text-align:center">pageX</td><td style="text-align:left">以Document 对象（即文本窗口）左上角为原点，定位x轴坐标</td></tr><tr><td style="text-align:center">pageY</td><td style="text-align:left">以Document 对象（即文本窗口）左上角为原点，定位ｙ轴坐标</td></tr><tr><td style="text-align:center">screenX</td><td style="text-align:left">计算机屏幕左上角为原点，定位x轴坐标</td></tr><tr><td style="text-align:center">screenY</td><td style="text-align:left">计算机屏幕左上角为原点，定位ｙ轴坐标</td></tr><tr><td style="text-align:center">layerX</td><td style="text-align:left">最近的绝对定位的父元素（如果没有，则为Document对象）左上角为原点，定位x轴坐标</td></tr><tr><td style="text-align:center">layerY</td><td style="text-align:left">最近的绝对定位的父元素（如果没有，则为Document对象）左上角为原点，定位ｙ轴坐标</td></tr></tbody></table><p><img src="/images/location2.png" alt="page、client、screen区别"></p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zoom和transform scale的区别</title>
      <link href="/2020/02/24/zoom-scale/"/>
      <url>/2020/02/24/zoom-scale/</url>
      
        <content type="html"><![CDATA[<h3 id="IE和Chrome等浏览器与zoom"><a href="#IE和Chrome等浏览器与zoom" class="headerlink" title="IE和Chrome等浏览器与zoom"></a>IE和Chrome等浏览器与zoom</h3><p>还在几年前，<code>zoom</code>还只是IE浏览器自己私有的玩具，但是，现在，除了FireFox浏览器，其他，尤其Chrome和移动端浏览器已经很好支持zoom属性了。</p><p><code>zoom</code>的字面意思是“变焦”，摄影的时候常用到的一个概念。对于web上的<code>zoom</code>效果，你也可以按照此概念理解。可以改变页面上元素的尺寸，属于真实尺寸。</p><p>在旧的web时代。<code>*zoom: 1</code>可以给IE6/IE7浏览器增加haslayout, 用来清除浮动，修复一些布局上的疑难杂症等。</p><p>其支持的值类型有：</p><ul><li>百分比值：zoom:50%，表示缩小到原来的一半。</li><li>数值：zoom:0.5，表示缩小到原来的一半。</li><li>normal关键字：zoom:normal等同于zoom:1.</li></ul><p><strong>注意:</strong> 虽然Chrome/Safari浏览器支持了zoom属性，但是，其实zoom并不是标准属性。</p><h3 id="CSS3-transform下的scale"><a href="#CSS3-transform下的scale" class="headerlink" title="CSS3 transform下的scale"></a>CSS3 transform下的scale</h3><p>而<code>transform</code>下的<code>scale</code>就不一样了，是明明确确写入规范的。从IE9+到其他现代浏览器都支持。语法为：<code>transform: scale(&lt;x&gt; [&lt;y&gt;])</code>. 同时有<code>scaleX</code>, <code>scaleY</code>专门的<code>x</code>, <code>y</code>方向的控制。</p><p>和<code>zoom</code>不同，<code>scale</code>并不支持百分比值和normal关键字，只能是数值。而且，还能是负数，没错，负数。而<code>zoom</code>不能是负值！</p><h3 id="zoom和scale更深层次的差异"><a href="#zoom和scale更深层次的差异" class="headerlink" title="zoom和scale更深层次的差异"></a>zoom和scale更深层次的差异</h3><p>先总结下上面表面所见的差异：</p><ol><li>浏览器兼容性。IE全族/Chrome/Safari和IE9+现代浏览器的差别。</li><li>控制缩放的值不一样。zoom更全面，但是不能是负数，只能等比例控制；而scale虽然只能是数值，但是能负数，可以只控制1个维度。</li></ol><p>然而，更深层次的差异才是更重要的。</p><ol><li>zoom的缩放是相对于左上角的；而scale默认是居中缩放；</li><li>zoom的缩放改变了元素占据的空间大小；而scale的缩放占据的原始尺寸不变，页面布局不会发生变化；</li><li>zoom和scale对元素的渲染计算方法可能有差异。</li><li>对文字的缩放规则不一致。zoom缩放依然受限于最小12像素中文大小限制；而scale就是纯粹的对图形进行比例控制，文字50%原来尺寸。</li></ol><p>然后，还有一个肉眼看不见却更重要的差异，渲染的性能差异明显。</p><p>由于zoom的缩放会改变元素的真实空间大小，换句话说，实时影响了其他小伙伴。</p><p>在文档流中<code>zoom</code>加在任意一个元素上都会引起一整个页面的重新渲染，而<code>scale</code>只是在当前的元素上重绘。这其实很好理解，对吧。<code>scale</code>变化时候，其原本的尺寸是不变的，因此，就没有layout的重计算；但是<code>zoom</code>牵一发动全身，就麻烦地多！</p><p>这就让我们要斟酌下移动端一些功能的实现了。</p><p>我们要实现元素的缩放效果，可以使用CSS3 <code>animation</code>, 但是存在这样一种情况，就是元素原本就使用了一些<code>transform</code>属性进行，此时，再使用<code>scale</code>进行<code>animation</code>缩放，就会覆盖原来的值，事情就会变得麻烦。</p><p>聪明的小伙伴想到了一个方法，就是使用<code>zoom</code>做动画。从效果上讲，<code>zoom</code>是可以的；但是，从性能上讲，大家就要掂量掂量了。</p><p>需要注意的是，Chrome等浏览器下，<code>zoom/scale</code>不要同时使用，因为，缩放效果会累加。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 逻辑位运算符</title>
      <link href="/2020/02/23/js-logical/"/>
      <url>/2020/02/23/js-logical/</url>
      
        <content type="html"><![CDATA[<p>位运算就是对二进制数执行计算，是整数的逐位运算。例如，1+1=2，在十进制计算中是正确的，但是在二进制计算中，1+1=10；对于二进制数 100 取反，等于 001，而不是 -100。</p><p>位运算符有 7 个，分为两类：</p><ul><li>逻辑位运算符：位与（&amp;）、位或（|）、位异或（^）、非位（~）</li><li>移位运算符：左移（&lt;&lt;）、右移（&gt;&gt;）、无符号右移（&gt;&gt;&gt;）</li></ul><p>逻辑位运算符与逻辑运算符的运算方式是相同的，但是针对的对象不同。逻辑位运算符针对的是二进制的整数值，而逻辑运算符针对的是非二进制的值。</p><h3 id="“-amp-”运算符"><a href="#“-amp-”运算符" class="headerlink" title="“&amp;”运算符"></a>“&amp;”运算符</h3><p>“&amp;”运算符（位与）用于对两个二进制操作数逐位进行比较，并根据下表所示的换算表返回结果。</p><table><thead><tr><th>第一个数的位值</th><th style="text-align:center">第二个数的位值</th><th style="text-align:right">运算结果</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:right">1</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:right">0</td></tr><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:right">0</td></tr><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:right">0</td></tr></tbody></table><p>在位运算中，数值 1 表示 true，0 表示 false，反之亦然。<br>12 和 5 进行位与运算，则返回值为 4。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">12</span> &amp; <span class="number">5</span>);  <span class="comment">//返回值4</span></span><br></pre></td></tr></table></figure><h3 id="“-”运算符"><a href="#“-”运算符" class="headerlink" title="“|”运算符"></a>“|”运算符</h3><p>“|”运算符（位或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。</p><table><thead><tr><th>第一个数的位值</th><th style="text-align:center">第二个数的位值</th><th style="text-align:right">运算结果</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:right">1</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:right">1</td></tr><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:right">1</td></tr><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:right">0</td></tr></tbody></table><p>12 和 5 进行位或运算，则返回值为 13。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">12</span> | <span class="number">5</span>);  <span class="comment">//返回值13</span></span><br></pre></td></tr></table></figure></p><h3 id="“-”运算符-1"><a href="#“-”运算符-1" class="headerlink" title="“^”运算符"></a>“^”运算符</h3><p>“^”运算符（位异或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。</p><table><thead><tr><th>第一个数的位值</th><th style="text-align:center">第二个数的位值</th><th style="text-align:right">运算结果</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:right">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:right">1</td></tr><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:right">1</td></tr><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:right">0</td></tr></tbody></table><p>12 和 5 进行位异或运算，则返回值为 9。<br>纯文本复制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">12</span> ^ <span class="number">5</span>);  <span class="comment">//返回值9</span></span><br></pre></td></tr></table></figure></p><h3 id="“-”运算符-2"><a href="#“-”运算符-2" class="headerlink" title="“~”运算符"></a>“~”运算符</h3><p>“~”运算符（位非）用于对一个二进制操作数逐位进行取反操作。</p><ul><li>第 1 步：把运算数转换为 32 位的二进制整数。</li><li>第 2 步：逐位进行取反操作。</li><li>第 3 步：把二进制反码转换为十进制浮点数</li></ul><p>对 12 进行位非运算，则返回值为 -13。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( ~ <span class="number">12</span> );  <span class="comment">//返回值-13</span></span><br></pre></td></tr></table></figure></p><p>位非运算实际上就是对数字进行取负运算，再减 1。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( ~ <span class="number">12</span> == <span class="number">12</span><span class="number">-1</span>);  <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="双-的用法"><a href="#双-的用法" class="headerlink" title="双~的用法"></a>双~的用法</h4><p>~~它代表双非按位取反运算符，如果你想使用比Math.floor()更快的方法，那就是它了。需要注意，对于正数，它向下取整；对于负数，向上取整；非数字取值为0，它具体的表现形式为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="literal">null</span>;      <span class="comment">// =&gt; 0</span></span><br><span class="line">~~<span class="literal">undefined</span>; <span class="comment">// =&gt; 0</span></span><br><span class="line">~~<span class="literal">Infinity</span>;  <span class="comment">// =&gt; 0</span></span><br><span class="line">--<span class="literal">NaN</span>;       <span class="comment">// =&gt; 0</span></span><br><span class="line">~~<span class="number">0</span>;         <span class="comment">// =&gt; 0</span></span><br><span class="line">~~&#123;&#125;;        <span class="comment">// =&gt; 0</span></span><br><span class="line">~~[];        <span class="comment">// =&gt; 0</span></span><br><span class="line">~~(<span class="number">1</span>/<span class="number">0</span>);     <span class="comment">// =&gt; 0</span></span><br><span class="line">~~<span class="literal">false</span>;     <span class="comment">// =&gt; 0</span></span><br><span class="line">~~<span class="literal">true</span>;      <span class="comment">// =&gt; 1</span></span><br><span class="line">~~<span class="number">1.9</span>;       <span class="comment">// =&gt; 1</span></span><br><span class="line">~~<span class="number">-1.9</span>;      <span class="comment">// =&gt; -1</span></span><br></pre></td></tr></table></figure><h3 id="“-”-的用法，通常用来取整"><a href="#“-”-的用法，通常用来取整" class="headerlink" title="“|” 的用法，通常用来取整"></a>“|” 的用法，通常用来取整</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2</span>|<span class="number">0</span>  <span class="comment">// 1</span></span><br><span class="line"><span class="number">1.8</span>|<span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">-1.2</span>|<span class="number">0</span> <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">11.71</span>)     <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">11.71</span> &gt;&gt; <span class="number">0</span>)  <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">11.71</span> &lt;&lt; <span class="number">0</span>)  <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">11.71</span> | <span class="number">0</span>)   <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">11.71</span> &gt;&gt;&gt; <span class="number">0</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h3 id="使用左移运算符-lt-lt-迅速得出2的次方"><a href="#使用左移运算符-lt-lt-迅速得出2的次方" class="headerlink" title="使用左移运算符 &lt;&lt; 迅速得出2的次方"></a>使用左移运算符 &lt;&lt; 迅速得出2的次方</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">2</span>  <span class="comment">// 4, 即 2的2次方</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">10</span> <span class="comment">// 1024, 即 2的10次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是要注意使用场景</span></span><br><span class="line">a = <span class="number">2e9</span>;   <span class="comment">// 2000000000</span></span><br><span class="line">a &lt;&lt; <span class="number">1</span>;    <span class="comment">// -294967296</span></span><br></pre></td></tr></table></figure><h3 id="使用-切换变量-0-或-1"><a href="#使用-切换变量-0-或-1" class="headerlink" title="使用 ^ 切换变量 0 或 1"></a>使用 ^ 切换变量 0 或 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- before ---</span></span><br><span class="line"><span class="comment">// if 判断</span></span><br><span class="line"><span class="keyword">if</span> (toggle) &#123;</span><br><span class="line">    toggle = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    toggle = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三目运算符</span></span><br><span class="line">togle = toggle ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- after ---</span></span><br><span class="line">toggle ^= <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="使用-来完成值交换"><a href="#使用-来完成值交换" class="headerlink" title="使用^来完成值交换"></a>使用^来完成值交换</h3><p>在 ES6 的解构赋值出来之前，用这种方式会更快(但必须是整数)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- before ---</span></span><br><span class="line"><span class="keyword">let</span> temp = a; a = b; b = temp; <span class="comment">// 传统，但需要借助临时变量</span></span><br><span class="line">b = [a, a = b][<span class="number">0</span>] <span class="comment">// 借助数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- after ---</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"><span class="built_in">console</span>.log(a)   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b)   <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">[a, b] = [b, a]; <span class="comment">// ES6，解构赋值</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-amp-判断奇偶性"><a href="#使用-amp-判断奇偶性" class="headerlink" title="使用 &amp; 判断奇偶性"></a>使用 &amp; 判断奇偶性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span> &amp; <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span> &amp; <span class="number">1</span>) ;   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="使用-判断符号是否相同"><a href="#使用-判断符号是否相同" class="headerlink" title="使用^判断符号是否相同"></a>使用^判断符号是否相同</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a ^ b) &gt;= <span class="number">0</span>; <span class="comment">//  true 相同; false 不相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">(a ^ b) &gt;= <span class="number">0</span>; <span class="comment">//-12 falsee</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">(a ^ b) &gt;= <span class="number">0</span>; <span class="comment">//9 true</span></span><br></pre></td></tr></table></figure><h3 id="使用-A-0-5-0-来替代-Math-round"><a href="#使用-A-0-5-0-来替代-Math-round" class="headerlink" title="使用 A + 0.5 | 0 来替代 Math.round()"></a>使用 <code>A + 0.5 | 0</code> 来替代 Math.round()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">24.7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(a)); <span class="comment">//25;</span></span><br><span class="line"><span class="built_in">console</span>.log( a + <span class="number">0.5</span> | <span class="number">0</span> ); <span class="comment">//25;</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">24.1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(a)); <span class="comment">//24;</span></span><br><span class="line"><span class="built_in">console</span>.log( a + <span class="number">0.5</span> | <span class="number">0</span> ); <span class="comment">//24;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery 扩展方法，自定义函数等一些写法</title>
      <link href="/2020/02/22/jquery-fn/"/>
      <url>/2020/02/22/jquery-fn/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参数 </span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//弹出对象 x 里的 aa 变量和 bb 变量 </span></span><br><span class="line">    alert(x.aa + <span class="string">" "</span> + x.bb); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">$.windowbox = aa; </span><br><span class="line">$.windowbox(&#123; </span><br><span class="line">    aa: <span class="string">"哈哈"</span>, </span><br><span class="line">    bb: <span class="string">"啦啦"</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法定义 </span></span><br><span class="line">$.windowbox = &#123; </span><br><span class="line">    <span class="comment">//定义一个方法aa </span></span><br><span class="line">    aa: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">"aa"</span>); </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">//定义一个方法bb </span></span><br><span class="line">    bb: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">"bb"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$.windowbox.aa(); <span class="comment">//调用$.windowbox里的aa方法</span></span><br></pre></td></tr></table></figure><p>一种如<code>$.fn.extend({&#39;aa&#39;:function(){}})</code>,这种调用时就得这样,<code>$(this).aa()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.setApDiv=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">//apDiv浮动层显示位置居中控制 </span></span><br><span class="line">    <span class="keyword">var</span> wheight = $(<span class="built_in">window</span>).height(); </span><br><span class="line">    <span class="keyword">var</span> wwidth = $(<span class="built_in">window</span>).width(); </span><br><span class="line">    <span class="keyword">var</span> apHeight = wheight - $(<span class="string">"#apDiv"</span>).height(); </span><br><span class="line">    <span class="keyword">var</span> apWidth = wwidth - $(<span class="string">"#apDiv"</span>).width(); </span><br><span class="line">    $(<span class="string">"#apDiv"</span>).css(<span class="string">"top"</span>, apHeight / <span class="number">2</span>); </span><br><span class="line">    $(<span class="string">"#apDiv"</span>).css(<span class="string">"left"</span>, apWidth / <span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">$(<span class="string">"#apDiv"</span>).setApDiv(); </span><br><span class="line"><span class="comment">//jQuery.fn表示jquery内置函数，可以使用jquery对象直接操作；</span></span><br></pre></td></tr></table></figure><p>一种如 <code>$.extend({&#39;aa&#39;:function(){}})</code>,这种调用时就是这样<code>$.aa()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123; </span><br><span class="line">    <span class="comment">// 设置 apDiv </span></span><br><span class="line">    setApDiv : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="comment">//apDiv浮动层显示位置居中控制 </span></span><br><span class="line">        <span class="keyword">var</span> wheight = $(<span class="built_in">window</span>).height(); </span><br><span class="line">        <span class="keyword">var</span> wwidth = $(<span class="built_in">window</span>).width(); </span><br><span class="line">        <span class="keyword">var</span> apHeight = wheight - $(<span class="string">"#apDiv"</span>).height(); </span><br><span class="line">        <span class="keyword">var</span> apWidth = wwidth - $(<span class="string">"#apDiv"</span>).width(); </span><br><span class="line">        $(<span class="string">"#apDiv"</span>).css(<span class="string">"top"</span>, apHeight / <span class="number">2</span>); </span><br><span class="line">        $(<span class="string">"#apDiv"</span>).css(<span class="string">"left"</span>, apWidth / <span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line">$.setApDiv();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>onchange onpropertychange 和 oninput 事件的区别</title>
      <link href="/2019/12/27/oninput/"/>
      <url>/2019/12/27/oninput/</url>
      
        <content type="html"><![CDATA[<ol><li><p>onchange 事件与 onpropertychange 事件的区别：<br>onchange 事件在内容改变（两次内容有可能还是相等的）且失去焦点时触发。<br>onpropertychange 事件却是实时触发，即每增加或删除一个字符就会触发，通过 js 改变也会触发该事件，但是该事件 IE 专有。</p></li><li><p>oninput 事件与 onpropertychange 事件的区别：<br>oninput 事件是 IE 之外的大多数浏览器支持的事件，在 value 改变时触发，实时的，即每增加或删除一个字符就会触发，然而通过 js 改变 value 时，却不会触发。<br>onpropertychange 事件是任何属性改变都会触发的，而 oninput 却只在 value 改变时触发，oninput 要通过 addEventListener() 来注册，onpropertychange 注册方式跟一般事件一样。（此处都是指在js中动态绑定事件，以实现内容与行为分离）</p></li><li><p>oninput 与 onpropertychange 失效的情况：<br>（1）oninput 事件：a). 当脚本中改变 value 时，不会触发；b).从浏览器的自动下拉提示中选取时，不会触发。<br>（2）onpropertychange 事件：当 input 设置为 disable=tru e后，onpropertychange 不会触发。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb的使用</title>
      <link href="/2019/12/01/mongodb/"/>
      <url>/2019/12/01/mongodb/</url>
      
        <content type="html"><![CDATA[<h3 id="开启数据库"><a href="#开启数据库" class="headerlink" title="开启数据库"></a>开启数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath [data path]</span><br></pre></td></tr></table></figure><h3 id="启用验证"><a href="#启用验证" class="headerlink" title="启用验证"></a>启用验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27017</span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;adminUser&quot;,</span><br><span class="line">    pwd: &quot;adminPass&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">mongo --port 27017</span><br><span class="line">use admin</span><br><span class="line">db.auth(&quot;adminUser&quot;, &quot;adminPass&quot;)</span><br><span class="line">// 输出 1 表示验证成功</span><br></pre></td></tr></table></figure><h3 id="Mongodb-用户验证登陆-启动带访问控制的-Mongodb"><a href="#Mongodb-用户验证登陆-启动带访问控制的-Mongodb" class="headerlink" title="Mongodb 用户验证登陆 启动带访问控制的 Mongodb"></a>Mongodb 用户验证登陆 启动带访问控制的 Mongodb</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongod --auth --port 27017 --dbpath /data/db1</span><br><span class="line">mongo --port 27017 -u &quot;lyl&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure><h3 id="内建角色"><a href="#内建角色" class="headerlink" title="内建角色"></a>内建角色</h3><ul><li>Read：允许用户读取指定数据库</li><li>readWrite：允许用户读写指定数据库</li><li>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</li><li>userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</li><li>clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</li><li>readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</li><li>readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</li><li>userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</li><li>dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</li><li>root：只在admin数据库中可用。超级账号，超级权限</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1.进入mongo环境</span><br><span class="line">&gt; mongo</span><br><span class="line"></span><br><span class="line"># 2.切换到 &apos;admin&apos; 数据库</span><br><span class="line">&gt; use admin</span><br><span class="line"></span><br><span class="line"># 3.给admin设置用户</span><br><span class="line"># user: 用户名 </span><br><span class="line"># pwd: 用户密码</span><br><span class="line"># roles: 用来设置用户的权限，比如读，读写，写等等</span><br><span class="line">&gt; db.createUser(&#123;user: &apos;root&apos;, pwd: &apos;123456&apos;, roles: [&apos;root&apos;]&#125;)</span><br><span class="line"></span><br><span class="line"># 4.验证该用户 &apos;db.auth(用户名，用户密码)&apos;</span><br><span class="line">&gt; db.auth(&apos;root&apos;, &apos;123456&apos;)</span><br><span class="line"># 如果返回 &apos;1&apos;表示验证成功， 如果是 &apos;0&apos; 表示验证失败</span><br><span class="line"></span><br><span class="line"># 5.自定义数据库，并添加用户</span><br><span class="line"># a.创建 &apos;example&apos; 数据库</span><br><span class="line">&gt; use example</span><br><span class="line"></span><br><span class="line"># b.创建用户</span><br><span class="line">&gt; db.createUser(&#123;user: &apos;james&apos;, pwd: &apos;123456&apos;, roles: [&#123;role: &apos;readWrite&apos;&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"># c.验证该用户</span><br><span class="line">&gt; db.auth(&apos;james&apos;, &apos;123456&apos;)</span><br><span class="line"># 如果返回 &apos;1&apos;表示验证成功， 如果是 &apos;0&apos; 表示验证失败</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS规范化OOCSS、BEM、SMAcss、Atomic CSS</title>
      <link href="/2019/10/09/css-rule/"/>
      <url>/2019/10/09/css-rule/</url>
      
        <content type="html"><![CDATA[<h3 id="OOCSS-Object-Oriented-CSS-面向对象的css"><a href="#OOCSS-Object-Oriented-CSS-面向对象的css" class="headerlink" title="OOCSS(Object Oriented CSS)面向对象的css"></a>OOCSS(Object Oriented CSS)面向对象的css</h3><p>Object Oriented CSS，面向对象的CSS，旨在编写高可复用、低耦合和高扩展的CSS代码。<br>OOCSS是以面向对象的思想去定义样式，将抽象和实现分离，抽离公共代码。</p><p>主要分成四个部分</p><ul><li>Template ：模板<br>  人体架构 (.header, .body, .footer)<br>  垂直方向 (.top, .middle, .bottom)<br>  水平方向 (.left, .main, .right)</li><li>Grids ：栅格布局<br>  浮动布局 (.f-fl, f-fr)<br>  弹性盒子布局 (.container, .row, .col)<br>  Grid布局</li><li>Module ：组件<br>  各个组件特有的结构和样式。(btn, btn btn-error, modal md-title)</li><li>Content ：内容<br>  定义html标签，适合自己应用的基本样式，不用类，直接定义标签的样式。</li></ul><h3 id="BEM-Block-Element-Modifier"><a href="#BEM-Block-Element-Modifier" class="headerlink" title="BEM(Block,Element,Modifier)"></a>BEM(Block,Element,Modifier)</h3><p>Block Element Modifier，它是一种前端命名方法，旨在帮助开发者实现模块化、可复用、高可维护性和结构化的CSS代码。</p><p>BEM是定义了一种css class的命名规范，每个名称及其组成部分都是存在一定的含义。</p><table><thead><tr><th>Block</th><th>Element</th><th>Modifier</th></tr></thead><tbody><tr><td>独立且有意义的实体,例 header, container, menu, checkbox, 等</td><td>Block的一部分且没有独立的意义, 例 header title, menu item, list item, 等.</td><td>Blocks或Elements的一种标志，可以用它改变其表现形式、行为、状态. 例 disabled, checked, fixed, 等.</td></tr></tbody></table><p>也可以：B__E–M<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span>; &#125; </span><br><span class="line"><span class="selector-class">.article__title</span> &#123; <span class="attribute">font-size</span>: <span class="number">24px</span>; &#125;</span><br><span class="line"><span class="selector-class">.article__title--red</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="SMAcss"><a href="#SMAcss" class="headerlink" title="SMAcss"></a>SMAcss</h3><p>Scalable and Modular Architecture for CSS，可扩展模块化的CSS，它的核心就是结构化CSS代码，提出了一种CSS分类规则，SMACSS定义了一种css文件的组织方式，其横向的切分，使css文件更具有结构化、高可维护性。<br>分为五种类型：</p><ul><li>Base<br>  负责定义页面的默认样式，由于不同的浏览器都有自己的默认样式，要做到在不同浏览器上效果一致，需要开发者重写这些样式。<br>  例如html, body, input[type=text], a:hover 等<br>  常见的base配置有Reset.css 和 normalize.css</li><li>Layout<br>  不明思议，是对页面布局元素（页面架构中主要和次要的组件）的样式设置，例如header, navigation, footer, sidebar, login-form 等</li><li>Module<br>  对公共组件样式的设置，例如dropdown, tabs, carousels, dialogs, 等</li><li>State<br>  对组件、模块、元素等表现行为或状态的样式修饰，通过特殊的前缀指定命名空间和划分功能模块，例如hide, show, is-error, 等</li><li>Theme<br>  对页面整体布局样式的设置，可以说是一种皮肤，它可以在特定场景下覆盖base, layout等的默认样式。</li></ul><h3 id="Atomic-CSS"><a href="#Atomic-CSS" class="headerlink" title="Atomic CSS"></a>Atomic CSS</h3><p>原子化 CSS 结构。<br>优点是可以写基础 视觉功能小的，单用途的 CSS，相当于把每一个单一的作用定义一个Class，确保整个样式表没有一条重复的样式，这样复用性是最高的，代码也最少，但是每个元素就需要一堆的 Class。</p><p>这种思路可谓另辟蹊径，独树一帜。当然优缺点都很明显：CSS 代码最小化了，而 HTML 膨胀了；虽然不用考虑命名，但是要记一堆新规则。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mt-10 w-100 h-15"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// mt-10 &gt; margin-top: 10px;</span></span><br><span class="line"><span class="comment">// w-100 &gt; width: 100px;</span></span><br><span class="line"><span class="comment">// h-15 &gt; height: 15px;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex Basis与Width的区别</title>
      <link href="/2019/09/25/flex-basis/"/>
      <url>/2019/09/25/flex-basis/</url>
      
        <content type="html"><![CDATA[<p>原文： <a href="http://gedd.ski/post/the-difference-between-width-and-flex-basis/" target="_blank" rel="noopener">http://gedd.ski/post/the-difference-between-width-and-flex-basis/</a><br>翻译： <a href="https://www.jianshu.com/p/17b1b445ecd4" target="_blank" rel="noopener">https://www.jianshu.com/p/17b1b445ecd4</a></p><h3 id="Flex-Items的应用准则"><a href="#Flex-Items的应用准则" class="headerlink" title="Flex Items的应用准则"></a>Flex Items的应用准则</h3><p>content –&gt; width –&gt; flex-basis (limted by max|min-width)<br>也就是说，</p><ul><li>如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小</li><li>如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小</li></ul><p>下面通过给一个1000px的flex容器来添加一些flex items来说明一下Flex Items的应用准则：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        width: 1000px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面的示例就是当flex-basis没有被指定，默认值是flex-basis: auto，也就意味着items以宽度width(200px)为准。</p><h3 id="设置一个Flex-Basis值"><a href="#设置一个Flex-Basis值" class="headerlink" title="设置一个Flex Basis值"></a>设置一个Flex Basis值</h3><p>让我们看看当给这些已经设置固定宽度width的items设置一个flex-basis值会发生什么。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        width: 1000px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        flex-basis: 250px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>就像你所看到的，当指定一个flex-basis值的时候，盒子的宽度属性被忽略了，所以我们就不需要指定盒子的宽度width属性了</p><p>因此items的宽度关键在用最终的flex-basis。最佳的方法是只使用flex-basis而不是width或height属性。特别是Safari 10之前的版本的浏览器有一个flexbox bug，在给items应用flex-shrink属性的时候，浏览器会使用height属性而不是flex-basis。</p><h3 id="使用max-width来限制flex-basis"><a href="#使用max-width来限制flex-basis" class="headerlink" title="使用max-width来限制flex-basis"></a>使用max-width来限制flex-basis</h3><p>min-width和max-width会限制flex-basis值。下面是给flex items设置max-width的结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到即使我们将flex-basis设置为250px，item的宽度还是被限制在了100px。所以在这个示例中最终的flex-basis是100px：</p><p>接着试试min-width来看看最终的flex-basis有什么不同：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">250px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终item的宽度是250px而不是100px：</p><h3 id="Flex-basis到底是什么？"><a href="#Flex-basis到底是什么？" class="headerlink" title="Flex-basis到底是什么？"></a>Flex-basis到底是什么？</h3><p>现在我们知道了width属性只是一个当flex-basis没有被设置时的回退选项。min-width和max-width则是flex-basis的下限和上限。那么flex-basis到底是什么呢？</p><p>也许你注意到了上面我们所有的示例在将flex items放入flex容器之前都直观地列出了flex items的大小。之所以这么做是因为这就是flex-basis的含义：flex items 在被放进一个flex容器之前的大小。也就是items理想或假设的大小。但是flex-basis不能保证其大小！一旦将items放入flex容器中，flex-basis的值就无法保证了。在上面的示例中，你可以看到flex items完美地填充了容器，那是因为容器的大小正好等于items最终的flex-basis之和。但是如果容器没有足够的空间来容纳或者有多余的空间呢？下面就分别讲解一下这两种情况：</p><h3 id="当没有足够空间的时候"><a href="#当没有足够空间的时候" class="headerlink" title="当没有足够空间的时候"></a>当没有足够空间的时候</h3><p>比方说我们想要放更多的flex-basis：200px的items到我们的容器：</p><p>在items被放进容器之前，每个item会占据200px，所有的items会占据1600px。但是容器只有1000px。当容器没有足够大的空间来存放所有的items的时候，flex items会按照压缩率(shrink rate)被压缩(shrink)其大小来填充容器,这个压缩率就是flex-shrink来设置的，默认情况下每个item的压缩率都是一样的：</p><h3 id="当有额外的空间的时候"><a href="#当有额外的空间的时候" class="headerlink" title="当有额外的空间的时候"></a>当有额外的空间的时候</h3><p>通常我们会有额外的空间剩余当所有的items都添加进容器后：</p><p>我们可以控制flex items的增长来填充可用的空间，这也就是flex-grow属性的作用。默认值为0，意味着item不会增长。如果将每个item设置flex-grow： 1，那么所有 的item都会等比例的增长来填充剩余的空间：</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料查阅</title>
      <link href="/2019/09/22/note-page/"/>
      <url>/2019/09/22/note-page/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="react-fiber"><a href="#react-fiber" class="headerlink" title="react-fiber"></a>react-fiber</h3><p><a href="https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">React技术揭秘</a><br><a href="https://juejin.im/post/6859528127010471949" target="_blank" rel="noopener">React Fiber 源码解析</a><br><a href="https://zhuanlan.zhihu.com/p/77579841" target="_blank" rel="noopener">浅谈React Fiber</a><br><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">[译]深入React fiber架构及源码</a><br><a href="https://juejin.im/post/6847902224287285255" target="_blank" rel="noopener">componentWillXXX为什么UNSAFE</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">如何实现一个 Virtual DOM 算法</a></p><h3 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react-hooks"></a>react-hooks</h3><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data" target="_blank" rel="noopener">How to fetch data with React Hooks</a><br><a href="https://juejin.im/post/6867745889184972814#heading-2" target="_blank" rel="noopener">React Hook干了啥</a><br><a href="https://zhuanlan.zhihu.com/p/48264713" target="_blank" rel="noopener">对React Hooks的一些思考</a><br><a href="https://juejin.im/post/6844904127110053895" target="_blank" rel="noopener">用动画和实战打开 React Hooks</a><br><a href="https://zhuanlan.zhihu.com/p/60277120" target="_blank" rel="noopener">useEffect 完全指南</a></p><h3 id="js-other"><a href="#js-other" class="headerlink" title="js-other"></a>js-other</h3><p><a href="https://juejin.im/post/6844903668563574798" target="_blank" rel="noopener">Next.js踩坑入门</a><br><a href="https://blog.csdn.net/weixin_33701564/article/details/87962120" target="_blank" rel="noopener">使用next.js完成从开发到部署</a><br><a href="https://segmentfault.com/blog/big-front-end" target="_blank" rel="noopener">大前端之路</a><br><a href="https://www.jianshu.com/p/3d2dd446c522" target="_blank" rel="noopener">memoization</a><br><a href="http://anata.me/2019/06/24/Koa%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">Koa源码浅析</a><br><a href="https://juejin.im/post/6864869694390665224#heading-1" target="_blank" rel="noopener">手动实现一个 react-router-dom</a><br><a href="https://juejin.im/post/6866372840451473415" target="_blank" rel="noopener">Promise原理及全功能实现</a><br><a href="https://zhuanlan.zhihu.com/p/133658121" target="_blank" rel="noopener">ES2020 新特性出炉</a><br><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2020/" target="_blank" rel="noopener">What’s new in ECMAScript 2020</a><br><a href="https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">渲染树构建、布局及绘制</a><br><a href="https://developers.google.cn/web/fundamentals/primers/service-workers" target="_blank" rel="noopener">Service Worker：简介</a></p><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p><a href="https://juejin.im/post/6872111128135073806" target="_blank" rel="noopener">TS 学习指南</a><br><a href="https://juejin.im/post/6871752423577223176" target="_blank" rel="noopener">困扰过的 TS 问题</a><br><a href="https://juejin.im/post/6875091047752400910" target="_blank" rel="noopener">TS 中那些奇怪的符号</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://juejin.im/post/6866970001409064967#heading-4" target="_blank" rel="noopener">前端数据结构</a><br><a href="https://juejin.im/post/6850418120755494925#heading-10" target="_blank" rel="noopener">算法与数据结构</a><br><a href="https://juejin.im/post/6874708801208254478" target="_blank" rel="noopener">哈希算法之美</a></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><a href="https://juejin.im/post/6859888538004783118" target="_blank" rel="noopener">由浅入深配置webpack4</a></p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p><a href="https://blog.csdn.net/u013510838?t=1" target="_blank" rel="noopener">Tensorflow源码解析和机器学习</a></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><a href="https://www.cnblogs.com/xiahj/p/8036419.html#webkit-overflow-scrollingtouch%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener"> -webkit-overflow-scrolling:touch</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://blog.csdn.net/vampire10086/category_10021995.html" target="_blank" rel="noopener">每日3+1</a></p><h2 id="别的一些博客"><a href="#别的一些博客" class="headerlink" title="别的一些博客"></a>别的一些博客</h2><p><a href="https://gafferongames.com/#posts" target="_blank" rel="noopener">Gaffer On Games</a><br><a href="https://fed.taobao.org/" target="_blank" rel="noopener">淘系前端团队</a><br><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener">函数式编程指北</a><br><a href="https://www.keithcirkel.co.uk/" target="_blank" rel="noopener">Keith Cirkel</a><br><a href="https://hakim.se/" target="_blank" rel="noopener">Hakim El Hattab 喜欢尝试图形和交互性</a><br><a href="https://mxstbr.blog/2016/11/styled-components-magic-explained/" target="_blank" rel="noopener">The magic behind 💅 styled-components</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20" target="_blank" rel="noopener">生成console</a><br><a href="https://picsum.photos/" target="_blank" rel="noopener">随机图片请求</a><br><a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener">JSONPlaceholder</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 1.0、1.1、2.0的区别详解</title>
      <link href="/2019/07/25/http/"/>
      <url>/2019/07/25/http/</url>
      
        <content type="html"><![CDATA[<h3 id="1-http-1-0"><a href="#1-http-1-0" class="headerlink" title="1.http 1.0"></a>1.http 1.0</h3><h4 id="1-1-链接无法复用，即不支持持久链接："><a href="#1-1-链接无法复用，即不支持持久链接：" class="headerlink" title="1.1 链接无法复用，即不支持持久链接："></a>1.1 链接无法复用，即不支持持久链接：</h4><p>http 1.0 规定浏览器与服务器保持较短时间的链接，浏览器每次请求都和服务器经过三次握手和慢启动（基本思想是当TCP开始传输数据或发现数据丢失并开始重发时，首先慢慢的对网路实际容量进行试探，避免由于发送了过量的数据而导致阻塞）建立一个TCP链接，服务器完成请求处理后立即断开TCP链接，而且不跟踪每个浏览器的历史请求。<br>注意：由于http 1.0每次建立TCP链接对性能的影响实在是太大，http1.1实现持久化链接之后，又反向移植到http 1.0上，只是默认是没有开启持久链接的，通过http的header部分的 Connection: KeepAlive 来启用）</p><h4 id="1-2-线头阻塞（Head-of-Line-HOL-Blocking）"><a href="#1-2-线头阻塞（Head-of-Line-HOL-Blocking）" class="headerlink" title="1.2 线头阻塞（Head of Line (HOL) Blocking）"></a>1.2 线头阻塞（Head of Line (HOL) Blocking）</h4><p>请求队列的第一个请求因为服务器正忙（或请求格式问题等其他原因），导致后面的请求被阻塞。</p><h3 id="2-http-1-1"><a href="#2-http-1-1" class="headerlink" title="2.http 1.1"></a>2.http 1.1</h3><h4 id="2-1-支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）"><a href="#2-1-支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）" class="headerlink" title="2.1 支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）"></a>2.1 支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）</h4><p>一个TCP链接可以传送多个http请求和相应，减少了TCP建立链接和关闭链接的消耗。另外http1.1允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能 够区分出每次请求的响应内容。</p><h4 id="2-2-支持http管道"><a href="#2-2-支持http管道" class="headerlink" title="2.2 支持http管道"></a>2.2 支持http管道</h4><p>不使用管道的http请求，在使用持久链接时，必须严格满足先进先出的队列顺序（FIFO），即发送请求，等待响应完成，再发送客户端队列中的下一个请求。管道可以让我们把 FIFO 队列从客户端（请求队列）迁移到服务器（响应队列），即客户端可以并行，服务端串行。客户端可以不用等待前一个请求返回，发送请求，但服务器端必须顺序的返回客户端的请求响应结果。<br>缺点：<br>a. 一个请求响应阻塞，就会阻塞后续所有请求<br>b. 并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面；<br>c. 响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，导致重复处理；<br>d. 由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要；<br>e. 如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来</p><h4 id="2-3-使用多个TCP链接"><a href="#2-3-使用多个TCP链接" class="headerlink" title="2.3 使用多个TCP链接"></a>2.3 使用多个TCP链接</h4><p>http1.1 在客户端排队所有请求，然后通过一个TCP持久链接，一个接一个的发送请求（如果有http管道还必须顺序等待服务端的顺序返回结果）。但实际中，浏览器的开发时不会这么笨，浏览器允许我们打开N个TCP链接（大多说浏览器是6个TCP链接，这个数字越大，客户端和服务器的资源占用越多，这个数据也只是感觉安全的数字而已）。</p><p>2.3.1 带来的好处：<br>1.客户端可以并行发送最多 N个请求；<br>2.服务器可以并行处理最多 N个请求；<br>3.第一次往返可以发送的累计分组数量（TCP cwnd）增长为原来的 N 倍。</p><p>2.3.2 代价：<br>1.更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU时钟周期；<br>2.并行 TCP 流之间竞争共享的带宽；<br>3.由于处理多个套接字，实现复杂性更高；<br>4.即使并行 TCP 流，应用的并行能力也受限制。<br>因此使用多个TCP链接只是权宜之计，后续的http 2.0支持多路复用，很好的解决了上述问题。</p><h4 id="2-4-http-1-1-增加了请求头和响应头来扩充功能"><a href="#2-4-http-1-1-增加了请求头和响应头来扩充功能" class="headerlink" title="2.4 http 1.1 增加了请求头和响应头来扩充功能"></a>2.4 http 1.1 增加了请求头和响应头来扩充功能</h4><p>举例：<br>a. 支持Host请求：<br>b. Connection: 请求头的值为Connection时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close 时，客户端通知服务器返回本次请求结果后关闭连接<br>c. 支持断点续传:<br>d.身份认证：<br>e.状态管理:<br>f. 缓存处理：</p><h4 id="2-5-域名分区"><a href="#2-5-域名分区" class="headerlink" title="2.5 域名分区"></a>2.5 域名分区</h4><p>域名分区是思想是将原来集中到一个服务器上的资源分布到多个服务器上，这样就可以突破浏览器的链接限制（一般是6个），提高并行能力。<br>代价：<br>1.每多一台主机都要多一次的 DNS 查询，每多一个套接字都会多消耗两端的一些资源；<br>2.必须手工分离一台主机上的资源到多台；.<br>实际实践中，效果并不是很明显，反而导致被滥用。</p><h4 id="2-6-http的header的优化"><a href="#2-6-http的header的优化" class="headerlink" title="2.6 http的header的优化"></a>2.6 http的header的优化</h4><p>目前所有的header请求都是以没有经过压缩的纯文本的形式发送（通常会有600`1000字节），而通常使用的http请求body却很少（10~200字节），和header相比，显得很少，特别是在使用了cookie之后，这样的矛盾就更加突出，因此要减少header的数据。</p><h4 id="2-7-减少连接次数"><a href="#2-7-减少连接次数" class="headerlink" title="2.7 减少连接次数"></a>2.7 减少连接次数</h4><p>即将需要多次才能获取的文件或资源组合并成一个，通过一次网络请求获取。这样减少了协议的开销，间接地将服务器端的管道思维移植到了客户端。缺点：增加复杂性，更缓存带来负担，页面的分步显示，改成一次显示，在网络慢的时候影响用户体验。</p><h4 id="2-8-嵌入小的文件"><a href="#2-8-嵌入小的文件" class="headerlink" title="2.8 嵌入小的文件"></a>2.8 嵌入小的文件</h4><p>即将资源嵌入文档（通过URI嵌入图片，音频或PDF），可以减少请求次数。嵌入资源作为页面的返回一部分一次返回，即如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小，如果嵌入资源被更新，客户端只能重新获取有效的资源。<br>实践：一般只考虑嵌入1~2KB一下的资源</p><p>参照建议：<br>1.如果文件很小，而且只有个别页面使用，可以考虑嵌入；<br>2.如果文件很小，但需要在多个页面中重用，应该考虑集中打包；<br>3.如果小文件经常需要更新，就不要嵌入了；<br>4.通过减少 HTTP cookie 的大小将协议开销最小化</p><h3 id="3-http-2-0"><a href="#3-http-2-0" class="headerlink" title="3. http 2.0"></a>3. http 2.0</h3><p>HTTP 2.0把解决性能问题的方案内置在了传输层，通过多路复用来减少延迟，通过压缩 HTTP首部降低开销，同时增加请求优先级和服务器端推送的功能。</p><h4 id="3-1-支持多路复用"><a href="#3-1-支持多路复用" class="headerlink" title="3.1 支持多路复用"></a>3.1 支持多路复用</h4><p>多路复用允许同时通过单一的 HTTP 2.0 连接发起多重的请求-响应消息，即所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可，所有数据流共用同一个连接 ，减少了因http链接多而引起的网络拥塞（在 HTTP1.1 协议中，同一时间，浏览器会针对同一域名下的请求有一定数量限制），解决了慢启动针对突发性和短时性的http链接低效的问题。</p><h4 id="3-2-将通信的基本单位缩小为帧"><a href="#3-2-将通信的基本单位缩小为帧" class="headerlink" title="3.2 将通信的基本单位缩小为帧"></a>3.2 将通信的基本单位缩小为帧</h4><p>即应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层，因此在多向请求和响应时，客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来，解决了http 1.*的对手阻塞问题。</p><h4 id="3-3-首部压缩"><a href="#3-3-首部压缩" class="headerlink" title="3.3 首部压缩"></a>3.3 首部压缩</h4><p>http 2.0支持DEFLATE和HPACK 算法的压缩。</p><h4 id="3-4-服务端推送"><a href="#3-4-服务端推送" class="headerlink" title="3.4 服务端推送"></a>3.4 服务端推送</h4><p>指客户端请求之前发送数据的机制，在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应。</p><h4 id="3-5-请求优先级"><a href="#3-5-请求优先级" class="headerlink" title="3.5 请求优先级"></a>3.5 请求优先级</h4><p>HTTP 2.0 使用一个31比特的优先值,0表示最高优先级, 2(31)-1表示最低优<br>先级，服务器端就可以根据优先级，控制资源分配，优先处理和返回最高优先级的请求帧给客户端。</p><p>作者：zhglance<br>链接：<a href="https://www.jianshu.com/p/ac628fda40f2" target="_blank" rel="noopener">https://www.jianshu.com/p/ac628fda40f2</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async和await使用</title>
      <link href="/2019/07/24/async-await/"/>
      <url>/2019/07/24/async-await/</url>
      
        <content type="html"><![CDATA[<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>函数前面的async一词意味着一个简单的事情：这个函数总是返回一个promise，如果代码中有return &lt;非promise&gt;语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(alert) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在每一个函数前面的都加上async，函数内部，如果是异步操作，直接在其前面加上await即可，等待一步函数执行的结果。await后面可以接任何变量，可以是常量或者promise。async修饰的函数自动变成一个promise.正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'my god, failure'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(timeout(<span class="literal">true</span>))  <span class="comment">// 调用Promise.resolve() 返回promise 对象。</span></span><br><span class="line"><span class="built_in">console</span>.log(timeout(<span class="literal">false</span>)); <span class="comment">// 调用Promise.reject() 返回promise 对象。</span></span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p><strong>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，await命令的参数是数值123，这时等同于return 123。</p><p>另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。<br>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure></p><p>注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</p><p>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。</p><p><strong>如果一个promise正常resolve，那么await返回这个结果，但是在reject的情况下会抛出一个错误，就好像在那一行有一个throw语句一样。</strong></p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>让我们来看promise链式操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">showAvatar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// read our JSON</span></span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'/article/promise-chaining/user.json'</span>)</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> response.json()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read github user</span></span><br><span class="line">    <span class="keyword">let</span> githubResponse = <span class="keyword">await</span> fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;user.name&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">let</span> githubUser = <span class="keyword">await</span> githubResponse.json()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 展示头像</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">    img.src = githubUser.avatar_url</span><br><span class="line">    img.className = <span class="string">'promise-avatar-example'</span></span><br><span class="line">    documenmt.body.append(img)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待3s</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    img.remove()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> githubUser</span><br><span class="line">&#125;</span><br><span class="line">showAvatar()</span><br></pre></td></tr></table></figure></p><p><code>return promise</code> 和 <code>return await promise</code>区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">resolve(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">testPromise.then(<span class="function"><span class="params">rsp</span> =&gt;</span> <span class="built_in">console</span>.log(rsp)); <span class="comment">// 没能调用resolve</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processDataInWorker</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">123</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProcessedData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> processDataInWorker(); <span class="comment">// 注意 `return await` 和单独 `return` 的比较</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProcessedData1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">return</span> processDataInWorker(); <span class="comment">// 注意 `return await` 和单独 `return` 的比较</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getProcessedData();   <span class="comment">//null</span></span><br><span class="line">getProcessedData1();  <span class="comment">//throw 123</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3自定义滚动条样式</title>
      <link href="/2019/07/15/css-sroll/"/>
      <url>/2019/07/15/css-sroll/</url>
      
        <content type="html"><![CDATA[<h3 id="自定义滚动条实现"><a href="#自定义滚动条实现" class="headerlink" title="自定义滚动条实现"></a>自定义滚动条实现</h3><p>此部分针对webkit内核的浏览器，使用伪类来改变滚动条的默认样式，详情如下：</p><h3 id="滚动条组成部分"><a href="#滚动条组成部分" class="headerlink" title="滚动条组成部分"></a>滚动条组成部分</h3><ol><li>::-webkit-scrollbar 滚动条整体部分</li><li>::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或向左向右移动）</li><li>::-webkit-scrollbar-track 滚动条的轨道（里面装有Thumb）</li><li>::-webkit-scrollbar-button 滚动条的轨道的两端按钮，由于通过点击微调小方块的位置。</li><li>::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分</li><li>::-webkit-scrollbar-corner 边角，即垂直滚动条和水平滚动条相交的地方</li><li>::-webkit-resizer 两个滚动条的交汇处上用于拖动调整元素大小的小控件</li></ol><h3 id="滚动条组成结构图如下："><a href="#滚动条组成结构图如下：" class="headerlink" title="滚动条组成结构图如下："></a>滚动条组成结构图如下：</h3><p><img src="/images/scroll.png" alt="滚动条"></p><h3 id="其他设置项："><a href="#其他设置项：" class="headerlink" title="其他设置项："></a>其他设置项：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:horizontal</span>  </span><br><span class="line">//horizontal伪类适用于任何水平方向上的滚动条  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:vertical</span>  </span><br><span class="line">//vertical伪类适用于任何垂直方向的滚动条  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:decrement</span>  </span><br><span class="line">//decrement伪类适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:increment</span>  </span><br><span class="line">//increment伪类适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:start</span>  </span><br><span class="line">//start伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的前面  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:end</span>  </span><br><span class="line">//end伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的后面  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:double-button</span>  </span><br><span class="line">//double-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:single-button</span>  </span><br><span class="line">//single-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:no-button</span>  </span><br><span class="line"><span class="selector-tag">no-button</span>伪类表示轨道结束的位置没有按钮。  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:corner-present</span>  </span><br><span class="line">//corner-present伪类表示滚动条的角落是否存在。  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">:window-inactive</span>  </span><br><span class="line">//适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track-piece</span><span class="selector-pseudo">:start</span> &#123;  </span><br><span class="line"><span class="comment">/*滚动条上半边或左半边*/</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span><span class="selector-pseudo">:window-inactive</span> &#123;  </span><br><span class="line"><span class="comment">/*当焦点不在当前区域滑块的状态*/</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:horizontal</span><span class="selector-pseudo">:decrement</span><span class="selector-pseudo">:hover</span> &#123;  </span><br><span class="line"><span class="comment">/*当鼠标在水平滚动条下面的按钮上的状态*/</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 深浅拷贝</title>
      <link href="/2019/05/27/js-clone-cloneDeep/"/>
      <url>/2019/05/27/js-clone-cloneDeep/</url>
      
        <content type="html"><![CDATA[<p>基本数据类型：String，Boolean，Number，Undefined，Null；<br>引用数据类型：Object(Array，Date，RegExp，Function)；</p><p>基本数据类型和引用数据类型的区别：</p><ol><li><p>保存位置不同：基本数据类型保存在栈内存中，引用数据类型保存在堆内存中，然后在栈内存中保存了一个对堆内存中实际对象的引用，即数据在堆内存中的地址，JS对引用数据类型的操作都是操作对象的引用而不是实际的对象，如果obj1拷贝了obj2，那么这两个引用数据类型就指向了同一个堆内存对象，具体操作是obj1将栈内存的引用地址复制了一份给obj2，因而它们共同指向了一个堆内存对象；<br>为什么基本数据类型保存在栈中，而引用数据类型保存在堆中？</p><p> 1) 堆比栈大，栈比堆速度快；<br> 2) 本数据类型比较稳定，而且相对来说占用的内存小；<br> 3) 引用数据类型大小是动态的，而且是无限的，引用值的大小会改变，不能把它放在栈中，否则会降低变量查找的速度，因此放在变量栈空间的值是该对象存储在堆中的地址，地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响；<br> 4) 堆内存是无序存储，可以根据引用直接获取</p></li><li><p>基本数据类型使用typeof可以返回其基本数据类型，但是NULL类型会返回object，因此null值表示一个空对象指针；引用数据类型使用typeof会返回object，此时需要使用instanceof来检测引用数据类型；</p></li><li>定义引用数据类型需要使用new操作符，后面再跟一个构造函数来创建；<br> 1) 使用new操作符创建对象；<br> 2) 使用对象字面量表示法创建对象；<br> 3) 可以通过点表示法访问对象的属性，也可以使用方括号表示法来访问对象的属性；</li></ol><p><img src="/images/stack1.png" alt="栈内存"><br><img src="/images/stack2.png" alt="堆内存"></p><h2 id="深拷贝和浅拷贝简单解释"><a href="#深拷贝和浅拷贝简单解释" class="headerlink" title="深拷贝和浅拷贝简单解释"></a>深拷贝和浅拷贝简单解释</h2><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；</p><p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；<br><img src="/images/object-copy.webp" alt="深拷贝和浅拷贝"></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只复制第一层的浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleCopy</span>(<span class="params">obj1</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj2 = <span class="built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">   obj2[i] = obj1[i];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>,<span class="attr">b</span>: <span class="number">2</span>,<span class="attr">c</span>: &#123;<span class="attr">d</span>: <span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = simpleCopy(obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.c.d = <span class="number">4</span>;</span><br><span class="line">alert(obj1.a); <span class="comment">// 1</span></span><br><span class="line">alert(obj2.a); <span class="comment">// 3</span></span><br><span class="line">alert(obj1.c.d); <span class="comment">// 4</span></span><br><span class="line">alert(obj2.c.d); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>Object.assign()实现浅拷贝及一层的深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;  <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, <span class="attr">c</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj1)</span><br><span class="line">obj2.a.b = <span class="number">3</span>;</span><br><span class="line">obj2.c = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.a.b); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.a.b); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>数组的潜拷贝有 <code>Array.prototype.slice</code> 和 <code>Array.prototype.concat</code> 和 <code>Array.from</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.prototype.slice</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.slice();</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">4</span>].a = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.prototype.concat</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> newArr = [].concat(arr);</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">arr[<span class="number">4</span>].a = <span class="number">31</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.from</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> newArr = <span class="built_in">Array</span>.from(arr);</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">arr[<span class="number">4</span>].a = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, newArr);</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>使用JSON.stringify和JSON.parse实现深拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _obj = <span class="built_in">JSON</span>.stringify(obj1);</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">    <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> b = deepCopy(a);</span><br><span class="line">b[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">alert(a); <span class="comment">// 1,1,2,3,4</span></span><br><span class="line">alert(b); <span class="comment">// 2,2,2,3,4</span></span><br></pre></td></tr></table></figure><p><strong>缺陷</strong>：<br>它会抛弃对象的<code>constructor</code>，深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object；这种方法能正确处理的对象只有 <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Array</code>, 扁平对象，也就是说，只有可以转成JSON格式的对象才可以这样用，像<code>function</code>没办法转成<code>JSON</code>；<br>拷贝 <code>Date</code> 引用类型会变成字符串, 且转换结果不正确；<br>拷贝 <code>RegExp</code> 引用类型会变成空对象；<br>对象中含有 <code>NaN</code> 、 <code>Infinity</code> 和 <code>-Infinity</code> ，则序列化的结果会变成 <code>null</code> ；<br>无法拷贝对象的循环应用(即 <code>obj[key] = obj</code> )。<br>会忽略 <code>undefined</code> , <code>Symbol</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    h1: <span class="string">'test'</span>,</span><br><span class="line">    h2: <span class="literal">undefined</span>,</span><br><span class="line">    h3: <span class="built_in">Symbol</span>(<span class="number">1</span>),</span><br><span class="line">    h4: <span class="literal">NaN</span>,</span><br><span class="line">    h5: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    h6: <span class="regexp">/'1234'/</span>,</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">// ==&gt; &#123;h1: "test", h4: null, h5: "2021-11-04T07:41:46.039Z", h6: &#123;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj1.fun); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj2.fun); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>递归实现深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj1 &amp;&amp; <span class="keyword">typeof</span> obj1 === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj1.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="comment">// 如果子属性为引用数据类型，递归复制</span></span><br><span class="line">        <span class="keyword">if</span> (obj1[i] &amp;&amp; <span class="keyword">typeof</span> obj1[i] === <span class="string">"object"</span>) &#123;</span><br><span class="line">            obj2[i] = deepCopy(obj1[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是基本数据类型，只是简单的复制</span></span><br><span class="line">            obj2[i] = obj1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = deepCopy(obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.c.d = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a, obj2.a); <span class="comment">// 1  3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c.d, obj2.c.d); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure><p><strong>缺陷</strong>：当遇到两个互相引用的对象，会出现死循环的情况，为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj1 &amp;&amp; <span class="keyword">typeof</span> obj1 === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">        <span class="keyword">var</span> prop = obj1[i]; <span class="comment">// 避免相互引用造成死循环，如obj1.a=obj</span></span><br><span class="line">        <span class="keyword">if</span> (prop == obj1) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj1.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="comment">// 如果子属性为引用数据类型，递归复制</span></span><br><span class="line">        <span class="keyword">if</span> (prop &amp;&amp; <span class="keyword">typeof</span> prop === <span class="string">"object"</span>) &#123;</span><br><span class="line">            obj2[i] = (prop.constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(prop, obj2[i]); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是基本数据类型，只是简单的复制</span></span><br><span class="line">            obj2[i] = prop;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span> &#125;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = deepCopy(obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.c.d = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a, obj2.a); <span class="comment">// 1  3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c.d, obj2.c.d); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure><p>热门的函数库<code>lodash</code>，也有提供<code>_.cloneDeep</code>用来做深拷贝, <code>jquery</code> 提供一个<code>$.extend</code>也可以用来做深拷贝。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.create和new object</title>
      <link href="/2019/05/25/Object-create-new-object/"/>
      <url>/2019/05/25/Object-create-new-object/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a><code>Object.create</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.create(proto, propertiesObject)</span><br></pre></td></tr></table></figure><p>参数<br><strong>proto</strong><br>新创建对象的原型对象。<br><strong>propertiesObject</strong><br>可选。如果没有指定为 <code>undefined</code>，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应<code>Object.defineProperties()</code>的第二个参数</p><p>返回值<br>一个新对象，带着指定的原型对象和属性。</p><p><strong>注意</strong><br>新创建出来的对象的原型 （新对象的 <code>__proto__</code>属性指向的对象），值得注意的是当<code>proto</code>为<code>null</code>的时候创建的新对象完全是一个空对象，没有原型，也就是没有继承<code>Object.prototype</code>上的方法。（如<code>hasOwnProperty() toString()</code> 等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;&#125; no properties</span></span><br></pre></td></tr></table></figure><p>作用:</p><ol><li>创建一个对象</li><li>继承指定父对象</li><li>为新对象扩展新属性</li></ol><h3 id="用-Object-create实现类式继承"><a href="#用-Object-create实现类式继承" class="headerlink" title="用 Object.create实现类式继承"></a>用 Object.create实现类式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x += x;</span><br><span class="line">    <span class="keyword">this</span>.y += y;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Shape.call(<span class="keyword">this</span>); <span class="comment">// call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类续承父类</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is rect an instance of Rectangle?'</span>,  rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is rect an instance of Shape?'</span>,  rect <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Outputs, 'Shape moved.'</span></span><br></pre></td></tr></table></figure><h2 id="new-Object"><a href="#new-Object" class="headerlink" title="new Object()"></a><code>new Object()</code></h2><ul><li><code>new</code> 运算符是创建一个自定义对象或者具有构造函数的内置对象的实例<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">mdn</a></li><li>使用<code>new</code>运算符会创建一个新的对象，它继承自构造函数的prototype,也就是说它的<code>__proto__</code>属性会指向构造函数的prototype</li><li><code>new Object()</code> 也就是具有构造函数的内置<code>Object</code>的实例，新创建的对象的<code>__proto__</code>属性会指向<code>Object</code>的prototype</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectFactory = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()              <span class="comment">// 从Object.prototype上克隆一个空对象 此时 __proto__ 指向Object.prototype</span></span><br><span class="line">   <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>)  <span class="comment">//取得构造器</span></span><br><span class="line">   obj.__proto__ = Constructor.prototype  <span class="comment">// 指向构造器的prototype</span></span><br><span class="line">   <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>)  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = objectFactory(Person, <span class="string">'nancy'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.name)  <span class="comment">// nancy</span></span><br><span class="line"><span class="built_in">console</span>.log(a.getName) <span class="comment">//nancy</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a)  === Person.protoType) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="总结区别"><a href="#总结区别" class="headerlink" title="总结区别"></a>总结区别</h2><ul><li><code>Object.cerate()</code> 必须接收一个对象参数，创建的新对象的原型指向接收的参数对象，<code>new Object()</code> 创建的新对象的原型指向的是 <code>Object.prototype</code>. （简洁点说就是前者继承指定对象， 后者继承内置对象Object）</li><li>可以通过<code>Object.create(null)</code> 创建一个干净的对象，也就是没有原型，而 <code>new Object()</code> 创建的对象是 <code>Object</code>的实例，原型永远指向<code>Object.prototype</code>.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升和函数提升</title>
      <link href="/2019/04/11/function-scoping-and-hoisting/"/>
      <url>/2019/04/11/function-scoping-and-hoisting/</url>
      
        <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。(注：当前流行的JS引擎大都对源码进行了编译，由于引擎的不同，编译形式也会有所差异，我们这里说的预编译和提升其实是抽象出来的、易于理解的概念)<br>下面的代码中，我们在函数中声明了一个变量，不过这个变量声明是在if语句块中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure><p>运行代码，我们会发现foo的值是5，初学者可能对此不甚理解，如果外层作用域也存在一个foo变量，就更加困惑了，该不会是打印外层作用域中的foo变量吧？答案是：不会，如果当前作用域中存在此变量声明，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预编译之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        foo = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure><p>是的，引擎将变量声明提升到了函数顶部，初始值为undefined，自然，if语句块就会被执行，foo变量赋值为5，下面的打印也就是预期的结果了。<br>类似的，还有下面一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = foo || <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure></p><p><code>foo || 5</code>这个表达式的结果是5而不是3，虽然外层作用域有个foo变量，但函数内是不会去引用的，因为预编译之后的代码逻辑是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预编译之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    foo = foo || <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure><p>如果当前作用域中声明了多个同名变量，那么根据我们的推断，它们的同一个标识符会被提升至作用域顶部，其他部分按顺序执行，比如下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure></p><p>由于JavaScript在es6之前没块作用域，只有全局作用域和函数作用域，所以预编译之后的代码逻辑为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预编译之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    foo = <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        foo = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure></p><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>相信大家对下面这段代码都不陌生，实际开发当中也很常见：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo(); <span class="comment">// output: I am hoisted</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am hoisted'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure><p>为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部，预编译之后的代码逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预编译之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am hoisted'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(); <span class="comment">// output: I am hoisted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure><p>相似的，如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(); <span class="comment">// output: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure></p><p>对于函数，除了使用上面的函数声明，更多时候，我们会使用函数表达式，下面是函数声明和函数表达式的对比：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function declaration'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'anonymous function expression'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'named function expression'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，而具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。我们也看到了，其实函数表达式可以通过变量访问，所以也存在变量提升同样的效果。</p><p>那么当函数声明遇到函数表达式时，会有什么样的结果呢，先看下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    foo(); <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure></p><p>运行后我们会发现，输出的结果依次是2 1 1，为什么会有这样的结果呢？</p><p>因为JavaScript中的函数是一等公民，<strong>函数声明的优先级最高，会被提升至当前作用域最顶端</strong>，所以第一次调用时实际执行了下面定义的函数声明，然后第二次调用时，由于前面的函数表达式与之前的函数声明同名，故将其覆盖，以后的调用也将会打印同样的结果。上面的过程经过预编译之后，代码逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预编译之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(); <span class="comment">// 1</span></span><br><span class="line">    foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br></pre></td></tr></table></figure><p>我们也不难理解，下面的函数和变量重名时，会如何执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line">    foo = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br><span class="line"><span class="built_in">console</span>.log(foo);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>我们可以看到，函数声明被提升至作用域最顶端，然后被赋值为5，而外层的变量并没有被覆盖，经过预编译之后，上面代码的逻辑是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预编译之后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line">   foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(foo); <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line">   </span><br><span class="line">   foo = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistFunction();</span><br><span class="line"><span class="built_in">console</span>.log(foo);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>所以，函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行，这一点要牢记。</p><h2 id="为什么要进行提升"><a href="#为什么要进行提升" class="headerlink" title="为什么要进行提升"></a>为什么要进行提升</h2><p><a href="http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/" target="_blank" rel="noopener">Dmitry Soshnikov之前的一篇文章</a></p><p>大致的意思就是：由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将变量名绑定到了栈槽内的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）</p><p>然后，Dmitry Soshnikov又提到了函数提升，他提到了相互递归（就是A函数内会调用到B函数，而B函数也会调用到A函数）：</p><p>Brendan Eich很确定的说，函数提升就是为了解决相互递归的问题，大体上可以解决像ML语言这样自下而上的顺序问题。</p><p>这里简单阐述一下相互递归，下面两个函数分别在自己的函数体内调用了对方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证偶数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOdd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证奇数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEven(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有函数提升，而是按照自下而上的顺序，当isEven函数被调用时，isOdd函数还未声明，所以当isEven内部无法调用isOdd函数。所以Brendan Eich设计了函数提升这一形式，将函数提升至当前作用域的顶部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证偶数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOdd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证奇数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEven(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">2</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这样一来，问题就迎刃而解了。</p><p>最后，Brendan Eich还对变量提升和函数提升做了总结：<br>大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p><p>至此，关于变量提升和函数提升，相信大家已经明白其中的真相了。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>理解变量提升和函数提升可以使我们更了解这门语言，更好地驾驭它，但是在开发中，我们不应该使用这些技巧，而是要规范我们的代码，做到可读性和可维护性。</p><p>具体的做法是：无论变量还是函数，都必须先声明后使用。下面举了简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Scott'</span>;</span><br><span class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">guest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="string">'says hello to'</span>, guest);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> guest;</span><br><span class="line"><span class="keyword">var</span> guests = [<span class="string">'John'</span>, <span class="string">'Tom'</span>, <span class="string">'Jack'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; guests.length; i++) &#123;</span><br><span class="line">    guest = guests[i];</span><br><span class="line">    <span class="comment">// do something on guest</span></span><br><span class="line">    sayHello(guest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果对于新的项目，可以使用let、const替换var，会变得更可靠，可维护性更高：</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="noopener">http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html</a></p><p><a href="http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/" target="_blank" rel="noopener">http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/</a></p><p><a href="https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/" target="_blank" rel="noopener">https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/</a></p><p><a href="http://stackoverflow.com/questions/7506844/javascript-function-scoping-and-hoisting" target="_blank" rel="noopener">http://stackoverflow.com/questions/7506844/javascript-function-scoping-and-hoisting</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件队列</title>
      <link href="/2019/03/12/javascript-que/"/>
      <url>/2019/03/12/javascript-que/</url>
      
        <content type="html"><![CDATA[<h3 id="JS-事件循环机制"><a href="#JS-事件循环机制" class="headerlink" title="JS 事件循环机制"></a>JS 事件循环机制</h3><h4 id="JS单线程、异步、同步概念"><a href="#JS单线程、异步、同步概念" class="headerlink" title="JS单线程、异步、同步概念"></a>JS单线程、异步、同步概念</h4><p>单线程即任务是串行的，后一个任务需要等待前一个任务的执行，这就可能出现长时间的等待。但由于类似ajax网络请求、setTimeout时间延迟、DOM事件的用户交互等，这些任务并不消耗 CPU，是一种空等，资源浪费，<br>因此出现了异步。通过将任务交给相应的异步模块去处理，主线程的效率大大提升，可以并行的去处理其他的操作。当异步处理完成，主线程空闲时，主线程读取相应的callback，进行后续的操作，最大程度的利用CPU。<br>此时出现了同步执行和异步执行的概念，同步执行是主线程按照顺序，串行执行任务；异步执行就是cpu跳过等待，先处理后续的任务（CPU与网络模块、timer等并行进行任务）。由此产生了任务队列与事件循环，来协调主线程与异步模块之间的工作。</p><h4 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h4><p>step1：主线程读取JS代码，此时为同步环境，形成相应的堆和执行栈；<br>step2:  主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）;<br>step3:  异步进程处理完毕（Ajax返回、DOM事件处罚、Timer到等），将相应的异步任务推入任务队列；<br>step4: 主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）；<br>step5: 重复执行step2、3、4；称为事件循环。</p><p>执行的大意：<br>同步环境执行(step1) -&gt; 事件循环1(step4) -&gt; 事件循环2(step4的重复)…<br>其中的异步进程有：<br>a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中；<br>b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中；<br>c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>任务队列存在多个，同一任务队列内，按队列顺序被主线程取走；不同任务队列之间，存在着优先级，优先级高的优先获取（如用户I/O）；</p><ol><li>任务队列的类型<br>任务队列存在两种类型，一种为microtask queue，另一种为macrotask queue。<br>图中所列出的任务队列均为macrotask queue，而ES6 的 promise［ECMAScript标准］产生的任务队列为microtask queue。</li><li>两者的区别<br>microtask queue：唯一，整个事件循环当中，仅存在一个；执行为同步，同一个事件循环中的microtask会按队列顺序，串行执行完毕；<br>macrotask queue：不唯一，存在一定的优先级（用户I/O部分优先级更高）；异步执行，同一事件循环中，只执行一个。</li><li>更完整的事件循环流程<br>将microtask加入到JS运行机制流程中，则：<br>step1、2、3同上，<br>step4：主线程查询任务队列，执行microtask queue，将其按序执行，全部执行完毕；<br>step5：主线程查询任务队列，执行macrotask queue，取队首任务执行，执行完毕；<br>step6：重复step4、step5。</li></ol><p>microtask queue中的所有callback处在同一个事件循环中，而macrotask queue中的callback有自己的事件循环。</p><p>macro-task（<code>宏任务</code>）：包括整体script代码，setInterval，setTimeout<br>micro-task（<code>微任务</code>）：promise ，process.nexttrick（nodejs的内容）</p><p>简而言之：同步环境执行 -&gt; 事件循环1（microtask queue的All）-&gt; 事件循环2(macrotask queue中的一个) -&gt; 事件循环1（microtask queue的All）-&gt; 事件循环2(macrotask queue中的一个)…</p><p>利用microtask queue可以形成一个同步执行的环境，但如果Microtask queue太长，将导致Macrotask任务长时间执行不了，最终导致用户I/O无响应等，所以使用需慎重。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1, time = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line"></span><br><span class="line">setTimeout(macroCallback, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2, time = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3, time = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125;).then(microCallback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">macroCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4, time = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">microCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5, time = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合第二节与第三节的分析，此处的执行流程应为：<br>同步环境：1 -&gt; 2 -&gt; 3<br>事件循环1（microCallback）：5<br>事件循环2（macroCallback）：4</p><p>运行结果与预期一致，验证了在不同类型的任务队列中，microtask queue中的callball将优先执行。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中的事件冒泡</title>
      <link href="/2019/02/23/react-event/"/>
      <url>/2019/02/23/react-event/</url>
      
        <content type="html"><![CDATA[<h3 id="React点击空白部分隐藏弹出层；React阻止事件冒泡失效"><a href="#React点击空白部分隐藏弹出层；React阻止事件冒泡失效" class="headerlink" title="React点击空白部分隐藏弹出层；React阻止事件冒泡失效"></a>React点击空白部分隐藏弹出层；React阻止事件冒泡失效</h3><p>两个在React组件上绑定的事件，产生冲突后，使用e.stopPropagation()，阻止冒泡，即可防止事件冲突，毫无问题。</p><p>今天是踩了个React事件的坑，需求可以简化为：点击框体以外的部分则隐藏框体。最直接的想法，document上绑定个事件，设置控制显示隐藏的state为false，在框体上绑定个事件，阻止冒泡。这样点击框体内部就不会触发document上的事件。</p><p>等写完了，发现一个问题，无法阻止冒泡，一搜索，好家伙，好多人问e.stopPropagation()为什么无法阻止事件冒泡，但是鲜有靠谱的回答。我第一个想法是原生事件和React事件产生冲突。明显绑定原生事件是不符合React精神的，但我决定在探索真理的路上走下去了。</p><p>为了直观的调试，把需求转化为，点击框体内 alert（1）点击框体外 alert（2）。</p><p>在document上绑定 alert（2），框体上（框体为React组件，下同）绑定 alert（1），不做特殊处理，点击框体内，根据事件冒泡，先弹 1 再弹 2 。这一点符合预期。此时e.stopPropagation()无法阻止冒泡。</p><p>经过 Stack Overflow 解惑 e.nativeEvent.stopImmediatePropagation() 可以完美实现预期。</p><p><strong>下面进入探索环节，经查阅资料，得出以下结论：</strong></p><ol><li>React为了提高效率，把事件都委托给了document，所以 e.stopPropagation() 并非是不能阻止冒泡，而是等他阻止冒泡的时侯，事件已经传递给document了，没东西可阻止了。可以通过在document.body上绑定 alert（3），直观的了解这一点，3 是优先于 1 弹出的。</li><li>e.stopPropagation()不行，浏览器支持一个好东西，e.stopImmediatePropagation() 他不光阻止冒泡，还能阻止在当前事件触发元素上，触发其它事件。这样即使你都绑定到document上也阻止不了我了吧。</li><li>这样做还不行，React对原生事件封装，提供了很多好东西，但也省略了某些特性。e.stopImmediatePropagation() 就是被省略的部分，然而，他给了开口：e.nativeEvent ，从原生的事件对象里找到stopImmediatePropagation()，完活。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">document</span>.onclick=<span class="keyword">this</span>.two;</span><br><span class="line">    &#125;</span><br><span class="line">    one(e)&#123;</span><br><span class="line">        e.nativeEvent.stopImmediatePropagation();</span><br><span class="line">        alert(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    two()&#123;</span><br><span class="line">        alert(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;height:150,width:150,backgroundColor:</span>"#<span class="attr">000</span>"&#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;this.one&#125;/</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Test</span>/&gt;</span>,</span></span><br><span class="line"><span class="xml">    document.getElementById("test")</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure><h3 id="React编写input组件传参共用onChange"><a href="#React编写input组件传参共用onChange" class="headerlink" title="React编写input组件传参共用onChange"></a>React编写input组件传参共用onChange</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     valueChange = <span class="function">(<span class="params">name,e</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;[e.target.name]:  e.target.value&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*下面这种方式也可以</span></span><br><span class="line"><span class="comment">         var change = &#123;&#125;;</span></span><br><span class="line"><span class="comment">         change[e.target.name] = e.target.value;</span></span><br><span class="line"><span class="comment">         this.setState(change);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"all"</span>&gt;</span><br><span class="line">                &lt;Input placeholder=<span class="string">"请输入你的姓名"</span> name=<span class="string">"name"</span> valueChange=&#123;<span class="keyword">this</span>.valueChange&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">                &lt;Input placeholder=<span class="string">"请输入你的手机号"</span> name=<span class="string">"phone"</span> valueChange=&#123;<span class="keyword">this</span>.valueChange&#125;&gt; <span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">                &lt;Input placeholder=<span class="string">"请输入你的微信号"</span> name=<span class="string">"wechat"</span> valueChange=&#123;<span class="keyword">this</span>.valueChange&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">                &lt;Input placeholder=<span class="string">"请输入你的QQ号"</span> name=<span class="string">"qq"</span> valueChange=&#123;<span class="keyword">this</span>.valueChange&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">                &lt;div className=<span class="string">"rebtn"</span> onClick=&#123;<span class="keyword">this</span>.submit&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件委托捕获冒泡</title>
      <link href="/2019/02/14/javascript-event/"/>
      <url>/2019/02/14/javascript-event/</url>
      
        <content type="html"><![CDATA[<h3 id="关于事件机制"><a href="#关于事件机制" class="headerlink" title="关于事件机制"></a>关于事件机制</h3><p>DOM事件流（event  flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。<br><strong>事件捕获</strong>（event  capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><p><strong>事件冒泡</strong>（dubbed  bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。</p><h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p><p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。</p><h3 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h3><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="/2019/02/14/prototype/"/>
      <url>/2019/02/14/prototype/</url>
      
        <content type="html"><![CDATA[<p>普通对象 Object 和 函数对象 Function。<br>一般而言，通过 new Function 产生的对象是函数对象，其他对象都是普通对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,  <span class="string">'console.log(x)'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    <span class="keyword">typeof</span> f1,</span><br><span class="line">    <span class="keyword">typeof</span> f2,</span><br><span class="line">    <span class="keyword">typeof</span> f3,</span><br><span class="line">    <span class="keyword">typeof</span> o1,</span><br><span class="line">    <span class="keyword">typeof</span> o2,</span><br><span class="line">    <span class="keyword">typeof</span> o3</span><br><span class="line">);</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">function</span> <span class="title">function</span> <span class="title">object</span> <span class="title">object</span> <span class="title">object</span></span></span><br></pre></td></tr></table></figure></p><p>f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。<br>Function 是JS自带的对象，f1，f2 在创建的时候，JS会自动通过 new Function() 的方式来构建这些对象，因此，这三个对象都是通过 new Function() 创建的。<br>在 Javascript 中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然…<br>怎么理解呢? 很简单，看 o3 是不是通过 new Function 产生的，显然不是，既然不是函数对象，那就是<strong>普通对象</strong>。</p><p>在 JS 中，每当创建一个函数对象 f1 时，该对象中都会内置一些属性，其中包括 prototype 和 __proto__， prototype 即原型对象，它记录着f1的一些属性和方法。</p><p>需要注意的是，prototype 对 f1 是不可见的，也就是说，f1 不会查找 prototype 中的属性和方法。 </p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>原型链的形成真正是靠<strong>proto</strong> 而非prototype，当JS引擎执行对象的方法时，先查找对象本身是否存在该方法，如果不存在，会在原型链上查找，但不会查找自身的prototype。</li><li>一个对象的 __proto__ 记录着自己的原型链，决定了自身的数据类型，改变 __proto__ 就等于改变对象的数据类型。</li><li>函数的 prototype 不属于自身的原型链，它是创建子类的核心，决定了子类的数据类型，是连接子类原型链的桥梁。</li><li>在原型对象上定义方法和属性，是为了被子类继承和使用。</li></ul><p><img src="/images/prototype.jpg" alt="图解"></p><h2 id="new的时候干了什么"><a href="#new的时候干了什么" class="headerlink" title="new的时候干了什么"></a>new的时候干了什么</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.color = <span class="string">"black"</span>;</span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Animal(<span class="string">"cat"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    cat.name,  <span class="comment">//cat</span></span><br><span class="line">    cat.height <span class="comment">//undefined</span></span><br><span class="line">);</span><br><span class="line">cat.say(); <span class="comment">//I'm cat</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    Animal.name, <span class="comment">//Animal</span></span><br><span class="line">    Animal.color <span class="comment">//back</span></span><br><span class="line">);</span><br><span class="line">Animal.say(); <span class="comment">//Animal.say is not a function</span></span><br></pre></td></tr></table></figure><p>关键 <code>var cat = new Animal(&quot;cat&quot;);</code><br>JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj, <span class="string">'cat'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.创建一个空对象obj;</p><p>2.把obj的<strong>proto</strong> 指向Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</p><p>3.在obj对象的执行环境调用Animal函数并传递参数“cat”。 相当于var result = obj.Animal(“cat”)。<br>当这句执行完之后，obj便产生了属性name并赋值为”cat”。</p><p>4.考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 士兵(<span class="params">ID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> 临时对象 = &#123;&#125;  <span class="comment">//创建临时对象</span></span><br><span class="line">  临时对象.__proto__ = 士兵.原型   <span class="comment">//绑定原型</span></span><br><span class="line">  临时对象.ID = ID  </span><br><span class="line">  临时对象.生命值 = <span class="number">42</span></span><br><span class="line">  <span class="keyword">return</span> 临时对象  <span class="comment">//return出对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">士兵.原型 = &#123;</span><br><span class="line">  兵种:<span class="string">"美国大兵"</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*走俩步的代码*/</span>&#125;，</span><br><span class="line">  奔跑:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> 士兵们 = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">  士兵们.push(士兵(i))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure><p>1.不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>2.不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>3.不用 return 临时对象，因为 new 会帮你做；<br>4.不要给原型想名字了，因为 new 指定名字为 prototype。</p><h2 id="构造函数的执行过程"><a href="#构造函数的执行过程" class="headerlink" title="构造函数的执行过程"></a>构造函数的执行过程</h2><p>当一个函数创建好以后，我们并不知道它是不是构造函数，函数名为大写，我们也不能确定。只有当一个函数以 new 关键字来调用的时候，我们才能说它是一个构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">"black"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender, hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'zs'</span>, <span class="string">'男'</span>, <span class="string">'basketball'</span>);</span><br></pre></td></tr></table></figure></p><p>我们还是以上面的 Person 为例。此时，构造函数会有以下几个执行过程：</p><ol><li>当以 <code>new</code> 关键字调用时，会创建一个新的内存空间，标记为 <code>Person</code> 的实例。</li><li>函数体内部的 <code>this</code> 指向该内存<br>通过以上两步，我们就可以得出这样的结论。<br>每当创建一个实例的时候，就会创建一个新的内存空间(#f2, #f3)，创建 #f2 的时候，函数体内部的 this 指向 #f2, 创建 #f3 的时候，函数体内部的 this 指向 #f3。</li><li>执行函数体内的代码<br>通过上面的讲解，你就可以知道，给 this 添加属性，就相当于给实例添加属性。</li><li>默认返回 this 。<br>由于函数体内部的 <code>this</code> 指向新创建的内存空间，默认返回 <code>this</code> ，就相当于默认返回了该内存空间，也就是上图中的 #f1。此时，#f1的内存空间被变量 p1 所接受。也就是说 p1 这个变量，保存的内存地址就是 #f1，同时被标记为 <code>Person</code> 的实例。</li></ol><p>以上就是构造函数的整个执行过程。</p><h2 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h2><p>构造函数执行过程的最后一步是默认返回 this 。言外之意，构造函数的返回值还有其它情况。下面我们就来聊聊关于构造函数返回值的问题。<br>(1) 没有手动添加返回值，默认返回 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'zhangsan'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person1();</span><br></pre></td></tr></table></figure></p><p>当用 <code>new</code> 关键字调用时，产生一个新的内存空间 #f11，并标记为 <code>Person1</code> 的实例；接着，函数体内部的 <code>this</code> 指向该内存空间 #f11；执行函数体内部的代码；由于函数体内部的 <code>this</code> 指向该内存空间，而该内存空间又被变量 p1 所接收，所以 p1 中就会有一个 name 属性，属性值为 ‘zhangsan’。</p><p>(2) 手动添加一个基本数据类型的返回值，最终还是返回 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">28</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person2();</span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p>(3) 手动添加一个复杂数据类型(对象)的返回值，最终返回该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = <span class="string">'180'</span>;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Person3();</span><br><span class="line"><span class="built_in">console</span>.log(p3.height);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.length);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(p3[<span class="number">0</span>]);      <span class="comment">// 'a'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.gender = <span class="string">'男'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">gender</span>: <span class="string">'中性'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> Person4();</span><br><span class="line"><span class="built_in">console</span>.log(p4.gender);  <span class="comment">// '中性'</span></span><br></pre></td></tr></table></figure><p>可以看出：在JavaScript构造函数中：如果return值类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型；</p><h2 id="这一次我们用-new-来写"><a href="#这一次我们用-new-来写" class="headerlink" title="这一次我们用 new 来写"></a>这一次我们用 new 来写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 士兵(<span class="params">ID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ID = ID</span><br><span class="line">  <span class="keyword">this</span>.生命值 = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">士兵.prototype = &#123;</span><br><span class="line">  兵种:<span class="string">"美国大兵"</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*走俩步的代码*/</span>&#125;,</span><br><span class="line">  奔跑:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 士兵们 = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">  士兵们.push(<span class="keyword">new</span> 士兵(i))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure><h3 id="注意-constructor-属性"><a href="#注意-constructor-属性" class="headerlink" title="注意 constructor 属性"></a>注意 constructor 属性</h3><p>new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">士兵.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: 士兵</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">士兵.prototype.兵种 = <span class="string">"美国大兵"</span></span><br><span class="line">士兵.prototype.攻击力 = <span class="number">5</span></span><br><span class="line">士兵.prototype.行走 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">士兵.prototype.奔跑 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  &#125;</span><br><span class="line">士兵.prototype.死亡 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在javascript中, 通过new可以产生原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法。因此，new存在的意义在于它实现了javascript中的继承，而不仅仅是实例化了一个对象！</p><h2 id="关于Object-prototype-constructor"><a href="#关于Object-prototype-constructor" class="headerlink" title="关于Object.prototype.constructor"></a>关于Object.prototype.constructor</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">mozilla</a>上的描述：返回创建实例对象的 Object 构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如1，true和”test”，该值只可读。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor === Foo);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>但是可能出于不理解，或者很多的误操作，都会导致我们.constructor指向的丢失。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;&#125; <span class="comment">// 重新对prototype赋值，constructor就没了</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(a1.constructor === Foo);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.constructor === <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Foo.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writeable:<span class="literal">true</span>,</span><br><span class="line">    configureable: <span class="literal">true</span>,</span><br><span class="line">    value: Foo <span class="comment">// 让.constructor指向Foo</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="改变constructor"><a href="#改变constructor" class="headerlink" title="改变constructor"></a>改变constructor</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentWithStatic</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">ParentWithStatic.startPosition = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span> &#125;;</span><br><span class="line">ParentWithStatic.getStartPosition = <span class="function"><span class="keyword">function</span> <span class="title">getStartPosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.startPosition;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.position = &#123;</span><br><span class="line">    x: x,</span><br><span class="line">    y: y</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(ParentWithStatic.prototype); </span><br><span class="line">Child.prototype.constructor = Child; <span class="comment">//在这里如果不指向回Child，就会在创建的时候指向ParentWithStatic, 下面的引用就会报错</span></span><br><span class="line"></span><br><span class="line">Child.prototype.getOffsetByInitialPosition = <span class="function"><span class="keyword">function</span> <span class="title">getOffsetByInitialPosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> position = <span class="keyword">this</span>.position;</span><br><span class="line">  <span class="keyword">var</span> startPosition = <span class="keyword">this</span>.constructor.getStartPosition(); <span class="comment">// error undefined is not a function, since the constructor is Child</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    offsetX: startPosition.x - position.x,</span><br><span class="line">    offsetY: startPosition.y - position.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于为什么要做<code>Child.prototype.constructor = Child</code>这样的修正？<br>可以参考<a href="https://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property/4013295#4013141" target="_blank" rel="noopener">这里</a></p><p>所以，即使不做这样的修正也不会有什么影响，它主要防止一种情况下出错，就是你显式地去使用构造函数。比如，我并不知道woman是由哪个函数实例化出来的，但是我想clone一个，这时就可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Woman();</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> woman1 = woman.constructor();</span><br></pre></td></tr></table></figure><h2 id="关于Object-create和new区别"><a href="#关于Object-create和new区别" class="headerlink" title="关于Object.create和new区别"></a>关于Object.create和new区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Base = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(Base);</span><br><span class="line"><span class="built_in">console</span>.log(o1)  <span class="comment">//Base &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2)  <span class="comment">//Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建函数</span></span><br><span class="line"><span class="built_in">Object</span>.create =  <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new 做了什么</span></span><br><span class="line">JavaScript 实际上执行的是：</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o1.__proto__ = Base.prototype;</span><br><span class="line">Base.call(o1);</span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 以字面量方式创建的空对象就相当于:</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>为什么通过Object.create构造的连Base原型上的属性都访问不到，因为他压根就没有指向他的prototype。这也就说明了__proto__ 和 prototype 的区别。所以上面在prototype定义的a，只是Base的 prototype对象上的一个属性。</p><p>再来看看就是：<br>1.new关键字必须是以function定义的。<br>2.Object.create 则 function和object都可以进行构建</p><table><thead><tr><th>比较</th><th>new</th><th>Object.create</th></tr></thead><tbody><tr><td>构造函数</td><td>保留原构造函数属性</td><td>丢失原构造函数属性</td></tr><tr><td>原型链</td><td>原构造函数prototype属性</td><td>原构造函数/（对象）本身</td></tr><tr><td>作用对象</td><td>function</td><td>function和object</td></tr></tbody></table><h2 id="proto-和prototype的区别"><a href="#proto-和prototype的区别" class="headerlink" title="__proto__和prototype的区别"></a><code>__proto__</code>和prototype的区别</h2><p><code>__proto__</code>（隐式原型）与<code>prototype</code>（显式原型）</p><h3 id="分别是什么"><a href="#分别是什么" class="headerlink" title="分别是什么"></a>分别是什么</h3><p>显式原型 explicit prototype property:<br>每一个函数在创建之后都会拥有一个名为<code>prototype</code>的属性，这个属性指向函数的原型对象<br><strong>注意：</strong> ECMAScript5中的Function.bind()方法返回的对象除外</p><p>隐式原型 implicit prototype link：<br>JavaScript中任意对象都有一个内置属性<code>[[prototype]]</code>，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。ES5中有了对于这个内置属性标准的Get方法<code>Object.getPrototypeOf()</code>.</p><p>二者的关系: 隐式原型指向创建这个对象的函数(constructor)的prototype</p><h3 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h3><p>显式原型的作用：用来实现基于原型的继承与属性的共享。</p><blockquote><p>ECMAScript does not use classes such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via constructors which create objects and then execute code that initialises all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named “prototype” that is used to implement prototype-based inheritance and shared properties.Objects are created by using constructors in new expressions; for example, new Date(2009,11) creates a new Date object. —-<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.1" target="_blank" rel="noopener">ECMAScript Language Specification</a></p></blockquote><p>隐式原型的作用：构成原型链，指向创建这个对象的函数的显式原型，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<code>__proto__</code>依次查找。</p><blockquote><p>Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “prototype” —-<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.1" target="_blank" rel="noopener">ECMAScript Language Specification</a></p></blockquote><p><code>__proto__</code>是每个对象都有的一个属性，而<code>prototype</code>是函数才会有的属性<br><code>__proto__</code>指向的是当前对象的原型对象，而<code>prototype</code>指向的，是以当前函数作为构造函数构造出来的对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GirlFriend</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Alice"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GirlFriend.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 对象都是由object创建</span></span><br><span class="line">GirlFriend.prototype.constructor === GirlFriend  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> GirlFriend();</span><br><span class="line">myObject.__proto__ === GirlFriend.prototype</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/01/hello-world/"/>
      <url>/2019/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
