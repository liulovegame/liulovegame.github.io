<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>博客 | 简而不单</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/live2d.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">博客</h1><a id="logo" href="/.">博客</a><p class="description">简而不单</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2019/09/22/note-page/">资料查阅</a></h1><div class="post-meta">2019-09-22</div><div class="post-content"><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="react-fiber"><a href="#react-fiber" class="headerlink" title="react-fiber"></a>react-fiber</h3><p><a href="https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">React技术揭秘</a><br><a href="https://juejin.im/post/6859528127010471949" target="_blank" rel="noopener">React Fiber 源码解析</a><br><a href="https://zhuanlan.zhihu.com/p/77579841" target="_blank" rel="noopener">浅谈React Fiber</a><br><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">[译]深入React fiber架构及源码</a><br><a href="https://juejin.im/post/6847902224287285255" target="_blank" rel="noopener">componentWillXXX为什么UNSAFE</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">如何实现一个 Virtual DOM 算法</a></p></div><p class="readmore"><a href="/2019/09/22/note-page/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/07/25/http/">http 1.0、1.1、2.0的区别详解</a></h1><div class="post-meta">2019-07-25</div><div class="post-content"><h3 id="1-http-1-0"><a href="#1-http-1-0" class="headerlink" title="1.http 1.0"></a>1.http 1.0</h3><h4 id="1-1-链接无法复用，即不支持持久链接："><a href="#1-1-链接无法复用，即不支持持久链接：" class="headerlink" title="1.1 链接无法复用，即不支持持久链接："></a>1.1 链接无法复用，即不支持持久链接：</h4><p>http 1.0 规定浏览器与服务器保持较短时间的链接，浏览器每次请求都和服务器经过三次握手和慢启动（基本思想是当TCP开始传输数据或发现数据丢失并开始重发时，首先慢慢的对网路实际容量进行试探，避免由于发送了过量的数据而导致阻塞）建立一个TCP链接，服务器完成请求处理后立即断开TCP链接，而且不跟踪每个浏览器的历史请求。<br>注意：由于http 1.0每次建立TCP链接对性能的影响实在是太大，http1.1实现持久化链接之后，又反向移植到http 1.0上，只是默认是没有开启持久链接的，通过http的header部分的 Connection: KeepAlive 来启用）</p></div><p class="readmore"><a href="/2019/07/25/http/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/07/24/async-await/">async和await使用</a></h1><div class="post-meta">2019-07-24</div><div class="post-content"><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>函数前面的async一词意味着一个简单的事情：这个函数总是返回一个promise，如果代码中有return &lt;非promise&gt;语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。</p></div><p class="readmore"><a href="/2019/07/24/async-await/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/07/15/css-sroll/">CSS3自定义滚动条样式</a></h1><div class="post-meta">2019-07-15</div><div class="post-content"><h3 id="自定义滚动条实现"><a href="#自定义滚动条实现" class="headerlink" title="自定义滚动条实现"></a>自定义滚动条实现</h3><p>此部分针对webkit内核的浏览器，使用伪类来改变滚动条的默认样式，详情如下：</p>
<h3 id="滚动条组成部分"><a href="#滚动条组成部分" class="headerlink" title="滚动条组成部分"></a>滚动条组成部分</h3><ol></ol></div><p class="readmore"><a href="/2019/07/15/css-sroll/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/05/27/js-clone-cloneDeep/">js 深浅拷贝</a></h1><div class="post-meta">2019-05-27</div><div class="post-content"><p>基本数据类型：String，Boolean，Number，Undefined，Null；<br>引用数据类型：Object(Array，Date，RegExp，Function)；</p>
<p>基本数据类型和引用数据类型的区别：</p>
<ol>
<li><p>保存位置不同：基本数据类型保存在栈内存中，引用数据类型保存在堆内存中，然后在栈内存中保存了一个对堆内存中实际对象的引用，即数据在堆内存中的地址，JS对引用数据类型的操作都是操作对象的引用而不是实际的对象，如果obj1拷贝了obj2，那么这两个引用数据类型就指向了同一个堆内存对象，具体操作是obj1将栈内存的引用地址复制了一份给obj2，因而它们共同指向了一个堆内存对象；<br>为什么基本数据类型保存在栈中，而引用数据类型保存在堆中？</p></li></ol></div><p class="readmore"><a href="/2019/05/27/js-clone-cloneDeep/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/05/25/Object-create-new-object/">Object.create和new object</a></h1><div class="post-meta">2019-05-25</div><div class="post-content"><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a><code>Object.create</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.create(proto, propertiesObject)</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2019/05/25/Object-create-new-object/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/04/11/function-scoping-and-hoisting/">变量提升和函数提升</a></h1><div class="post-meta">2019-04-11</div><div class="post-content"><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。(注：当前流行的JS引擎大都对源码进行了编译，由于引擎的不同，编译形式也会有所差异，我们这里说的预编译和提升其实是抽象出来的、易于理解的概念)<br>下面的代码中，我们在函数中声明了一个变量，不过这个变量声明是在if语句块中：</p></div><p class="readmore"><a href="/2019/04/11/function-scoping-and-hoisting/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/03/12/javascript-que/">js事件队列</a></h1><div class="post-meta">2019-03-12</div><div class="post-content"><h3 id="JS-事件循环机制"><a href="#JS-事件循环机制" class="headerlink" title="JS 事件循环机制"></a>JS 事件循环机制</h3><h4 id="JS单线程、异步、同步概念"><a href="#JS单线程、异步、同步概念" class="headerlink" title="JS单线程、异步、同步概念"></a>JS单线程、异步、同步概念</h4><p>单线程即任务是串行的，后一个任务需要等待前一个任务的执行，这就可能出现长时间的等待。但由于类似ajax网络请求、setTimeout时间延迟、DOM事件的用户交互等，这些任务并不消耗 CPU，是一种空等，资源浪费，<br>因此出现了异步。通过将任务交给相应的异步模块去处理，主线程的效率大大提升，可以并行的去处理其他的操作。当异步处理完成，主线程空闲时，主线程读取相应的callback，进行后续的操作，最大程度的利用CPU。<br>此时出现了同步执行和异步执行的概念，同步执行是主线程按照顺序，串行执行任务；异步执行就是cpu跳过等待，先处理后续的任务（CPU与网络模块、timer等并行进行任务）。由此产生了任务队列与事件循环，来协调主线程与异步模块之间的工作。</p></div><p class="readmore"><a href="/2019/03/12/javascript-que/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/02/23/react-event/">react中的事件冒泡</a></h1><div class="post-meta">2019-02-23</div><div class="post-content"><h3 id="React点击空白部分隐藏弹出层；React阻止事件冒泡失效"><a href="#React点击空白部分隐藏弹出层；React阻止事件冒泡失效" class="headerlink" title="React点击空白部分隐藏弹出层；React阻止事件冒泡失效"></a>React点击空白部分隐藏弹出层；React阻止事件冒泡失效</h3><p>两个在React组件上绑定的事件，产生冲突后，使用e.stopPropagation()，阻止冒泡，即可防止事件冲突，毫无问题。</p></div><p class="readmore"><a href="/2019/02/23/react-event/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2019/02/14/javascript-event/">事件委托捕获冒泡</a></h1><div class="post-meta">2019-02-14</div><div class="post-content"><h3 id="关于事件机制"><a href="#关于事件机制" class="headerlink" title="关于事件机制"></a>关于事件机制</h3><p>DOM事件流（event  flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。<br><strong>事件捕获</strong>（event  capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。</p></div><p class="readmore"><a href="/2019/02/14/javascript-event/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/categories/">categories</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/IM/" style="font-size: 15px;">IM</a> <a href="/tags/WebRTC/" style="font-size: 15px;">WebRTC</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/console/" style="font-size: 15px;">console</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/web3/" style="font-size: 15px;">web3</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/资料/" style="font-size: 15px;">资料</a> <a href="/tags/cavnas/" style="font-size: 15px;">cavnas</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/题库/" style="font-size: 15px;">题库</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/html/" style="font-size: 15px;">html</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/08/27/eip-712/">了解 EIP712</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/16/truffle-use/">Truffle的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/30/nextjs-and-cms/">Nextjs + Tailwind css + Strapi CMS 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/24/date-timezone/">将 JavaScript 日期初始化为特定时区</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/30/directory-structure/">项目目录结构推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/input-blur/">input 失去焦点重复校验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/tampermonkey/">油猴脚本教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/auto-jump-history/">页面加载时使用脚本自动跳转到新页面浏览器不会产生历史记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/flex-finally-width/">关于flex布局的最后一行元素宽度问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/ unicode/">Unicode编码和解码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://translate.google.cn/#en/zh-CN" title="谷歌翻译" target="_blank">谷歌翻译</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><div id="landlord"><div class="message"></div><canvas class="live2d" id="live2d" width="280" height="250"></canvas></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="//lib.baomitu.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/contextMenu.js?v=0.0.0"></script><script type="text/javascript" src="/js/live2d.js?v=0.0.0"></script><script type="text/javascript" src="/js/message.js?v=0.0.0"></script></div></body></html>