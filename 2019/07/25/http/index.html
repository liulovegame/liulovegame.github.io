<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>http 1.0、1.1、2.0的区别详解 | 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/live2d.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">http 1.0、1.1、2.0的区别详解</h1><a id="logo" href="/.">博客</a><p class="description">简而不单</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">http 1.0、1.1、2.0的区别详解</h1><div class="post-meta">Jul 25, 2019<span> | </span><span class="category"><a href="/categories/categories/">categories</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-http-1-0"><span class="toc-number">1.</span> <span class="toc-text">1.http 1.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-链接无法复用，即不支持持久链接："><span class="toc-number">1.1.</span> <span class="toc-text">1.1 链接无法复用，即不支持持久链接：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-线头阻塞（Head-of-Line-HOL-Blocking）"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 线头阻塞（Head of Line (HOL) Blocking）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-http-1-1"><span class="toc-number">2.</span> <span class="toc-text">2.http 1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-支持http管道"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 支持http管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-使用多个TCP链接"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 使用多个TCP链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-http-1-1-增加了请求头和响应头来扩充功能"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 http 1.1 增加了请求头和响应头来扩充功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-域名分区"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 域名分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-http的header的优化"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 http的header的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-减少连接次数"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 减少连接次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-嵌入小的文件"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 嵌入小的文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-http-2-0"><span class="toc-number">3.</span> <span class="toc-text">3. http 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-支持多路复用"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 支持多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-将通信的基本单位缩小为帧"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 将通信的基本单位缩小为帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-首部压缩"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 首部压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-服务端推送"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 服务端推送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-请求优先级"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 请求优先级</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="1-http-1-0"><a href="#1-http-1-0" class="headerlink" title="1.http 1.0"></a>1.http 1.0</h3><h4 id="1-1-链接无法复用，即不支持持久链接："><a href="#1-1-链接无法复用，即不支持持久链接：" class="headerlink" title="1.1 链接无法复用，即不支持持久链接："></a>1.1 链接无法复用，即不支持持久链接：</h4><p>http 1.0 规定浏览器与服务器保持较短时间的链接，浏览器每次请求都和服务器经过三次握手和慢启动（基本思想是当TCP开始传输数据或发现数据丢失并开始重发时，首先慢慢的对网路实际容量进行试探，避免由于发送了过量的数据而导致阻塞）建立一个TCP链接，服务器完成请求处理后立即断开TCP链接，而且不跟踪每个浏览器的历史请求。<br>注意：由于http 1.0每次建立TCP链接对性能的影响实在是太大，http1.1实现持久化链接之后，又反向移植到http 1.0上，只是默认是没有开启持久链接的，通过http的header部分的 Connection: KeepAlive 来启用）</p>
<h4 id="1-2-线头阻塞（Head-of-Line-HOL-Blocking）"><a href="#1-2-线头阻塞（Head-of-Line-HOL-Blocking）" class="headerlink" title="1.2 线头阻塞（Head of Line (HOL) Blocking）"></a>1.2 线头阻塞（Head of Line (HOL) Blocking）</h4><p>请求队列的第一个请求因为服务器正忙（或请求格式问题等其他原因），导致后面的请求被阻塞。</p>
<h3 id="2-http-1-1"><a href="#2-http-1-1" class="headerlink" title="2.http 1.1"></a>2.http 1.1</h3><h4 id="2-1-支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）"><a href="#2-1-支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）" class="headerlink" title="2.1 支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）"></a>2.1 支持持久链接（在request和response中的header中的connection是close或者Keep-Alive进行控制）</h4><p>一个TCP链接可以传送多个http请求和相应，减少了TCP建立链接和关闭链接的消耗。另外http1.1允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能 够区分出每次请求的响应内容。</p>
<h4 id="2-2-支持http管道"><a href="#2-2-支持http管道" class="headerlink" title="2.2 支持http管道"></a>2.2 支持http管道</h4><p>不使用管道的http请求，在使用持久链接时，必须严格满足先进先出的队列顺序（FIFO），即发送请求，等待响应完成，再发送客户端队列中的下一个请求。管道可以让我们把 FIFO 队列从客户端（请求队列）迁移到服务器（响应队列），即客户端可以并行，服务端串行。客户端可以不用等待前一个请求返回，发送请求，但服务器端必须顺序的返回客户端的请求响应结果。<br>缺点：<br>a. 一个请求响应阻塞，就会阻塞后续所有请求<br>b. 并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面；<br>c. 响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，导致重复处理；<br>d. 由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要；<br>e. 如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来</p>
<h4 id="2-3-使用多个TCP链接"><a href="#2-3-使用多个TCP链接" class="headerlink" title="2.3 使用多个TCP链接"></a>2.3 使用多个TCP链接</h4><p>http1.1 在客户端排队所有请求，然后通过一个TCP持久链接，一个接一个的发送请求（如果有http管道还必须顺序等待服务端的顺序返回结果）。但实际中，浏览器的开发时不会这么笨，浏览器允许我们打开N个TCP链接（大多说浏览器是6个TCP链接，这个数字越大，客户端和服务器的资源占用越多，这个数据也只是感觉安全的数字而已）。</p>
<p>2.3.1 带来的好处：<br>1.客户端可以并行发送最多 N个请求；<br>2.服务器可以并行处理最多 N个请求；<br>3.第一次往返可以发送的累计分组数量（TCP cwnd）增长为原来的 N 倍。</p>
<p>2.3.2 代价：<br>1.更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU时钟周期；<br>2.并行 TCP 流之间竞争共享的带宽；<br>3.由于处理多个套接字，实现复杂性更高；<br>4.即使并行 TCP 流，应用的并行能力也受限制。<br>因此使用多个TCP链接只是权宜之计，后续的http 2.0支持多路复用，很好的解决了上述问题。</p>
<h4 id="2-4-http-1-1-增加了请求头和响应头来扩充功能"><a href="#2-4-http-1-1-增加了请求头和响应头来扩充功能" class="headerlink" title="2.4 http 1.1 增加了请求头和响应头来扩充功能"></a>2.4 http 1.1 增加了请求头和响应头来扩充功能</h4><p>举例：<br>a. 支持Host请求：<br>b. Connection: 请求头的值为Connection时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close 时，客户端通知服务器返回本次请求结果后关闭连接<br>c. 支持断点续传:<br>d.身份认证：<br>e.状态管理:<br>f. 缓存处理：</p>
<h4 id="2-5-域名分区"><a href="#2-5-域名分区" class="headerlink" title="2.5 域名分区"></a>2.5 域名分区</h4><p>域名分区是思想是将原来集中到一个服务器上的资源分布到多个服务器上，这样就可以突破浏览器的链接限制（一般是6个），提高并行能力。<br>代价：<br>1.每多一台主机都要多一次的 DNS 查询，每多一个套接字都会多消耗两端的一些资源；<br>2.必须手工分离一台主机上的资源到多台；.<br>实际实践中，效果并不是很明显，反而导致被滥用。</p>
<h4 id="2-6-http的header的优化"><a href="#2-6-http的header的优化" class="headerlink" title="2.6 http的header的优化"></a>2.6 http的header的优化</h4><p>目前所有的header请求都是以没有经过压缩的纯文本的形式发送（通常会有600`1000字节），而通常使用的http请求body却很少（10~200字节），和header相比，显得很少，特别是在使用了cookie之后，这样的矛盾就更加突出，因此要减少header的数据。</p>
<h4 id="2-7-减少连接次数"><a href="#2-7-减少连接次数" class="headerlink" title="2.7 减少连接次数"></a>2.7 减少连接次数</h4><p>即将需要多次才能获取的文件或资源组合并成一个，通过一次网络请求获取。这样减少了协议的开销，间接地将服务器端的管道思维移植到了客户端。缺点：增加复杂性，更缓存带来负担，页面的分步显示，改成一次显示，在网络慢的时候影响用户体验。</p>
<h4 id="2-8-嵌入小的文件"><a href="#2-8-嵌入小的文件" class="headerlink" title="2.8 嵌入小的文件"></a>2.8 嵌入小的文件</h4><p>即将资源嵌入文档（通过URI嵌入图片，音频或PDF），可以减少请求次数。嵌入资源作为页面的返回一部分一次返回，即如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小，如果嵌入资源被更新，客户端只能重新获取有效的资源。<br>实践：一般只考虑嵌入1~2KB一下的资源</p>
<p>参照建议：<br>1.如果文件很小，而且只有个别页面使用，可以考虑嵌入；<br>2.如果文件很小，但需要在多个页面中重用，应该考虑集中打包；<br>3.如果小文件经常需要更新，就不要嵌入了；<br>4.通过减少 HTTP cookie 的大小将协议开销最小化</p>
<h3 id="3-http-2-0"><a href="#3-http-2-0" class="headerlink" title="3. http 2.0"></a>3. http 2.0</h3><p>HTTP 2.0把解决性能问题的方案内置在了传输层，通过多路复用来减少延迟，通过压缩 HTTP首部降低开销，同时增加请求优先级和服务器端推送的功能。</p>
<h4 id="3-1-支持多路复用"><a href="#3-1-支持多路复用" class="headerlink" title="3.1 支持多路复用"></a>3.1 支持多路复用</h4><p>多路复用允许同时通过单一的 HTTP 2.0 连接发起多重的请求-响应消息，即所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可，所有数据流共用同一个连接 ，减少了因http链接多而引起的网络拥塞（在 HTTP1.1 协议中，同一时间，浏览器会针对同一域名下的请求有一定数量限制），解决了慢启动针对突发性和短时性的http链接低效的问题。</p>
<h4 id="3-2-将通信的基本单位缩小为帧"><a href="#3-2-将通信的基本单位缩小为帧" class="headerlink" title="3.2 将通信的基本单位缩小为帧"></a>3.2 将通信的基本单位缩小为帧</h4><p>即应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层，因此在多向请求和响应时，客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来，解决了http 1.*的对手阻塞问题。</p>
<h4 id="3-3-首部压缩"><a href="#3-3-首部压缩" class="headerlink" title="3.3 首部压缩"></a>3.3 首部压缩</h4><p>http 2.0支持DEFLATE和HPACK 算法的压缩。</p>
<h4 id="3-4-服务端推送"><a href="#3-4-服务端推送" class="headerlink" title="3.4 服务端推送"></a>3.4 服务端推送</h4><p>指客户端请求之前发送数据的机制，在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应。</p>
<h4 id="3-5-请求优先级"><a href="#3-5-请求优先级" class="headerlink" title="3.5 请求优先级"></a>3.5 请求优先级</h4><p>HTTP 2.0 使用一个31比特的优先值,0表示最高优先级, 2(31)-1表示最低优<br>先级，服务器端就可以根据优先级，控制资源分配，优先处理和返回最高优先级的请求帧给客户端。</p>
<p>作者：zhglance<br>链接：<a href="https://www.jianshu.com/p/ac628fda40f2" target="_blank" rel="noopener">https://www.jianshu.com/p/ac628fda40f2</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
</div><div class="tags"><a href="/tags/http/">http</a></div><div class="post-nav"><a class="pre" href="/2019/09/22/note-page/">资料查阅</a><a class="next" href="/2019/07/24/async-await/">async和await使用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/categories/">categories</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/IM/" style="font-size: 15px;">IM</a> <a href="/tags/WebRTC/" style="font-size: 15px;">WebRTC</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/console/" style="font-size: 15px;">console</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/web3/" style="font-size: 15px;">web3</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/资料/" style="font-size: 15px;">资料</a> <a href="/tags/cavnas/" style="font-size: 15px;">cavnas</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/题库/" style="font-size: 15px;">题库</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/html/" style="font-size: 15px;">html</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/08/27/eip-712/">了解 EIP712</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/16/truffle-use/">Truffle的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/30/nextjs-and-cms/">Nextjs + Tailwind css + Strapi CMS 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/24/date-timezone/">将 JavaScript 日期初始化为特定时区</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/30/directory-structure/">项目目录结构推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/input-blur/">input 失去焦点重复校验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/tampermonkey/">油猴脚本教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/auto-jump-history/">页面加载时使用脚本自动跳转到新页面浏览器不会产生历史记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/flex-finally-width/">关于flex布局的最后一行元素宽度问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/ unicode/">Unicode编码和解码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://translate.google.cn/#en/zh-CN" title="谷歌翻译" target="_blank">谷歌翻译</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><div id="landlord"><div class="message"></div><canvas class="live2d" id="live2d" width="280" height="250"></canvas></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="//lib.baomitu.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/contextMenu.js?v=0.0.0"></script><script type="text/javascript" src="/js/live2d.js?v=0.0.0"></script><script type="text/javascript" src="/js/message.js?v=0.0.0"></script></div></body></html>