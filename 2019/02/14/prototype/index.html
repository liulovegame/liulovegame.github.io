<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>原型链 | 博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/live2d.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">原型链</h1><a id="logo" href="/.">博客</a><p class="description">简而不单</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">原型链</h1><div class="post-meta">Feb 14, 2019<span> | </span><span class="category"><a href="/categories/categories/">categories</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点"><span class="toc-number">1.</span> <span class="toc-text">重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new的时候干了什么"><span class="toc-number">2.</span> <span class="toc-text">new的时候干了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数的执行过程"><span class="toc-number">3.</span> <span class="toc-text">构造函数的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数的返回值"><span class="toc-number">4.</span> <span class="toc-text">构造函数的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#这一次我们用-new-来写"><span class="toc-number">5.</span> <span class="toc-text">这一次我们用 new 来写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意-constructor-属性"><span class="toc-number">5.1.</span> <span class="toc-text">注意 constructor 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于Object-prototype-constructor"><span class="toc-number">6.</span> <span class="toc-text">关于Object.prototype.constructor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#改变constructor"><span class="toc-number">6.1.</span> <span class="toc-text">改变constructor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于Object-create和new区别"><span class="toc-number">7.</span> <span class="toc-text">关于Object.create和new区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proto-和prototype的区别"><span class="toc-number">8.</span> <span class="toc-text">__proto__和prototype的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分别是什么"><span class="toc-number">8.1.</span> <span class="toc-text">分别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用是什么"><span class="toc-number">8.2.</span> <span class="toc-text">作用是什么</span></a></li></ol></li></ol></div></div><div class="post-content"><p>普通对象 Object 和 函数对象 Function。<br>一般而言，通过 new Function 产生的对象是函数对象，其他对象都是普通对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,  <span class="string">'console.log(x)'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    <span class="keyword">typeof</span> f1,</span><br><span class="line">    <span class="keyword">typeof</span> f2,</span><br><span class="line">    <span class="keyword">typeof</span> f3,</span><br><span class="line">    <span class="keyword">typeof</span> o1,</span><br><span class="line">    <span class="keyword">typeof</span> o2,</span><br><span class="line">    <span class="keyword">typeof</span> o3</span><br><span class="line">);</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">function</span> <span class="title">function</span> <span class="title">object</span> <span class="title">object</span> <span class="title">object</span></span></span><br></pre></td></tr></table></figure></p>
<p>f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。<br>Function 是JS自带的对象，f1，f2 在创建的时候，JS会自动通过 new Function() 的方式来构建这些对象，因此，这三个对象都是通过 new Function() 创建的。<br>在 Javascript 中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然…<br>怎么理解呢? 很简单，看 o3 是不是通过 new Function 产生的，显然不是，既然不是函数对象，那就是<strong>普通对象</strong>。</p>
<p>在 JS 中，每当创建一个函数对象 f1 时，该对象中都会内置一些属性，其中包括 prototype 和 __proto__， prototype 即原型对象，它记录着f1的一些属性和方法。</p>
<p>需要注意的是，prototype 对 f1 是不可见的，也就是说，f1 不会查找 prototype 中的属性和方法。 </p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul>
<li>原型链的形成真正是靠<strong>proto</strong> 而非prototype，当JS引擎执行对象的方法时，先查找对象本身是否存在该方法，如果不存在，会在原型链上查找，但不会查找自身的prototype。</li>
<li>一个对象的 __proto__ 记录着自己的原型链，决定了自身的数据类型，改变 __proto__ 就等于改变对象的数据类型。</li>
<li>函数的 prototype 不属于自身的原型链，它是创建子类的核心，决定了子类的数据类型，是连接子类原型链的桥梁。</li>
<li>在原型对象上定义方法和属性，是为了被子类继承和使用。</li>
</ul>
<p><img src="/images/prototype.jpg" alt="图解"></p>
<h2 id="new的时候干了什么"><a href="#new的时候干了什么" class="headerlink" title="new的时候干了什么"></a>new的时候干了什么</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.color = <span class="string">"black"</span>;</span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Animal(<span class="string">"cat"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    cat.name,  <span class="comment">//cat</span></span><br><span class="line">    cat.height <span class="comment">//undefined</span></span><br><span class="line">);</span><br><span class="line">cat.say(); <span class="comment">//I'm cat</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    Animal.name, <span class="comment">//Animal</span></span><br><span class="line">    Animal.color <span class="comment">//back</span></span><br><span class="line">);</span><br><span class="line">Animal.say(); <span class="comment">//Animal.say is not a function</span></span><br></pre></td></tr></table></figure>
<p>关键 <code>var cat = new Animal(&quot;cat&quot;);</code><br>JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj, <span class="string">'cat'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.创建一个空对象obj;</p>
<p>2.把obj的<strong>proto</strong> 指向Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</p>
<p>3.在obj对象的执行环境调用Animal函数并传递参数“cat”。 相当于var result = obj.Animal(“cat”)。<br>当这句执行完之后，obj便产生了属性name并赋值为”cat”。</p>
<p>4.考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 士兵(<span class="params">ID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> 临时对象 = &#123;&#125;  <span class="comment">//创建临时对象</span></span><br><span class="line">  临时对象.__proto__ = 士兵.原型   <span class="comment">//绑定原型</span></span><br><span class="line">  临时对象.ID = ID  </span><br><span class="line">  临时对象.生命值 = <span class="number">42</span></span><br><span class="line">  <span class="keyword">return</span> 临时对象  <span class="comment">//return出对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">士兵.原型 = &#123;</span><br><span class="line">  兵种:<span class="string">"美国大兵"</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*走俩步的代码*/</span>&#125;，</span><br><span class="line">  奔跑:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> 士兵们 = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">  士兵们.push(士兵(i))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure>
<p>1.不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>2.不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>3.不用 return 临时对象，因为 new 会帮你做；<br>4.不要给原型想名字了，因为 new 指定名字为 prototype。</p>
<h2 id="构造函数的执行过程"><a href="#构造函数的执行过程" class="headerlink" title="构造函数的执行过程"></a>构造函数的执行过程</h2><p>当一个函数创建好以后，我们并不知道它是不是构造函数，函数名为大写，我们也不能确定。只有当一个函数以 new 关键字来调用的时候，我们才能说它是一个构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">"black"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender, hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'zs'</span>, <span class="string">'男'</span>, <span class="string">'basketball'</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们还是以上面的 Person 为例。此时，构造函数会有以下几个执行过程：</p>
<ol>
<li>当以 <code>new</code> 关键字调用时，会创建一个新的内存空间，标记为 <code>Person</code> 的实例。</li>
<li>函数体内部的 <code>this</code> 指向该内存<br>通过以上两步，我们就可以得出这样的结论。<br>每当创建一个实例的时候，就会创建一个新的内存空间(#f2, #f3)，创建 #f2 的时候，函数体内部的 this 指向 #f2, 创建 #f3 的时候，函数体内部的 this 指向 #f3。</li>
<li>执行函数体内的代码<br>通过上面的讲解，你就可以知道，给 this 添加属性，就相当于给实例添加属性。</li>
<li>默认返回 this 。<br>由于函数体内部的 <code>this</code> 指向新创建的内存空间，默认返回 <code>this</code> ，就相当于默认返回了该内存空间，也就是上图中的 #f1。此时，#f1的内存空间被变量 p1 所接受。也就是说 p1 这个变量，保存的内存地址就是 #f1，同时被标记为 <code>Person</code> 的实例。</li>
</ol>
<p>以上就是构造函数的整个执行过程。</p>
<h2 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h2><p>构造函数执行过程的最后一步是默认返回 this 。言外之意，构造函数的返回值还有其它情况。下面我们就来聊聊关于构造函数返回值的问题。<br>(1) 没有手动添加返回值，默认返回 this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'zhangsan'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person1();</span><br></pre></td></tr></table></figure></p>
<p>当用 <code>new</code> 关键字调用时，产生一个新的内存空间 #f11，并标记为 <code>Person1</code> 的实例；接着，函数体内部的 <code>this</code> 指向该内存空间 #f11；执行函数体内部的代码；由于函数体内部的 <code>this</code> 指向该内存空间，而该内存空间又被变量 p1 所接收，所以 p1 中就会有一个 name 属性，属性值为 ‘zhangsan’。</p>
<p>(2) 手动添加一个基本数据类型的返回值，最终还是返回 this。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">28</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person2();</span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<p>(3) 手动添加一个复杂数据类型(对象)的返回值，最终返回该对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = <span class="string">'180'</span>;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Person3();</span><br><span class="line"><span class="built_in">console</span>.log(p3.height);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.length);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(p3[<span class="number">0</span>]);      <span class="comment">// 'a'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.gender = <span class="string">'男'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">gender</span>: <span class="string">'中性'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> Person4();</span><br><span class="line"><span class="built_in">console</span>.log(p4.gender);  <span class="comment">// '中性'</span></span><br></pre></td></tr></table></figure>
<p>可以看出：在JavaScript构造函数中：如果return值类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型；</p>
<h2 id="这一次我们用-new-来写"><a href="#这一次我们用-new-来写" class="headerlink" title="这一次我们用 new 来写"></a>这一次我们用 new 来写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 士兵(<span class="params">ID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ID = ID</span><br><span class="line">  <span class="keyword">this</span>.生命值 = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">士兵.prototype = &#123;</span><br><span class="line">  兵种:<span class="string">"美国大兵"</span>,</span><br><span class="line">  攻击力:<span class="number">5</span>,</span><br><span class="line">  行走:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*走俩步的代码*/</span>&#125;,</span><br><span class="line">  奔跑:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*狂奔的代码*/</span>  &#125;,</span><br><span class="line">  死亡:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*Go die*/</span>    &#125;,</span><br><span class="line">  攻击:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*糊他熊脸*/</span>   &#125;,</span><br><span class="line">  防御:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/*护脸*/</span>       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 士兵们 = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">  士兵们.push(<span class="keyword">new</span> 士兵(i))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">兵营.批量制造(士兵们)</span><br></pre></td></tr></table></figure>
<h3 id="注意-constructor-属性"><a href="#注意-constructor-属性" class="headerlink" title="注意 constructor 属性"></a>注意 constructor 属性</h3><p>new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">士兵.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: 士兵</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">士兵.prototype.兵种 = <span class="string">"美国大兵"</span></span><br><span class="line">士兵.prototype.攻击力 = <span class="number">5</span></span><br><span class="line">士兵.prototype.行走 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">士兵.prototype.奔跑 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  &#125;</span><br><span class="line">士兵.prototype.死亡 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在javascript中, 通过new可以产生原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法。因此，new存在的意义在于它实现了javascript中的继承，而不仅仅是实例化了一个对象！</p>
<h2 id="关于Object-prototype-constructor"><a href="#关于Object-prototype-constructor" class="headerlink" title="关于Object.prototype.constructor"></a>关于Object.prototype.constructor</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">mozilla</a>上的描述：返回创建实例对象的 Object 构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如1，true和”test”，该值只可读。 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor === Foo);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>但是可能出于不理解，或者很多的误操作，都会导致我们.constructor指向的丢失。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;&#125; <span class="comment">// 重新对prototype赋值，constructor就没了</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(a1.constructor === Foo);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.constructor === <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Foo.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writeable:<span class="literal">true</span>,</span><br><span class="line">    configureable: <span class="literal">true</span>,</span><br><span class="line">    value: Foo <span class="comment">// 让.constructor指向Foo</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="改变constructor"><a href="#改变constructor" class="headerlink" title="改变constructor"></a>改变constructor</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentWithStatic</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">ParentWithStatic.startPosition = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span> &#125;;</span><br><span class="line">ParentWithStatic.getStartPosition = <span class="function"><span class="keyword">function</span> <span class="title">getStartPosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.startPosition;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.position = &#123;</span><br><span class="line">    x: x,</span><br><span class="line">    y: y</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(ParentWithStatic.prototype); </span><br><span class="line">Child.prototype.constructor = Child; <span class="comment">//在这里如果不指向回Child，就会在创建的时候指向ParentWithStatic, 下面的引用就会报错</span></span><br><span class="line"></span><br><span class="line">Child.prototype.getOffsetByInitialPosition = <span class="function"><span class="keyword">function</span> <span class="title">getOffsetByInitialPosition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> position = <span class="keyword">this</span>.position;</span><br><span class="line">  <span class="keyword">var</span> startPosition = <span class="keyword">this</span>.constructor.getStartPosition(); <span class="comment">// error undefined is not a function, since the constructor is Child</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    offsetX: startPosition.x - position.x,</span><br><span class="line">    offsetY: startPosition.y - position.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至于为什么要做<code>Child.prototype.constructor = Child</code>这样的修正？<br>可以参考<a href="https://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property/4013295#4013141" target="_blank" rel="noopener">这里</a></p>
<p>所以，即使不做这样的修正也不会有什么影响，它主要防止一种情况下出错，就是你显式地去使用构造函数。比如，我并不知道woman是由哪个函数实例化出来的，但是我想clone一个，这时就可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Woman();</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> woman1 = woman.constructor();</span><br></pre></td></tr></table></figure>
<h2 id="关于Object-create和new区别"><a href="#关于Object-create和new区别" class="headerlink" title="关于Object.create和new区别"></a>关于Object.create和new区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Base = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(Base);</span><br><span class="line"><span class="built_in">console</span>.log(o1)  <span class="comment">//Base &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2)  <span class="comment">//Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建函数</span></span><br><span class="line"><span class="built_in">Object</span>.create =  <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new 做了什么</span></span><br><span class="line">JavaScript 实际上执行的是：</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o1.__proto__ = Base.prototype;</span><br><span class="line">Base.call(o1);</span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 以字面量方式创建的空对象就相当于:</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure>
<p>为什么通过Object.create构造的连Base原型上的属性都访问不到，因为他压根就没有指向他的prototype。这也就说明了__proto__ 和 prototype 的区别。所以上面在prototype定义的a，只是Base的 prototype对象上的一个属性。</p>
<p>再来看看就是：<br>1.new关键字必须是以function定义的。<br>2.Object.create 则 function和object都可以进行构建</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>new</th>
<th>Object.create</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造函数</td>
<td>保留原构造函数属性</td>
<td>丢失原构造函数属性</td>
</tr>
<tr>
<td>原型链</td>
<td>原构造函数prototype属性</td>
<td>原构造函数/（对象）本身</td>
</tr>
<tr>
<td>作用对象</td>
<td>function</td>
<td>function和object</td>
</tr>
</tbody>
</table>
<h2 id="proto-和prototype的区别"><a href="#proto-和prototype的区别" class="headerlink" title="__proto__和prototype的区别"></a><code>__proto__</code>和prototype的区别</h2><p><code>__proto__</code>（隐式原型）与<code>prototype</code>（显式原型）</p>
<h3 id="分别是什么"><a href="#分别是什么" class="headerlink" title="分别是什么"></a>分别是什么</h3><p>显式原型 explicit prototype property:<br>每一个函数在创建之后都会拥有一个名为<code>prototype</code>的属性，这个属性指向函数的原型对象<br><strong>注意：</strong> ECMAScript5中的Function.bind()方法返回的对象除外</p>
<p>隐式原型 implicit prototype link：<br>JavaScript中任意对象都有一个内置属性<code>[[prototype]]</code>，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。ES5中有了对于这个内置属性标准的Get方法<code>Object.getPrototypeOf()</code>.</p>
<p>二者的关系: 隐式原型指向创建这个对象的函数(constructor)的prototype</p>
<h3 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h3><p>显式原型的作用：用来实现基于原型的继承与属性的共享。</p>
<blockquote>
<p>ECMAScript does not use classes such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via constructors which create objects and then execute code that initialises all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named “prototype” that is used to implement prototype-based inheritance and shared properties.Objects are created by using constructors in new expressions; for example, new Date(2009,11) creates a new Date object. —-<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.1" target="_blank" rel="noopener">ECMAScript Language Specification</a></p>
</blockquote>
<p>隐式原型的作用：构成原型链，指向创建这个对象的函数的显式原型，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<code>__proto__</code>依次查找。</p>
<blockquote>
<p>Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “prototype” —-<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.1" target="_blank" rel="noopener">ECMAScript Language Specification</a></p>
</blockquote>
<p><code>__proto__</code>是每个对象都有的一个属性，而<code>prototype</code>是函数才会有的属性<br><code>__proto__</code>指向的是当前对象的原型对象，而<code>prototype</code>指向的，是以当前函数作为构造函数构造出来的对象的原型对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GirlFriend</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Alice"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GirlFriend.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true 对象都是由object创建</span></span><br><span class="line">GirlFriend.prototype.constructor === GirlFriend  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> GirlFriend();</span><br><span class="line">myObject.__proto__ === GirlFriend.prototype</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-nav"><a class="pre" href="/2019/02/14/javascript-event/">事件委托捕获冒泡</a><a class="next" href="/2019/01/01/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/categories/">categories</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/IM/" style="font-size: 15px;">IM</a> <a href="/tags/WebRTC/" style="font-size: 15px;">WebRTC</a> <a href="/tags/Promise/" style="font-size: 15px;">Promise</a> <a href="/tags/console/" style="font-size: 15px;">console</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/web3/" style="font-size: 15px;">web3</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/资料/" style="font-size: 15px;">资料</a> <a href="/tags/cavnas/" style="font-size: 15px;">cavnas</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/题库/" style="font-size: 15px;">题库</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/html/" style="font-size: 15px;">html</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/08/27/eip-712/">了解 EIP712</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/16/truffle-use/">Truffle的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/30/nextjs-and-cms/">Nextjs + Tailwind css + Strapi CMS 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/24/date-timezone/">将 JavaScript 日期初始化为特定时区</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/10/30/directory-structure/">项目目录结构推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/input-blur/">input 失去焦点重复校验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/tampermonkey/">油猴脚本教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/09/auto-jump-history/">页面加载时使用脚本自动跳转到新页面浏览器不会产生历史记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/flex-finally-width/">关于flex布局的最后一行元素宽度问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/ unicode/">Unicode编码和解码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://translate.google.cn/#en/zh-CN" title="谷歌翻译" target="_blank">谷歌翻译</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><div id="landlord"><div class="message"></div><canvas class="live2d" id="live2d" width="280" height="250"></canvas></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="//lib.baomitu.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/contextMenu.js?v=0.0.0"></script><script type="text/javascript" src="/js/live2d.js?v=0.0.0"></script><script type="text/javascript" src="/js/message.js?v=0.0.0"></script></div></body></html>